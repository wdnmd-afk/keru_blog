{
    "basicFunctionMock": {
        "title": "基础函数 Mock",
        "language": "javascript",
        "code": "// 创建 Mock 函数\nconst mockFn = jest.fn();\n\n// 使用 Mock 函数\nmockFn('arg1', 'arg2');\nmockFn('arg3');\n\n// 验证调用\nexpect(mockFn).toHaveBeenCalled();\nexpect(mockFn).toHaveBeenCalledTimes(2);\nexpect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');\nexpect(mockFn).toHaveBeenLastCalledWith('arg3');\n\n// 检查调用历史\nexpect(mockFn.mock.calls).toEqual([\n  ['arg1', 'arg2'],\n  ['arg3']\n]);\n\n// Mock 现有函数\nconst originalFunction = (x, y) => x + y;\nconst mockFunction = jest.fn(originalFunction);\n\n// 使用 Mock\nconst result = mockFunction(2, 3);\nexpect(result).toBe(5);\nexpect(mockFunction).toHaveBeenCalledWith(2, 3);\n\n// 清除 Mock 历史\nmockFunction.mockClear();\nexpect(mockFunction).not.toHaveBeenCalled();\n\n// 重置 Mock\nmockFunction.mockReset();\nexpect(mockFunction.mock.calls).toHaveLength(0);\n\n// 恢复原始实现\nmockFunction.mockRestore();"
    },
    "mockReturnValues": {
        "title": "Mock 返回值控制",
        "language": "javascript",
        "code": "// 设置返回值\nconst mockFn = jest.fn();\nmockFn.mockReturnValue(42);\n\nexpect(mockFn()).toBe(42);\nexpect(mockFn()).toBe(42); // 每次调用都返回相同值\n\n// 设置一次性返回值\nmockFn.mockReturnValueOnce(1)\n      .mockReturnValueOnce(2)\n      .mockReturnValue(3);\n\nexpect(mockFn()).toBe(1); // 第一次调用\nexpect(mockFn()).toBe(2); // 第二次调用\nexpect(mockFn()).toBe(3); // 后续调用\nexpect(mockFn()).toBe(3);\n\n// Promise 返回值\nconst asyncMockFn = jest.fn();\nasyncMockFn.mockResolvedValue('success');\n\nawait expect(asyncMockFn()).resolves.toBe('success');\n\n// Promise 拒绝\nasyncMockFn.mockRejectedValue(new Error('failed'));\n\nawait expect(asyncMockFn()).rejects.toThrow('failed');\n\n// 一次性 Promise 返回值\nasyncMockFn.mockResolvedValueOnce('first')\n           .mockResolvedValueOnce('second')\n           .mockResolvedValue('default');\n\nexpect(await asyncMockFn()).toBe('first');\nexpect(await asyncMockFn()).toBe('second');\nexpect(await asyncMockFn()).toBe('default');\n\n// 自定义实现\nconst customMockFn = jest.fn((x, y) => {\n  if (x > y) return 'greater';\n  if (x < y) return 'less';\n  return 'equal';\n});\n\nexpect(customMockFn(5, 3)).toBe('greater');\nexpect(customMockFn(2, 7)).toBe('less');\nexpect(customMockFn(4, 4)).toBe('equal');\n\n// 动态实现\nconst dynamicMockFn = jest.fn();\ndynamicMockFn.mockImplementation((name) => `Hello, ${name}!`);\n\nexpect(dynamicMockFn('World')).toBe('Hello, World!');\n\n// 一次性实现\ndynamicMockFn.mockImplementationOnce((name) => `Hi, ${name}!`)\n             .mockImplementation((name) => `Hey, ${name}!`);\n\nexpect(dynamicMockFn('Alice')).toBe('Hi, Alice!');\nexpect(dynamicMockFn('Bob')).toBe('Hey, Bob!');"
    },
    "moduleMock": {
        "title": "完整模块 Mock",
        "language": "javascript",
        "code": "// 要被 Mock 的模块：userService.js\nexport const getUser = async (id) => {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n};\n\nexport const createUser = async (userData) => {\n  const response = await fetch('/api/users', {\n    method: 'POST',\n    body: JSON.stringify(userData)\n  });\n  return response.json();\n};\n\nexport const deleteUser = async (id) => {\n  await fetch(`/api/users/${id}`, { method: 'DELETE' });\n};\n\n// 测试文件：userService.test.js\n\n// 方法1：使用 jest.mock() 自动 Mock\njest.mock('./userService');\n\nimport * as userService from './userService';\n\n// TypeScript 中需要类型断言\nconst mockGetUser = userService.getUser as jest.MockedFunction<typeof userService.getUser>;\nconst mockCreateUser = userService.createUser as jest.MockedFunction<typeof userService.createUser>;\n\ndescribe('UserService Mock 测试', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('应该获取用户信息', async () => {\n    const mockUser = { id: 1, name: 'John Doe' };\n    mockGetUser.mockResolvedValue(mockUser);\n    \n    const user = await userService.getUser(1);\n    \n    expect(user).toEqual(mockUser);\n    expect(mockGetUser).toHaveBeenCalledWith(1);\n  });\n  \n  test('应该创建新用户', async () => {\n    const userData = { name: 'Jane Doe', email: 'jane@example.com' };\n    const createdUser = { id: 2, ...userData };\n    \n    mockCreateUser.mockResolvedValue(createdUser);\n    \n    const result = await userService.createUser(userData);\n    \n    expect(result).toEqual(createdUser);\n    expect(mockCreateUser).toHaveBeenCalledWith(userData);\n  });\n});\n\n// 方法2：手动 Mock 模块\njest.mock('./userService', () => ({\n  getUser: jest.fn(),\n  createUser: jest.fn(),\n  deleteUser: jest.fn()\n}));\n\n// 方法3：使用 __mocks__ 目录\n// 创建 __mocks__/userService.js 文件\nexport const getUser = jest.fn();\nexport const createUser = jest.fn();\nexport const deleteUser = jest.fn();\n\n// 在测试中启用 Mock\njest.mock('./userService'); // 自动使用 __mocks__ 中的实现\n\n// 方法4：条件 Mock\nif (process.env.NODE_ENV === 'test') {\n  jest.mock('./userService');\n}\n\n// 方法5：动态 Mock\nconst mockUserService = () => {\n  return jest.doMock('./userService', () => ({\n    getUser: jest.fn().mockResolvedValue({ id: 1, name: 'Mock User' }),\n    createUser: jest.fn().mockResolvedValue({ id: 2, name: 'New User' }),\n    deleteUser: jest.fn().mockResolvedValue(undefined)\n  }));\n};\n\ndescribe('动态 Mock 测试', () => {\n  beforeEach(() => {\n    mockUserService();\n  });\n  \n  test('使用动态 Mock', async () => {\n    const { getUser } = await import('./userService');\n    const user = await getUser(1);\n    expect(user.name).toBe('Mock User');\n  });\n});"
    },
    "partialModuleMock": {
        "title": "部分模块 Mock",
        "language": "javascript",
        "code": "// 原始模块：mathUtils.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\nexport const multiply = (a, b) => a * b;\nexport const divide = (a, b) => {\n  if (b === 0) throw new Error('Division by zero');\n  return a / b;\n};\n\nexport const PI = 3.14159;\nexport const E = 2.71828;\n\n// 部分 Mock - 只 Mock 部分函数\njest.mock('./mathUtils', () => ({\n  ...jest.requireActual('./mathUtils'), // 保留原始实现\n  divide: jest.fn(), // 只 Mock divide 函数\n  PI: 3.14 // 覆盖常量\n}));\n\nimport * as mathUtils from './mathUtils';\n\nconst mockDivide = mathUtils.divide as jest.MockedFunction<typeof mathUtils.divide>;\n\ndescribe('部分模块 Mock 测试', () => {\n  test('原始函数应该正常工作', () => {\n    expect(mathUtils.add(2, 3)).toBe(5);\n    expect(mathUtils.subtract(5, 2)).toBe(3);\n    expect(mathUtils.multiply(3, 4)).toBe(12);\n  });\n  \n  test('Mock 函数应该被控制', () => {\n    mockDivide.mockReturnValue(2.5);\n    \n    expect(mathUtils.divide(10, 4)).toBe(2.5);\n    expect(mockDivide).toHaveBeenCalledWith(10, 4);\n  });\n  \n  test('Mock 常量应该被覆盖', () => {\n    expect(mathUtils.PI).toBe(3.14);\n    expect(mathUtils.E).toBe(2.71828); // 保持原值\n  });\n});\n\n// 使用 spyOn 进行部分 Mock\nimport * as originalMathUtils from './mathUtils';\n\ndescribe('使用 spyOn 的部分 Mock', () => {\n  let divideSpy: jest.SpyInstance;\n  \n  beforeEach(() => {\n    divideSpy = jest.spyOn(originalMathUtils, 'divide');\n  });\n  \n  afterEach(() => {\n    divideSpy.mockRestore();\n  });\n  \n  test('应该监视 divide 函数', () => {\n    divideSpy.mockReturnValue(5);\n    \n    const result = originalMathUtils.divide(10, 2);\n    \n    expect(result).toBe(5);\n    expect(divideSpy).toHaveBeenCalledWith(10, 2);\n  });\n  \n  test('其他函数应该正常工作', () => {\n    expect(originalMathUtils.add(2, 3)).toBe(5);\n    expect(originalMathUtils.multiply(3, 4)).toBe(12);\n  });\n});\n\n// 条件部分 Mock\nconst shouldMockDivide = process.env.MOCK_DIVIDE === 'true';\n\nif (shouldMockDivide) {\n  jest.mock('./mathUtils', () => ({\n    ...jest.requireActual('./mathUtils'),\n    divide: jest.fn().mockReturnValue(0)\n  }));\n}\n\n// 运行时部分 Mock\ndescribe('运行时部分 Mock', () => {\n  test('动态决定是否 Mock', () => {\n    const shouldMock = Math.random() > 0.5;\n    \n    if (shouldMock) {\n      const spy = jest.spyOn(mathUtils, 'divide').mockReturnValue(999);\n      expect(mathUtils.divide(10, 2)).toBe(999);\n      spy.mockRestore();\n    } else {\n      expect(mathUtils.divide(10, 2)).toBe(5);\n    }\n  });\n});"
    },
    "objectSpy": {
        "title": "对象方法 Spy",
        "language": "javascript",
        "code": "// 被监视的对象\nclass UserManager {\n  constructor() {\n    this.users = [];\n  }\n  \n  addUser(user) {\n    this.users.push(user);\n    this.logAction('add', user);\n    return user;\n  }\n  \n  removeUser(id) {\n    const index = this.users.findIndex(u => u.id === id);\n    if (index !== -1) {\n      const user = this.users.splice(index, 1)[0];\n      this.logAction('remove', user);\n      return user;\n    }\n    return null;\n  }\n  \n  logAction(action, user) {\n    console.log(`${action}: ${user.name}`);\n  }\n  \n  getUsers() {\n    return [...this.users];\n  }\n}\n\n// Spy 测试\ndescribe('UserManager Spy 测试', () => {\n  let userManager;\n  let logSpy;\n  \n  beforeEach(() => {\n    userManager = new UserManager();\n    // 监视 logAction 方法\n    logSpy = jest.spyOn(userManager, 'logAction');\n  });\n  \n  afterEach(() => {\n    // 恢复原始实现\n    logSpy.mockRestore();\n  });\n  \n  test('添加用户时应该调用 logAction', () => {\n    const user = { id: 1, name: 'John' };\n    \n    userManager.addUser(user);\n    \n    expect(logSpy).toHaveBeenCalledWith('add', user);\n    expect(logSpy).toHaveBeenCalledTimes(1);\n  });\n  \n  test('删除用户时应该调用 logAction', () => {\n    const user = { id: 1, name: 'John' };\n    userManager.addUser(user);\n    \n    // 清除之前的调用记录\n    logSpy.mockClear();\n    \n    userManager.removeUser(1);\n    \n    expect(logSpy).toHaveBeenCalledWith('remove', user);\n    expect(logSpy).toHaveBeenCalledTimes(1);\n  });\n  \n  test('可以 Mock Spy 的返回值', () => {\n    // Mock logAction 方法，但仍然监视调用\n    logSpy.mockImplementation((action, user) => {\n      return `Mocked: ${action} - ${user.name}`;\n    });\n    \n    const user = { id: 1, name: 'Jane' };\n    userManager.addUser(user);\n    \n    expect(logSpy).toHaveBeenCalledWith('add', user);\n    // 原始的 console.log 不会被调用，因为被 Mock 了\n  });\n  \n  test('可以监视但保持原始行为', () => {\n    // 不 Mock 实现，只监视\n    const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});\n    \n    const user = { id: 1, name: 'Bob' };\n    userManager.addUser(user);\n    \n    expect(logSpy).toHaveBeenCalledWith('add', user);\n    expect(consoleSpy).toHaveBeenCalledWith('add: Bob');\n    \n    consoleSpy.mockRestore();\n  });\n});\n\n// 监视静态方法\nclass MathHelper {\n  static add(a, b) {\n    return a + b;\n  }\n  \n  static multiply(a, b) {\n    return a * b;\n  }\n}\n\ndescribe('静态方法 Spy', () => {\n  test('应该监视静态方法', () => {\n    const addSpy = jest.spyOn(MathHelper, 'add');\n    \n    const result = MathHelper.add(2, 3);\n    \n    expect(result).toBe(5);\n    expect(addSpy).toHaveBeenCalledWith(2, 3);\n    \n    addSpy.mockRestore();\n  });\n  \n  test('可以 Mock 静态方法', () => {\n    const multiplySpy = jest.spyOn(MathHelper, 'multiply')\n                           .mockReturnValue(100);\n    \n    const result = MathHelper.multiply(3, 4);\n    \n    expect(result).toBe(100);\n    expect(multiplySpy).toHaveBeenCalledWith(3, 4);\n    \n    multiplySpy.mockRestore();\n  });\n});\n\n// 监视 getter 和 setter\nclass Counter {\n  constructor() {\n    this._count = 0;\n  }\n  \n  get count() {\n    return this._count;\n  }\n  \n  set count(value) {\n    if (value < 0) {\n      throw new Error('Count cannot be negative');\n    }\n    this._count = value;\n  }\n}\n\ndescribe('Getter/Setter Spy', () => {\n  test('应该监视 getter', () => {\n    const counter = new Counter();\n    const getSpy = jest.spyOn(counter, 'count', 'get');\n    \n    const value = counter.count;\n    \n    expect(value).toBe(0);\n    expect(getSpy).toHaveBeenCalled();\n    \n    getSpy.mockRestore();\n  });\n  \n  test('应该监视 setter', () => {\n    const counter = new Counter();\n    const setSpy = jest.spyOn(counter, 'count', 'set');\n    \n    counter.count = 5;\n    \n    expect(counter.count).toBe(5);\n    expect(setSpy).toHaveBeenCalledWith(5);\n    \n    setSpy.mockRestore();\n  });\n});"
    },
    "globalSpy": {
        "title": "全局函数 Spy",
        "language": "javascript",
        "code": "// 监视全局对象和函数\ndescribe('全局函数 Spy 测试', () => {\n  describe('Date 对象 Spy', () => {\n    test('应该监视 Date.now', () => {\n      const dateSpy = jest.spyOn(Date, 'now')\n                         .mockReturnValue(1234567890000);\n      \n      const timestamp = Date.now();\n      \n      expect(timestamp).toBe(1234567890000);\n      expect(dateSpy).toHaveBeenCalled();\n      \n      dateSpy.mockRestore();\n    });\n    \n    test('应该 Mock Date 构造函数', () => {\n      const mockDate = new Date('2023-01-01T00:00:00.000Z');\n      const dateSpy = jest.spyOn(global, 'Date')\n                         .mockImplementation(() => mockDate);\n      \n      const date = new Date();\n      \n      expect(date).toBe(mockDate);\n      expect(dateSpy).toHaveBeenCalled();\n      \n      dateSpy.mockRestore();\n    });\n  });\n  \n  describe('Math 对象 Spy', () => {\n    test('应该监视 Math.random', () => {\n      const randomSpy = jest.spyOn(Math, 'random')\n                           .mockReturnValue(0.5);\n      \n      const value = Math.random();\n      \n      expect(value).toBe(0.5);\n      expect(randomSpy).toHaveBeenCalled();\n      \n      randomSpy.mockRestore();\n    });\n    \n    test('应该监视 Math.floor', () => {\n      const floorSpy = jest.spyOn(Math, 'floor');\n      \n      const result = Math.floor(4.7);\n      \n      expect(result).toBe(4);\n      expect(floorSpy).toHaveBeenCalledWith(4.7);\n      \n      floorSpy.mockRestore();\n    });\n  });\n  \n  describe('console 对象 Spy', () => {\n    test('应该监视 console.log', () => {\n      const consoleSpy = jest.spyOn(console, 'log')\n                            .mockImplementation(() => {});\n      \n      console.log('Hello, World!');\n      \n      expect(consoleSpy).toHaveBeenCalledWith('Hello, World!');\n      \n      consoleSpy.mockRestore();\n    });\n    \n    test('应该监视 console.error', () => {\n      const errorSpy = jest.spyOn(console, 'error')\n                          .mockImplementation(() => {});\n      \n      console.error('Error message');\n      \n      expect(errorSpy).toHaveBeenCalledWith('Error message');\n      \n      errorSpy.mockRestore();\n    });\n  });\n  \n  describe('setTimeout/setInterval Spy', () => {\n    beforeEach(() => {\n      jest.useFakeTimers();\n    });\n    \n    afterEach(() => {\n      jest.useRealTimers();\n    });\n    \n    test('应该监视 setTimeout', () => {\n      const timeoutSpy = jest.spyOn(global, 'setTimeout');\n      const callback = jest.fn();\n      \n      setTimeout(callback, 1000);\n      \n      expect(timeoutSpy).toHaveBeenCalledWith(callback, 1000);\n      \n      // 快进时间\n      jest.advanceTimersByTime(1000);\n      expect(callback).toHaveBeenCalled();\n      \n      timeoutSpy.mockRestore();\n    });\n    \n    test('应该监视 setInterval', () => {\n      const intervalSpy = jest.spyOn(global, 'setInterval');\n      const callback = jest.fn();\n      \n      setInterval(callback, 500);\n      \n      expect(intervalSpy).toHaveBeenCalledWith(callback, 500);\n      \n      // 快进时间，触发多次回调\n      jest.advanceTimersByTime(1500);\n      expect(callback).toHaveBeenCalledTimes(3);\n      \n      intervalSpy.mockRestore();\n    });\n  });\n  \n  describe('fetch API Spy', () => {\n    test('应该监视 fetch', async () => {\n      const mockResponse = {\n        ok: true,\n        json: jest.fn().mockResolvedValue({ id: 1, name: 'John' })\n      };\n      \n      const fetchSpy = jest.spyOn(global, 'fetch')\n                          .mockResolvedValue(mockResponse as any);\n      \n      const response = await fetch('/api/users/1');\n      const data = await response.json();\n      \n      expect(fetchSpy).toHaveBeenCalledWith('/api/users/1');\n      expect(data).toEqual({ id: 1, name: 'John' });\n      \n      fetchSpy.mockRestore();\n    });\n  });\n  \n  describe('localStorage Spy', () => {\n    test('应该监视 localStorage', () => {\n      const getItemSpy = jest.spyOn(Storage.prototype, 'getItem')\n                            .mockReturnValue('mock-value');\n      const setItemSpy = jest.spyOn(Storage.prototype, 'setItem')\n                            .mockImplementation(() => {});\n      \n      localStorage.setItem('key', 'value');\n      const value = localStorage.getItem('key');\n      \n      expect(setItemSpy).toHaveBeenCalledWith('key', 'value');\n      expect(getItemSpy).toHaveBeenCalledWith('key');\n      expect(value).toBe('mock-value');\n      \n      getItemSpy.mockRestore();\n      setItemSpy.mockRestore();\n    });\n  });\n});\n\n// 监视第三方库\ndescribe('第三方库 Spy', () => {\n  test('应该监视 axios', async () => {\n    // 假设已安装 axios\n    const axios = require('axios');\n    \n    const axiosSpy = jest.spyOn(axios, 'get')\n                        .mockResolvedValue({\n                          data: { message: 'success' }\n                        });\n    \n    const response = await axios.get('/api/data');\n    \n    expect(axiosSpy).toHaveBeenCalledWith('/api/data');\n    expect(response.data.message).toBe('success');\n    \n    axiosSpy.mockRestore();\n  });\n});"
    }
}
