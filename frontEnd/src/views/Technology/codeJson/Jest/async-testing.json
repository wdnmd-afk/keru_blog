{
  "basicPromiseTesting": {
    "title": "基础 Promise 测试",
    "language": "javascript",
    "code": "// 被测试的异步函数\nfunction fetchUser(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 1) {\n        resolve({ id: 1, name: 'John Doe' });\n      } else {\n        reject(new Error('User not found'));\n      }\n    }, 100);\n  });\n}\n\nfunction fetchUserData(id) {\n  return fetch(`/api/users/${id}`)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    });\n}\n\n// Promise 测试方法\ndescribe('Promise 测试', () => {\n  // 方法1: 返回 Promise\n  test('应该获取用户信息 - 返回Promise', () => {\n    return fetchUser(1).then(user => {\n      expect(user.name).toBe('John Doe');\n    });\n  });\n  \n  // 方法2: 使用 resolves 匹配器\n  test('应该获取用户信息 - resolves', () => {\n    return expect(fetchUser(1)).resolves.toEqual({\n      id: 1,\n      name: 'John Doe'\n    });\n  });\n  \n  // 方法3: 使用 rejects 匹配器测试错误\n  test('应该处理用户不存在的情况 - rejects', () => {\n    return expect(fetchUser(999)).rejects.toThrow('User not found');\n  });\n  \n  // 方法4: 链式 Promise 测试\n  test('应该处理链式Promise', () => {\n    return fetchUser(1)\n      .then(user => {\n        expect(user.id).toBe(1);\n        return fetchUser(user.id);\n      })\n      .then(user => {\n        expect(user.name).toBe('John Doe');\n      });\n  });\n  \n  // 方法5: 使用 expect.assertions 确保断言被执行\n  test('应该确保所有断言被执行', () => {\n    expect.assertions(2); // 期望执行2个断言\n    \n    return fetchUser(1).then(user => {\n      expect(user.id).toBe(1);\n      expect(user.name).toBe('John Doe');\n    });\n  });\n});\n\n// Mock Promise 测试\ndescribe('Mock Promise 测试', () => {\n  // Mock fetch API\n  beforeEach(() => {\n    global.fetch = jest.fn();\n  });\n  \n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n  \n  test('应该Mock成功的API调用', () => {\n    const mockUser = { id: 1, name: 'John' };\n    \n    (global.fetch as jest.Mock).mockResolvedValue({\n      ok: true,\n      json: jest.fn().mockResolvedValue(mockUser)\n    });\n    \n    return expect(fetchUserData(1)).resolves.toEqual(mockUser);\n  });\n  \n  test('应该Mock失败的API调用', () => {\n    (global.fetch as jest.Mock).mockResolvedValue({\n      ok: false,\n      status: 404\n    });\n    \n    return expect(fetchUserData(1)).rejects.toThrow('Network response was not ok');\n  });\n});"
  },
  "promiseErrorHandling": {
    "title": "Promise 错误处理测试",
    "language": "javascript",
    "code": "// 错误处理函数\nclass ApiService {\n  static async fetchWithRetry(url, maxRetries = 3) {\n    let lastError;\n    \n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        const response = await fetch(url);\n        if (response.ok) {\n          return await response.json();\n        }\n        throw new Error(`HTTP ${response.status}`);\n      } catch (error) {\n        lastError = error;\n        if (i < maxRetries - 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n      }\n    }\n    \n    throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);\n  }\n  \n  static async processData(data) {\n    if (!data) {\n      throw new Error('Data is required');\n    }\n    \n    if (data.length === 0) {\n      throw new Error('Data cannot be empty');\n    }\n    \n    return data.map(item => ({ ...item, processed: true }));\n  }\n}\n\n// 错误处理测试\ndescribe('Promise 错误处理测试', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn();\n    jest.useFakeTimers();\n  });\n  \n  afterEach(() => {\n    jest.restoreAllMocks();\n    jest.useRealTimers();\n  });\n  \n  describe('fetchWithRetry', () => {\n    test('成功请求应该返回数据', async () => {\n      const mockData = { id: 1, name: 'Test' };\n      \n      (global.fetch as jest.Mock).mockResolvedValue({\n        ok: true,\n        json: jest.fn().mockResolvedValue(mockData)\n      });\n      \n      const result = await ApiService.fetchWithRetry('/api/test');\n      \n      expect(result).toEqual(mockData);\n      expect(global.fetch).toHaveBeenCalledTimes(1);\n    });\n    \n    test('应该在失败后重试', async () => {\n      (global.fetch as jest.Mock)\n        .mockRejectedValueOnce(new Error('Network error'))\n        .mockRejectedValueOnce(new Error('Network error'))\n        .mockResolvedValue({\n          ok: true,\n          json: jest.fn().mockResolvedValue({ success: true })\n        });\n      \n      // 启动异步操作\n      const promise = ApiService.fetchWithRetry('/api/test', 3);\n      \n      // 快进定时器\n      jest.advanceTimersByTime(1000);\n      await Promise.resolve(); // 让微任务执行\n      \n      jest.advanceTimersByTime(2000);\n      await Promise.resolve();\n      \n      const result = await promise;\n      \n      expect(result).toEqual({ success: true });\n      expect(global.fetch).toHaveBeenCalledTimes(3);\n    });\n    \n    test('超过最大重试次数应该抛出错误', async () => {\n      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));\n      \n      const promise = ApiService.fetchWithRetry('/api/test', 2);\n      \n      // 快进所有定时器\n      jest.advanceTimersByTime(3000);\n      \n      await expect(promise).rejects.toThrow('Failed after 2 attempts: Network error');\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n    });\n  });\n  \n  describe('processData', () => {\n    test('有效数据应该被正确处理', async () => {\n      const inputData = [{ id: 1 }, { id: 2 }];\n      const expectedOutput = [\n        { id: 1, processed: true },\n        { id: 2, processed: true }\n      ];\n      \n      const result = await ApiService.processData(inputData);\n      \n      expect(result).toEqual(expectedOutput);\n    });\n    \n    test('空数据应该抛出错误', async () => {\n      await expect(ApiService.processData(null)).rejects.toThrow('Data is required');\n      await expect(ApiService.processData(undefined)).rejects.toThrow('Data is required');\n    });\n    \n    test('空数组应该抛出错误', async () => {\n      await expect(ApiService.processData([])).rejects.toThrow('Data cannot be empty');\n    });\n  });\n  \n  // 测试Promise.all错误处理\n  test('Promise.all 错误处理', async () => {\n    const promises = [\n      Promise.resolve('success1'),\n      Promise.reject(new Error('error')),\n      Promise.resolve('success2')\n    ];\n    \n    await expect(Promise.all(promises)).rejects.toThrow('error');\n  });\n  \n  // 测试Promise.allSettled\n  test('Promise.allSettled 处理混合结果', async () => {\n    const promises = [\n      Promise.resolve('success'),\n      Promise.reject(new Error('error')),\n      Promise.resolve('another success')\n    ];\n    \n    const results = await Promise.allSettled(promises);\n    \n    expect(results).toEqual([\n      { status: 'fulfilled', value: 'success' },\n      { status: 'rejected', reason: expect.any(Error) },\n      { status: 'fulfilled', value: 'another success' }\n    ]);\n  });\n});"
  },
  "asyncAwaitBasics": {
    "title": "async/await 基础测试",
    "language": "javascript",
    "code": "// 被测试的异步函数\nclass UserService {\n  static async getUser(id) {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch user: ${response.status}`);\n    }\n    \n    return await response.json();\n  }\n  \n  static async createUser(userData) {\n    const response = await fetch('/api/users', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(userData)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to create user');\n    }\n    \n    return await response.json();\n  }\n  \n  static async updateUser(id, updates) {\n    const user = await this.getUser(id);\n    const updatedUser = { ...user, ...updates };\n    \n    const response = await fetch(`/api/users/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(updatedUser)\n    });\n    \n    return await response.json();\n  }\n}\n\n// async/await 测试\ndescribe('async/await 测试', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn();\n  });\n  \n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n  \n  describe('getUser', () => {\n    test('应该成功获取用户', async () => {\n      const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };\n      \n      (global.fetch as jest.Mock).mockResolvedValue({\n        ok: true,\n        json: jest.fn().mockResolvedValue(mockUser)\n      });\n      \n      const user = await UserService.getUser(1);\n      \n      expect(user).toEqual(mockUser);\n      expect(global.fetch).toHaveBeenCalledWith('/api/users/1');\n    });\n    \n    test('应该处理获取用户失败的情况', async () => {\n      (global.fetch as jest.Mock).mockResolvedValue({\n        ok: false,\n        status: 404\n      });\n      \n      await expect(UserService.getUser(999)).rejects.toThrow('Failed to fetch user: 404');\n    });\n    \n    test('应该处理网络错误', async () => {\n      (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));\n      \n      await expect(UserService.getUser(1)).rejects.toThrow('Network error');\n    });\n  });\n  \n  describe('createUser', () => {\n    test('应该成功创建用户', async () => {\n      const userData = { name: 'Jane Doe', email: 'jane@example.com' };\n      const createdUser = { id: 2, ...userData };\n      \n      (global.fetch as jest.Mock).mockResolvedValue({\n        ok: true,\n        json: jest.fn().mockResolvedValue(createdUser)\n      });\n      \n      const result = await UserService.createUser(userData);\n      \n      expect(result).toEqual(createdUser);\n      expect(global.fetch).toHaveBeenCalledWith('/api/users', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(userData)\n      });\n    });\n    \n    test('应该处理创建用户失败的情况', async () => {\n      const errorResponse = { message: 'Email already exists' };\n      \n      (global.fetch as jest.Mock).mockResolvedValue({\n        ok: false,\n        json: jest.fn().mockResolvedValue(errorResponse)\n      });\n      \n      await expect(UserService.createUser({ email: 'existing@example.com' }))\n        .rejects.toThrow('Email already exists');\n    });\n  });\n  \n  describe('updateUser', () => {\n    test('应该成功更新用户', async () => {\n      const existingUser = { id: 1, name: 'John', email: 'john@example.com' };\n      const updates = { name: 'John Doe' };\n      const updatedUser = { ...existingUser, ...updates };\n      \n      (global.fetch as jest.Mock)\n        .mockResolvedValueOnce({\n          ok: true,\n          json: jest.fn().mockResolvedValue(existingUser)\n        })\n        .mockResolvedValueOnce({\n          ok: true,\n          json: jest.fn().mockResolvedValue(updatedUser)\n        });\n      \n      const result = await UserService.updateUser(1, updates);\n      \n      expect(result).toEqual(updatedUser);\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(global.fetch).toHaveBeenNthCalledWith(1, '/api/users/1');\n      expect(global.fetch).toHaveBeenNthCalledWith(2, '/api/users/1', {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updatedUser)\n      });\n    });\n  });\n});\n\n// 错误处理和边界情况\ndescribe('async/await 错误处理', () => {\n  test('应该正确处理多个await的错误', async () => {\n    async function multipleAwaits() {\n      const result1 = await Promise.resolve('success');\n      const result2 = await Promise.reject(new Error('second error'));\n      const result3 = await Promise.resolve('never reached');\n      \n      return [result1, result2, result3];\n    }\n    \n    await expect(multipleAwaits()).rejects.toThrow('second error');\n  });\n  \n  test('应该使用try-catch处理错误', async () => {\n    async function withTryCatch() {\n      try {\n        await Promise.reject(new Error('test error'));\n        return 'success';\n      } catch (error) {\n        return `caught: ${error.message}`;\n      }\n    }\n    \n    const result = await withTryCatch();\n    expect(result).toBe('caught: test error');\n  });\n});"
  },
  "concurrentAsyncTesting": {
    "title": "并发异步测试",
    "language": "javascript",
    "code": "// 并发操作的服务类\nclass ConcurrentService {\n  static async fetchMultipleUsers(ids) {\n    const promises = ids.map(id => \n      fetch(`/api/users/${id}`).then(res => res.json())\n    );\n    \n    return await Promise.all(promises);\n  }\n  \n  static async fetchUserWithProfile(userId) {\n    const [user, profile] = await Promise.all([\n      fetch(`/api/users/${userId}`).then(res => res.json()),\n      fetch(`/api/profiles/${userId}`).then(res => res.json())\n    ]);\n    \n    return { ...user, profile };\n  }\n  \n  static async batchProcess(items, processor) {\n    const batchSize = 3;\n    const results = [];\n    \n    for (let i = 0; i < items.length; i += batchSize) {\n      const batch = items.slice(i, i + batchSize);\n      const batchResults = await Promise.all(\n        batch.map(item => processor(item))\n      );\n      results.push(...batchResults);\n    }\n    \n    return results;\n  }\n  \n  static async raceRequests(urls) {\n    const promises = urls.map(url => \n      fetch(url).then(res => ({ url, data: res.json() }))\n    );\n    \n    return await Promise.race(promises);\n  }\n}\n\n// 并发测试\ndescribe('并发异步测试', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn();\n  });\n  \n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n  \n  describe('fetchMultipleUsers', () => {\n    test('应该并发获取多个用户', async () => {\n      const mockUsers = [\n        { id: 1, name: 'User 1' },\n        { id: 2, name: 'User 2' },\n        { id: 3, name: 'User 3' }\n      ];\n      \n      (global.fetch as jest.Mock)\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue(mockUsers[0])\n        })\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue(mockUsers[1])\n        })\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue(mockUsers[2])\n        });\n      \n      const users = await ConcurrentService.fetchMultipleUsers([1, 2, 3]);\n      \n      expect(users).toEqual(mockUsers);\n      expect(global.fetch).toHaveBeenCalledTimes(3);\n      expect(global.fetch).toHaveBeenCalledWith('/api/users/1');\n      expect(global.fetch).toHaveBeenCalledWith('/api/users/2');\n      expect(global.fetch).toHaveBeenCalledWith('/api/users/3');\n    });\n    \n    test('应该处理部分请求失败的情况', async () => {\n      (global.fetch as jest.Mock)\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue({ id: 1, name: 'User 1' })\n        })\n        .mockRejectedValueOnce(new Error('User 2 not found'))\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue({ id: 3, name: 'User 3' })\n        });\n      \n      await expect(ConcurrentService.fetchMultipleUsers([1, 2, 3]))\n        .rejects.toThrow('User 2 not found');\n    });\n  });\n  \n  describe('fetchUserWithProfile', () => {\n    test('应该并发获取用户和档案', async () => {\n      const mockUser = { id: 1, name: 'John' };\n      const mockProfile = { userId: 1, bio: 'Developer' };\n      \n      (global.fetch as jest.Mock)\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue(mockUser)\n        })\n        .mockResolvedValueOnce({\n          json: jest.fn().mockResolvedValue(mockProfile)\n        });\n      \n      const result = await ConcurrentService.fetchUserWithProfile(1);\n      \n      expect(result).toEqual({\n        id: 1,\n        name: 'John',\n        profile: { userId: 1, bio: 'Developer' }\n      });\n      \n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(global.fetch).toHaveBeenCalledWith('/api/users/1');\n      expect(global.fetch).toHaveBeenCalledWith('/api/profiles/1');\n    });\n  });\n  \n  describe('batchProcess', () => {\n    test('应该分批处理项目', async () => {\n      const items = [1, 2, 3, 4, 5, 6, 7];\n      const processor = jest.fn().mockImplementation(async (item) => {\n        await new Promise(resolve => setTimeout(resolve, 10));\n        return item * 2;\n      });\n      \n      const results = await ConcurrentService.batchProcess(items, processor);\n      \n      expect(results).toEqual([2, 4, 6, 8, 10, 12, 14]);\n      expect(processor).toHaveBeenCalledTimes(7);\n    });\n  });\n  \n  describe('raceRequests', () => {\n    test('应该返回最快的请求结果', async () => {\n      const urls = ['/api/slow', '/api/fast', '/api/medium'];\n      \n      (global.fetch as jest.Mock)\n        .mockImplementation((url) => {\n          const delay = url.includes('fast') ? 10 : 100;\n          return new Promise(resolve => {\n            setTimeout(() => {\n              resolve({\n                json: jest.fn().mockResolvedValue({ source: url })\n              });\n            }, delay);\n          });\n        });\n      \n      const result = await ConcurrentService.raceRequests(urls);\n      \n      expect(result.url).toBe('/api/fast');\n    });\n  });\n});\n\n// 测试并发限制\ndescribe('并发控制测试', () => {\n  test('应该限制并发数量', async () => {\n    let activeRequests = 0;\n    let maxConcurrent = 0;\n    \n    const limitedFetch = async (url) => {\n      activeRequests++;\n      maxConcurrent = Math.max(maxConcurrent, activeRequests);\n      \n      await new Promise(resolve => setTimeout(resolve, 50));\n      \n      activeRequests--;\n      return { url };\n    };\n    \n    const urls = Array.from({ length: 10 }, (_, i) => `/api/item${i}`);\n    \n    // 限制并发为3\n    const semaphore = {\n      count: 3,\n      waiting: [],\n      \n      async acquire() {\n        if (this.count > 0) {\n          this.count--;\n          return;\n        }\n        \n        return new Promise(resolve => {\n          this.waiting.push(resolve);\n        });\n      },\n      \n      release() {\n        this.count++;\n        if (this.waiting.length > 0) {\n          const resolve = this.waiting.shift();\n          this.count--;\n          resolve();\n        }\n      }\n    };\n    \n    const limitedRequests = urls.map(async (url) => {\n      await semaphore.acquire();\n      try {\n        return await limitedFetch(url);\n      } finally {\n        semaphore.release();\n      }\n    });\n    \n    const results = await Promise.all(limitedRequests);\n    \n    expect(results).toHaveLength(10);\n    expect(maxConcurrent).toBeLessThanOrEqual(3);\n  });\n});"
  }
}
