{
  "aaaPattern": {
    "title": "AAA 模式（Arrange-Act-Assert）",
    "language": "javascript",
    "code": "// AAA 模式示例\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    test('应该成功创建用户', async () => {\n      // Arrange - 准备测试数据和环境\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        age: 30\n      };\n      const expectedUser = {\n        id: 1,\n        ...userData,\n        createdAt: expect.any(Date)\n      };\n      \n      // Mock 外部依赖\n      const mockRepository = {\n        save: jest.fn().mockResolvedValue(expectedUser)\n      };\n      const userService = new UserService(mockRepository);\n      \n      // Act - 执行被测试的操作\n      const result = await userService.createUser(userData);\n      \n      // Assert - 验证结果\n      expect(result).toEqual(expectedUser);\n      expect(mockRepository.save).toHaveBeenCalledWith(userData);\n      expect(mockRepository.save).toHaveBeenCalledTimes(1);\n    });\n    \n    test('应该处理无效邮箱格式', async () => {\n      // Arrange\n      const invalidUserData = {\n        name: 'John Doe',\n        email: 'invalid-email', // 无效邮箱\n        age: 30\n      };\n      const mockRepository = {\n        save: jest.fn()\n      };\n      const userService = new UserService(mockRepository);\n      \n      // Act & Assert\n      await expect(userService.createUser(invalidUserData))\n        .rejects\n        .toThrow('Invalid email format');\n      \n      // 验证没有调用保存方法\n      expect(mockRepository.save).not.toHaveBeenCalled();\n    });\n  });\n});\n\n// 复杂场景的 AAA 模式\ndescribe('OrderService', () => {\n  test('应该正确计算订单总价', () => {\n    // Arrange - 准备复杂的测试数据\n    const products = [\n      { id: 1, name: 'Product A', price: 100, quantity: 2 },\n      { id: 2, name: 'Product B', price: 50, quantity: 3 },\n      { id: 3, name: 'Product C', price: 200, quantity: 1 }\n    ];\n    \n    const discountRules = [\n      { type: 'percentage', value: 10, minAmount: 300 },\n      { type: 'fixed', value: 20, minAmount: 500 }\n    ];\n    \n    const taxRate = 0.08;\n    \n    const mockPricingService = {\n      calculateDiscount: jest.fn().mockReturnValue(55), // 10% + 20 fixed\n      calculateTax: jest.fn().mockReturnValue(43.6) // 8% of (550 - 55)\n    };\n    \n    const orderService = new OrderService(mockPricingService);\n    \n    // Act - 执行计算\n    const order = orderService.createOrder(products, discountRules, taxRate);\n    \n    // Assert - 验证所有相关的结果\n    expect(order.subtotal).toBe(550); // 2*100 + 3*50 + 1*200\n    expect(order.discount).toBe(55);\n    expect(order.tax).toBe(43.6);\n    expect(order.total).toBe(538.6); // 550 - 55 + 43.6\n    \n    // 验证依赖服务的调用\n    expect(mockPricingService.calculateDiscount)\n      .toHaveBeenCalledWith(550, discountRules);\n    expect(mockPricingService.calculateTax)\n      .toHaveBeenCalledWith(495, taxRate); // 550 - 55\n  });\n});\n\n// Given-When-Then 模式（BDD风格）\ndescribe('购物车功能', () => {\n  test('当添加商品到空购物车时，应该正确更新购物车状态', () => {\n    // Given - 给定初始状态\n    const emptyCart = new ShoppingCart();\n    const product = { id: 1, name: 'iPhone', price: 999 };\n    const quantity = 2;\n    \n    // When - 当执行某个操作时\n    emptyCart.addItem(product, quantity);\n    \n    // Then - 那么应该产生预期结果\n    expect(emptyCart.getItemCount()).toBe(1);\n    expect(emptyCart.getTotalQuantity()).toBe(2);\n    expect(emptyCart.getTotalPrice()).toBe(1998);\n    expect(emptyCart.getItems()).toContainEqual({\n      product,\n      quantity,\n      subtotal: 1998\n    });\n  });\n});"
  },
  "testOrganization": {
    "title": "测试组织结构",
    "language": "javascript",
    "code": "// 良好的测试组织结构\ndescribe('UserController', () => {\n  // 共享的测试设置\n  let userController;\n  let mockUserService;\n  let mockRequest;\n  let mockResponse;\n  \n  beforeEach(() => {\n    // 每个测试前的通用设置\n    mockUserService = {\n      findById: jest.fn(),\n      create: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn()\n    };\n    \n    userController = new UserController(mockUserService);\n    \n    mockRequest = {\n      params: {},\n      body: {},\n      query: {}\n    };\n    \n    mockResponse = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn().mockReturnThis(),\n      send: jest.fn().mockReturnThis()\n    };\n  });\n  \n  // 按功能分组测试\n  describe('GET /users/:id', () => {\n    describe('当用户存在时', () => {\n      test('应该返回用户信息', async () => {\n        // 测试实现\n      });\n      \n      test('应该返回200状态码', async () => {\n        // 测试实现\n      });\n    });\n    \n    describe('当用户不存在时', () => {\n      test('应该返回404错误', async () => {\n        // 测试实现\n      });\n      \n      test('应该返回错误消息', async () => {\n        // 测试实现\n      });\n    });\n    \n    describe('当发生服务器错误时', () => {\n      test('应该返回500错误', async () => {\n        // 测试实现\n      });\n    });\n  });\n  \n  describe('POST /users', () => {\n    describe('当输入有效时', () => {\n      test('应该创建新用户', async () => {\n        // 测试实现\n      });\n    });\n    \n    describe('当输入无效时', () => {\n      test('应该返回验证错误', async () => {\n        // 测试实现\n      });\n    });\n  });\n});\n\n// 使用嵌套 describe 进行逻辑分组\ndescribe('PaymentProcessor', () => {\n  describe('信用卡支付', () => {\n    describe('有效卡片', () => {\n      test('应该成功处理支付', () => {});\n      test('应该返回交易ID', () => {});\n    });\n    \n    describe('无效卡片', () => {\n      test('应该拒绝过期卡片', () => {});\n      test('应该拒绝余额不足', () => {});\n    });\n  });\n  \n  describe('PayPal支付', () => {\n    describe('已认证账户', () => {\n      test('应该成功处理支付', () => {});\n    });\n    \n    describe('未认证账户', () => {\n      test('应该要求认证', () => {});\n    });\n  });\n});\n\n// 使用 describe.each 进行参数化分组\ndescribe.each([\n  ['admin', { canCreate: true, canDelete: true }],\n  ['editor', { canCreate: true, canDelete: false }],\n  ['viewer', { canCreate: false, canDelete: false }]\n])('权限测试 - %s角色', (role, permissions) => {\n  test(`${role}应该${permissions.canCreate ? '能够' : '不能'}创建内容`, () => {\n    // 测试实现\n  });\n  \n  test(`${role}应该${permissions.canDelete ? '能够' : '不能'}删除内容`, () => {\n    // 测试实现\n  });\n});\n\n// 共享测试工具函数\nconst createMockUser = (overrides = {}) => ({\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  role: 'user',\n  ...overrides\n});\n\nconst createMockRequest = (overrides = {}) => ({\n  params: {},\n  body: {},\n  query: {},\n  headers: {},\n  user: null,\n  ...overrides\n});\n\n// 使用工厂函数创建测试数据\ndescribe('用户权限测试', () => {\n  test('管理员应该能够访问所有资源', () => {\n    const adminUser = createMockUser({ role: 'admin' });\n    const request = createMockRequest({ user: adminUser });\n    \n    // 测试实现\n  });\n});"
  },
  "testNaming": {
    "title": "测试命名规范",
    "language": "javascript",
    "code": "// 好的测试命名示例\ndescribe('UserService', () => {\n  // ✅ 清晰描述测试场景\n  test('应该在邮箱已存在时抛出错误', () => {});\n  test('应该在创建用户成功时返回用户ID', () => {});\n  test('应该在输入无效时返回验证错误', () => {});\n  \n  // ✅ 使用 \"should\" 模式\n  test('should throw error when email already exists', () => {});\n  test('should return user ID when user creation succeeds', () => {});\n  test('should return validation error when input is invalid', () => {});\n  \n  // ✅ 使用 \"when...then\" 模式\n  test('when email exists, then should throw DuplicateEmailError', () => {});\n  test('when user is valid, then should save to database', () => {});\n  \n  // ✅ 描述性的分组名称\n  describe('创建用户功能', () => {\n    describe('当邮箱已存在时', () => {\n      test('应该抛出DuplicateEmailError', () => {});\n      test('应该不调用数据库保存方法', () => {});\n    });\n    \n    describe('当输入数据有效时', () => {\n      test('应该调用数据库保存方法', () => {});\n      test('应该返回新用户的ID', () => {});\n      test('应该发送欢迎邮件', () => {});\n    });\n  });\n});\n\n// ❌ 不好的测试命名示例\ndescribe('UserService', () => {\n  test('test1', () => {}); // 没有描述性\n  test('user creation', () => {}); // 太模糊\n  test('it works', () => {}); // 没有具体信息\n  test('should work correctly', () => {}); // 太泛泛\n});\n\n// ✅ 针对不同类型的测试命名\ndescribe('Calculator', () => {\n  // 功能测试\n  test('应该正确计算两个正数的和', () => {});\n  test('应该正确处理负数相加', () => {});\n  \n  // 边界测试\n  test('应该在除数为零时抛出错误', () => {});\n  test('应该正确处理最大安全整数', () => {});\n  \n  // 错误测试\n  test('应该在输入非数字时抛出TypeError', () => {});\n  test('应该在参数缺失时抛出ArgumentError', () => {});\n});\n\n// ✅ API 测试命名\ndescribe('GET /api/users/:id', () => {\n  test('应该在用户存在时返回200和用户数据', () => {});\n  test('应该在用户不存在时返回404', () => {});\n  test('应该在ID格式无效时返回400', () => {});\n  test('应该在未授权时返回401', () => {});\n});\n\n// ✅ 组件测试命名\ndescribe('LoginForm组件', () => {\n  test('应该在初始状态下显示登录按钮', () => {});\n  test('应该在输入有效凭据时启用提交按钮', () => {});\n  test('应该在提交失败时显示错误消息', () => {});\n  test('应该在成功登录时调用onLogin回调', () => {});\n});\n\n// ✅ 使用测试模板\nconst testTemplate = {\n  // 成功场景\n  success: (action, expected) => `应该在${action}时${expected}`,\n  \n  // 错误场景\n  error: (condition, error) => `应该在${condition}时抛出${error}`,\n  \n  // 验证场景\n  validation: (input, result) => `应该在输入${input}时${result}`,\n  \n  // 状态变化\n  stateChange: (action, from, to) => `应该在${action}时从${from}变为${to}`\n};\n\n// 使用模板\ntest(testTemplate.success('用户登录成功', '重定向到首页'), () => {});\ntest(testTemplate.error('密码错误', 'AuthenticationError'), () => {});\ntest(testTemplate.validation('无效邮箱', '返回验证错误'), () => {});\n\n// ✅ 国际化测试命名\ndescribe('UserService (English)', () => {\n  test('should create user when valid data provided', () => {});\n  test('should throw error when email already exists', () => {});\n  test('should validate email format before creation', () => {});\n});\n\ndescribe('UserService (中文)', () => {\n  test('应该在提供有效数据时创建用户', () => {});\n  test('应该在邮箱已存在时抛出错误', () => {});\n  test('应该在创建前验证邮箱格式', () => {});\n});"
  },
  "variableNaming": {
    "title": "测试变量命名",
    "language": "javascript",
    "code": "// ✅ 好的测试变量命名\ndescribe('OrderService', () => {\n  test('应该计算订单总价', () => {\n    // 清晰的测试数据命名\n    const validOrderData = {\n      items: [\n        { productId: 1, quantity: 2, price: 100 },\n        { productId: 2, quantity: 1, price: 50 }\n      ],\n      customerId: 123,\n      shippingAddress: '123 Main St'\n    };\n    \n    const expectedTotalPrice = 250;\n    const expectedOrderId = 'ORD-001';\n    \n    // Mock 对象命名\n    const mockOrderRepository = {\n      save: jest.fn().mockResolvedValue({ id: expectedOrderId })\n    };\n    \n    const mockPricingService = {\n      calculateTotal: jest.fn().mockReturnValue(expectedTotalPrice)\n    };\n    \n    // 被测试对象命名\n    const orderService = new OrderService(mockOrderRepository, mockPricingService);\n    \n    // 执行和结果\n    const createdOrder = orderService.createOrder(validOrderData);\n    \n    expect(createdOrder.totalPrice).toBe(expectedTotalPrice);\n  });\n  \n  test('应该处理无效订单数据', () => {\n    // 明确表示无效数据\n    const invalidOrderData = {\n      items: [], // 空商品列表\n      customerId: null, // 无效客户ID\n      shippingAddress: '' // 空地址\n    };\n    \n    const expectedErrorMessage = 'Invalid order data';\n    const expectedErrorType = ValidationError;\n    \n    const orderService = new OrderService();\n    \n    expect(() => orderService.createOrder(invalidOrderData))\n      .toThrow(expectedErrorType);\n  });\n});\n\n// ✅ Mock 对象命名规范\ndescribe('UserController', () => {\n  let userController;\n  let mockUserService;\n  let mockEmailService;\n  let mockLogger;\n  \n  beforeEach(() => {\n    // Mock 服务命名：mock + 服务名\n    mockUserService = {\n      findById: jest.fn(),\n      create: jest.fn(),\n      update: jest.fn()\n    };\n    \n    mockEmailService = {\n      sendWelcomeEmail: jest.fn(),\n      sendPasswordResetEmail: jest.fn()\n    };\n    \n    mockLogger = {\n      info: jest.fn(),\n      error: jest.fn(),\n      warn: jest.fn()\n    };\n    \n    userController = new UserController(\n      mockUserService,\n      mockEmailService,\n      mockLogger\n    );\n  });\n});\n\n// ✅ 测试数据工厂命名\nconst createValidUser = (overrides = {}) => ({\n  name: 'John Doe',\n  email: 'john@example.com',\n  age: 30,\n  role: 'user',\n  ...overrides\n});\n\nconst createInvalidUser = (invalidField) => {\n  const baseUser = createValidUser();\n  \n  switch (invalidField) {\n    case 'email':\n      return { ...baseUser, email: 'invalid-email' };\n    case 'age':\n      return { ...baseUser, age: -1 };\n    case 'name':\n      return { ...baseUser, name: '' };\n    default:\n      return baseUser;\n  }\n};\n\n// ✅ 断言变量命名\ntest('应该返回正确的用户统计', () => {\n  const userStats = userService.getUserStats();\n  \n  const expectedTotalUsers = 100;\n  const expectedActiveUsers = 85;\n  const expectedInactiveUsers = 15;\n  \n  expect(userStats.total).toBe(expectedTotalUsers);\n  expect(userStats.active).toBe(expectedActiveUsers);\n  expect(userStats.inactive).toBe(expectedInactiveUsers);\n});\n\n// ✅ 异步测试变量命名\ntest('应该异步创建用户', async () => {\n  const userDataToCreate = createValidUser();\n  const expectedCreatedUser = { id: 1, ...userDataToCreate };\n  \n  mockUserService.create.mockResolvedValue(expectedCreatedUser);\n  \n  const actualCreatedUser = await userController.createUser(userDataToCreate);\n  \n  expect(actualCreatedUser).toEqual(expectedCreatedUser);\n});\n\n// ✅ 错误测试变量命名\ntest('应该处理数据库连接错误', async () => {\n  const databaseConnectionError = new Error('Database connection failed');\n  const expectedErrorResponse = {\n    status: 500,\n    message: 'Internal server error'\n  };\n  \n  mockUserService.findById.mockRejectedValue(databaseConnectionError);\n  \n  const actualErrorResponse = await userController.getUser(1);\n  \n  expect(actualErrorResponse).toEqual(expectedErrorResponse);\n});\n\n// ❌ 不好的变量命名示例\ntest('bad naming example', () => {\n  const data = { name: 'John' }; // 太泛泛\n  const result = service.create(data); // 不明确\n  const x = 100; // 没有意义\n  const temp = mockFn(); // 临时变量名\n  \n  expect(result).toBe(x); // 不清楚在测试什么\n});\n\n// ✅ 常量命名\nconst TEST_CONSTANTS = {\n  VALID_EMAIL: 'test@example.com',\n  INVALID_EMAIL: 'invalid-email',\n  DEFAULT_USER_ROLE: 'user',\n  ADMIN_USER_ROLE: 'admin',\n  MAX_LOGIN_ATTEMPTS: 3,\n  PASSWORD_MIN_LENGTH: 8\n};\n\n// ✅ 使用常量\ntest('应该验证邮箱格式', () => {\n  const userWithValidEmail = createValidUser({ \n    email: TEST_CONSTANTS.VALID_EMAIL \n  });\n  const userWithInvalidEmail = createValidUser({ \n    email: TEST_CONSTANTS.INVALID_EMAIL \n  });\n  \n  expect(validateUser(userWithValidEmail)).toBe(true);\n  expect(validateUser(userWithInvalidEmail)).toBe(false);\n});"
  },
  "testPyramid": {
    "title": "测试金字塔策略",
    "language": "javascript",
    "code": "// 测试金字塔：单元测试 > 集成测试 > E2E测试\n\n// 1. 单元测试（70%）- 快速、独立、大量\n// utils/calculator.test.js\ndescribe('Calculator Utils - 单元测试', () => {\n  test('add函数应该正确计算两数之和', () => {\n    expect(add(2, 3)).toBe(5);\n    expect(add(-1, 1)).toBe(0);\n    expect(add(0.1, 0.2)).toBeCloseTo(0.3);\n  });\n  \n  test('divide函数应该处理除零错误', () => {\n    expect(() => divide(10, 0)).toThrow('Division by zero');\n  });\n});\n\n// services/userService.test.js\ndescribe('UserService - 单元测试', () => {\n  let userService;\n  let mockRepository;\n  \n  beforeEach(() => {\n    mockRepository = {\n      findById: jest.fn(),\n      save: jest.fn(),\n      delete: jest.fn()\n    };\n    userService = new UserService(mockRepository);\n  });\n  \n  test('应该通过ID查找用户', async () => {\n    const mockUser = { id: 1, name: 'John' };\n    mockRepository.findById.mockResolvedValue(mockUser);\n    \n    const user = await userService.getUserById(1);\n    \n    expect(user).toEqual(mockUser);\n    expect(mockRepository.findById).toHaveBeenCalledWith(1);\n  });\n});\n\n// 2. 集成测试（20%）- 测试模块间交互\n// integration/userController.test.js\ndescribe('UserController - 集成测试', () => {\n  let app;\n  let database;\n  \n  beforeAll(async () => {\n    // 设置测试数据库\n    database = await setupTestDatabase();\n    app = createApp(database);\n  });\n  \n  afterAll(async () => {\n    await cleanupTestDatabase(database);\n  });\n  \n  beforeEach(async () => {\n    await database.clear();\n  });\n  \n  test('POST /users 应该创建用户并返回201', async () => {\n    const userData = {\n      name: 'John Doe',\n      email: 'john@example.com'\n    };\n    \n    const response = await request(app)\n      .post('/users')\n      .send(userData)\n      .expect(201);\n    \n    expect(response.body).toMatchObject({\n      id: expect.any(Number),\n      name: userData.name,\n      email: userData.email\n    });\n    \n    // 验证数据库中确实创建了用户\n    const userInDb = await database.users.findById(response.body.id);\n    expect(userInDb).toBeTruthy();\n  });\n  \n  test('GET /users/:id 应该返回用户信息', async () => {\n    // 先在数据库中创建用户\n    const user = await database.users.create({\n      name: 'Jane Doe',\n      email: 'jane@example.com'\n    });\n    \n    const response = await request(app)\n      .get(`/users/${user.id}`)\n      .expect(200);\n    \n    expect(response.body).toMatchObject({\n      id: user.id,\n      name: user.name,\n      email: user.email\n    });\n  });\n});\n\n// 3. E2E测试（10%）- 完整用户流程\n// e2e/userRegistration.test.js\ndescribe('用户注册流程 - E2E测试', () => {\n  let browser;\n  let page;\n  \n  beforeAll(async () => {\n    browser = await puppeteer.launch();\n  });\n  \n  afterAll(async () => {\n    await browser.close();\n  });\n  \n  beforeEach(async () => {\n    page = await browser.newPage();\n    await page.goto('http://localhost:3000');\n  });\n  \n  afterEach(async () => {\n    await page.close();\n  });\n  \n  test('用户应该能够完成完整的注册流程', async () => {\n    // 1. 导航到注册页面\n    await page.click('[data-testid=\"register-link\"]');\n    await page.waitForSelector('[data-testid=\"register-form\"]');\n    \n    // 2. 填写注册表单\n    await page.type('[data-testid=\"name-input\"]', 'John Doe');\n    await page.type('[data-testid=\"email-input\"]', 'john@example.com');\n    await page.type('[data-testid=\"password-input\"]', 'password123');\n    await page.type('[data-testid=\"confirm-password-input\"]', 'password123');\n    \n    // 3. 提交表单\n    await page.click('[data-testid=\"submit-button\"]');\n    \n    // 4. 验证成功消息\n    await page.waitForSelector('[data-testid=\"success-message\"]');\n    const successMessage = await page.textContent('[data-testid=\"success-message\"]');\n    expect(successMessage).toContain('注册成功');\n    \n    // 5. 验证重定向到登录页面\n    await page.waitForURL('**/login');\n    expect(page.url()).toContain('/login');\n  });\n});\n\n// 测试策略配置\n// jest.config.js\nmodule.exports = {\n  projects: [\n    {\n      displayName: 'unit',\n      testMatch: ['<rootDir>/src/**/*.test.js'],\n      testEnvironment: 'node'\n    },\n    {\n      displayName: 'integration',\n      testMatch: ['<rootDir>/tests/integration/**/*.test.js'],\n      testEnvironment: 'node',\n      setupFilesAfterEnv: ['<rootDir>/tests/integration/setup.js']\n    },\n    {\n      displayName: 'e2e',\n      testMatch: ['<rootDir>/tests/e2e/**/*.test.js'],\n      testEnvironment: 'node',\n      setupFilesAfterEnv: ['<rootDir>/tests/e2e/setup.js']\n    }\n  ]\n};\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"test:unit\": \"jest --selectProjects unit\",\n    \"test:integration\": \"jest --selectProjects integration\",\n    \"test:e2e\": \"jest --selectProjects e2e\",\n    \"test:all\": \"jest\",\n    \"test:pyramid\": \"npm run test:unit && npm run test:integration && npm run test:e2e\"\n  }\n}\n\n// 测试金字塔指标\nconst testMetrics = {\n  unit: {\n    count: 150,\n    percentage: 70,\n    avgDuration: '5ms',\n    coverage: '95%'\n  },\n  integration: {\n    count: 40,\n    percentage: 20,\n    avgDuration: '100ms',\n    coverage: '85%'\n  },\n  e2e: {\n    count: 20,\n    percentage: 10,\n    avgDuration: '2s',\n    coverage: '60%'\n  }\n};\n\n// 测试分层策略\nconst testingStrategy = {\n  // 单元测试：测试单个函数/类\n  unit: {\n    focus: '业务逻辑、工具函数、纯函数',\n    isolation: '完全隔离，Mock所有依赖',\n    speed: '非常快（<10ms）',\n    feedback: '即时反馈'\n  },\n  \n  // 集成测试：测试模块间交互\n  integration: {\n    focus: 'API端点、数据库交互、服务集成',\n    isolation: '部分隔离，使用真实数据库',\n    speed: '较快（<1s）',\n    feedback: '快速反馈'\n  },\n  \n  // E2E测试：测试完整用户流程\n  e2e: {\n    focus: '关键用户路径、业务流程',\n    isolation: '真实环境，最小Mock',\n    speed: '较慢（>1s）',\n    feedback: '完整反馈'\n  }\n};"
  }
}
