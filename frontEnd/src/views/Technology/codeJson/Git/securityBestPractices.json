{
  "environmentVariables": {
    "title": "环境变量管理",
    "language": "bash",
    "code": "# .env文件管理\n# 创建环境变量文件\n# .env (本地开发)\nDATABASE_URL=postgresql://localhost:5432/myapp_dev\nAPI_KEY=dev-api-key-12345\nJWT_SECRET=dev-jwt-secret-67890\n\n# .env.production (生产环境)\nDATABASE_URL=postgresql://prod-server:5432/myapp_prod\nAPI_KEY=prod-api-key-abcde\nJWT_SECRET=prod-jwt-secret-fghij\n\n# .gitignore配置\n# 环境变量文件\n.env\n.env.local\n.env.development\n.env.production\n.env.test\n\n# 配置文件\nconfig/database.yml\nconfig/secrets.yml\n*.pem\n*.key\n*.p12\n\n# 日志文件\n*.log\nlogs/\n\n# 临时文件\ntmp/\ntemp/\n.cache/\n\n# IDE配置\n.vscode/settings.json\n.idea/\n\n# 操作系统文件\n.DS_Store\nThumbs.db\n\n# 应用代码中使用环境变量\n// Node.js\nconst config = {\n    database: {\n        url: process.env.DATABASE_URL,\n        ssl: process.env.NODE_ENV === 'production'\n    },\n    api: {\n        key: process.env.API_KEY,\n        secret: process.env.API_SECRET\n    },\n    jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: process.env.JWT_EXPIRES_IN || '24h'\n    }\n}\n\n// React\nconst config = {\n    apiUrl: process.env.REACT_APP_API_URL,\n    environment: process.env.NODE_ENV\n}\n\n// 环境变量验证\nconst requiredEnvVars = [\n    'DATABASE_URL',\n    'API_KEY', \n    'JWT_SECRET'\n]\n\nrequiredEnvVars.forEach(envVar => {\n    if (!process.env[envVar]) {\n        throw new Error(`Missing required environment variable: ${envVar}`)\n    }\n})"
  },
  "gitSecrets": {
    "title": "Git Secrets工具",
    "language": "bash",
    "code": "# 安装git-secrets\n# macOS\nbrew install git-secrets\n\n# Ubuntu/Debian\nsudo apt-get install git-secrets\n\n# 初始化git-secrets\ngit secrets --install\ngit secrets --register-aws\n\n# 添加自定义规则\n# 检测API密钥\ngit secrets --add 'api[_-]?key[_-]?[=:][\"']?[a-zA-Z0-9]{20,}'\n\n# 检测JWT令牌\ngit secrets --add 'jwt[_-]?token[_-]?[=:][\"']?[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*'\n\n# 检测数据库连接字符串\ngit secrets --add 'postgresql://[^\\s]+'\ngit secrets --add 'mysql://[^\\s]+'\ngit secrets --add 'mongodb://[^\\s]+'\n\n# 检测私钥\ngit secrets --add '-----BEGIN [A-Z]+ PRIVATE KEY-----'\n\n# 检测密码字段\ngit secrets --add 'password[_-]?[=:][\"']?[^\\s\"'][^\\s\"']+'\n\n# 全局配置\ngit secrets --install ~/.git-templates/git-secrets\ngit config --global init.templateDir ~/.git-templates/git-secrets\n\n# 扫描现有仓库\ngit secrets --scan\n\n# 扫描历史记录\ngit secrets --scan-history\n\n# 在CI/CD中使用\n# .github/workflows/security.yml\nname: Security Scan\non: [push, pull_request]\n\njobs:\n  secrets-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      \n      - name: Install git-secrets\n        run: |\n          git clone https://github.com/awslabs/git-secrets.git\n          cd git-secrets && sudo make install\n      \n      - name: Configure git-secrets\n        run: |\n          git secrets --register-aws\n          git secrets --install\n      \n      - name: Scan for secrets\n        run: git secrets --scan-history"
  },
  "sensitiveDataCleanup": {
    "title": "敏感信息清理",
    "language": "bash",
    "code": "# 使用BFG Repo-Cleaner清理历史\n# 下载BFG\nwget https://repo1.maven.org/maven2/com/madgag/bfg/1.14.0/bfg-1.14.0.jar\n\n# 删除包含密码的文件\njava -jar bfg.jar --delete-files passwords.txt\n\n# 替换敏感字符串\njava -jar bfg.jar --replace-text replacements.txt\n\n# replacements.txt内容示例\napi_key_12345==>[REMOVED]\npassword123==>[REMOVED]\nsecret_token_xyz==>[REMOVED]\n\n# 清理.git目录\ngit reflog expire --expire=now --all\ngit gc --prune=now --aggressive\n\n# 使用git filter-branch (较慢但更精确)\n# 删除特定文件\ngit filter-branch --force --index-filter \\\n  'git rm --cached --ignore-unmatch config/secrets.yml' \\\n  --prune-empty --tag-name-filter cat -- --all\n\n# 替换敏感内容\ngit filter-branch --force --tree-filter \\\n  'find . -name \"*.js\" -exec sed -i \"s/api_key_12345/[REMOVED]/g\" {} \\;' \\\n  --prune-empty --tag-name-filter cat -- --all\n\n# 强制推送清理后的历史 (危险操作!)\ngit push origin --force --all\ngit push origin --force --tags\n\n# 通知团队成员重新克隆仓库\necho \"警告: 仓库历史已被重写，请重新克隆仓库\"\n\n# 预防措施脚本\n#!/bin/bash\n# pre-commit-security-check.sh\n\n# 检查常见敏感信息模式\nPATTERNS=(\n    \"password[\\\\s]*[=:]\"\n    \"api[_-]?key[\\\\s]*[=:]\"\n    \"secret[\\\\s]*[=:]\"\n    \"token[\\\\s]*[=:]\"\n    \"-----BEGIN.*PRIVATE KEY-----\"\n    \"postgresql://.*:.*@\"\n    \"mysql://.*:.*@\"\n)\n\nfor pattern in \"${PATTERNS[@]}\"; do\n    if git diff --cached | grep -iE \"$pattern\"; then\n        echo \"❌ 检测到可能的敏感信息: $pattern\"\n        echo \"请检查并移除敏感信息后再提交\"\n        exit 1\n    fi\ndone\n\necho \"✅ 安全检查通过\""
  },
  "gpgSigning": {
    "title": "GPG签名配置",
    "language": "bash",
    "code": "# 生成GPG密钥\ngpg --full-generate-key\n\n# 选择密钥类型 (推荐RSA 4096位)\n# 设置有效期 (推荐1-2年)\n# 输入用户信息 (与Git配置一致)\n\n# 列出GPG密钥\ngpg --list-secret-keys --keyid-format LONG\n\n# 输出示例:\n# sec   rsa4096/ABC123DEF456 2023-01-01 [SC] [expires: 2025-01-01]\n# uid                 [ultimate] Your Name <your.email@example.com>\n# ssb   rsa4096/XYZ789ABC123 2023-01-01 [E] [expires: 2025-01-01]\n\n# 配置Git使用GPG签名\ngit config --global user.signingkey ABC123DEF456\ngit config --global commit.gpgsign true\ngit config --global tag.gpgsign true\n\n# 导出公钥添加到GitHub\ngpg --armor --export ABC123DEF456\n\n# 配置GPG程序路径 (如果需要)\ngit config --global gpg.program gpg\n\n# 签名提交\ngit commit -S -m \"Signed commit message\"\n\n# 验证签名\ngit log --show-signature\n\n# 批量签名历史提交 (谨慎使用)\ngit rebase --exec 'git commit --amend --no-edit -S' -i HEAD~10\n\n# GPG密钥管理\n# 备份密钥\ngpg --export-secret-keys ABC123DEF456 > private-key-backup.asc\ngpg --export ABC123DEF456 > public-key-backup.asc\n\n# 恢复密钥\ngpg --import private-key-backup.asc\ngpg --import public-key-backup.asc\n\n# 撤销密钥\ngpg --gen-revoke ABC123DEF456 > revocation-certificate.asc\n\n# 密钥服务器操作\n# 上传公钥到密钥服务器\ngpg --keyserver keyserver.ubuntu.com --send-keys ABC123DEF456\n\n# 从密钥服务器获取公钥\ngpg --keyserver keyserver.ubuntu.com --recv-keys ABC123DEF456\n\n# 自动化签名脚本\n#!/bin/bash\n# setup-gpg-signing.sh\n\necho \"🔐 配置GPG签名...\"\n\n# 检查是否已有GPG密钥\nif ! gpg --list-secret-keys | grep -q \"sec\"; then\n    echo \"未找到GPG密钥，请先生成密钥:\"\n    echo \"gpg --full-generate-key\"\n    exit 1\nfi\n\n# 获取密钥ID\nKEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep \"sec\" | head -1 | sed 's/.*\\/\\([A-F0-9]\\{16\\}\\).*/\\1/')\n\nif [ -z \"$KEY_ID\" ]; then\n    echo \"❌ 无法获取GPG密钥ID\"\n    exit 1\nfi\n\necho \"找到GPG密钥: $KEY_ID\"\n\n# 配置Git\ngit config --global user.signingkey \"$KEY_ID\"\ngit config --global commit.gpgsign true\ngit config --global tag.gpgsign true\n\necho \"✅ GPG签名配置完成\"\necho \"公钥内容 (添加到GitHub):\"\ngpg --armor --export \"$KEY_ID\""
  },
  "sshKeyManagement": {
    "title": "SSH密钥管理",
    "language": "bash",
    "code": "# 生成SSH密钥\n# ED25519密钥 (推荐)\nssh-keygen -t ed25519 -C \"your.email@example.com\" -f ~/.ssh/id_ed25519\n\n# RSA密钥 (兼容性更好)\nssh-keygen -t rsa -b 4096 -C \"your.email@example.com\" -f ~/.ssh/id_rsa\n\n# 配置SSH密钥权限\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/id_ed25519\nchmod 644 ~/.ssh/id_ed25519.pub\n\n# SSH配置文件\n# ~/.ssh/config\nHost github.com\n    HostName github.com\n    User git\n    IdentityFile ~/.ssh/id_ed25519\n    IdentitiesOnly yes\n\nHost gitlab.com\n    HostName gitlab.com\n    User git\n    IdentityFile ~/.ssh/id_rsa\n    IdentitiesOnly yes\n\n# 多账户配置\nHost github-work\n    HostName github.com\n    User git\n    IdentityFile ~/.ssh/id_work\n    IdentitiesOnly yes\n\nHost github-personal\n    HostName github.com\n    User git\n    IdentityFile ~/.ssh/id_personal\n    IdentitiesOnly yes\n\n# 使用不同账户\ngit clone git@github-work:company/repo.git\ngit clone git@github-personal:username/repo.git\n\n# SSH Agent配置\n# 启动SSH Agent\neval \"$(ssh-agent -s)\"\n\n# 添加密钥到SSH Agent\nssh-add ~/.ssh/id_ed25519\n\n# 持久化SSH Agent (macOS)\n# ~/.ssh/config\nHost *\n    AddKeysToAgent yes\n    UseKeychain yes\n    IdentityFile ~/.ssh/id_ed25519\n\n# 测试SSH连接\nssh -T git@github.com\n\n# SSH密钥轮换脚本\n#!/bin/bash\n# rotate-ssh-keys.sh\n\nOLD_KEY=\"$1\"\nNEW_KEY=\"$2\"\n\nif [ -z \"$OLD_KEY\" ] || [ -z \"$NEW_KEY\" ]; then\n    echo \"用法: $0 <old_key_path> <new_key_path>\"\n    exit 1\nfi\n\necho \"🔄 轮换SSH密钥...\"\n\n# 生成新密钥\nssh-keygen -t ed25519 -C \"rotated-key-$(date +%Y%m%d)\" -f \"$NEW_KEY\"\n\necho \"✅ 新密钥已生成: $NEW_KEY\"\necho \"📋 请将以下公钥添加到GitHub:\"\ncat \"$NEW_KEY.pub\"\n\nread -p \"添加完成后按Enter继续...\"\n\n# 测试新密钥\nssh -i \"$NEW_KEY\" -T git@github.com\n\nif [ $? -eq 1 ]; then\n    echo \"✅ 新密钥测试成功\"\n    echo \"🗑️  请手动删除旧密钥: $OLD_KEY\"\nelse\n    echo \"❌ 新密钥测试失败\"\n    exit 1\nfi"
  },
  "githubPermissions": {
    "title": "GitHub权限管理",
    "language": "bash",
    "code": "# 仓库权限级别\n# Read: 克隆和拉取\n# Triage: Read + 管理issues和PR\n# Write: Triage + 推送到非保护分支\n# Maintain: Write + 管理仓库设置\n# Admin: 完全控制权限\n\n# 分支保护规则\n# 通过GitHub Web界面或API配置\n{\n  \"required_status_checks\": {\n    \"strict\": true,\n    \"contexts\": [\"ci/tests\", \"ci/lint\"]\n  },\n  \"enforce_admins\": true,\n  \"required_pull_request_reviews\": {\n    \"required_approving_review_count\": 2,\n    \"dismiss_stale_reviews\": true,\n    \"require_code_owner_reviews\": true,\n    \"restrict_pushes\": true\n  },\n  \"restrictions\": {\n    \"users\": [\"admin-user\"],\n    \"teams\": [\"core-team\"]\n  }\n}\n\n# CODEOWNERS文件\n# .github/CODEOWNERS\n# 全局所有者\n* @team-leads\n\n# 前端代码\n/frontend/ @frontend-team\n*.js @frontend-team\n*.jsx @frontend-team\n*.ts @frontend-team\n*.tsx @frontend-team\n\n# 后端代码\n/backend/ @backend-team\n*.py @backend-team\n*.java @backend-team\n\n# 基础设施\n/docker/ @devops-team\n/k8s/ @devops-team\nDockerfile @devops-team\n\n# 文档\n/docs/ @tech-writers\n*.md @tech-writers\n\n# 配置文件\n/.github/ @admin-team\n/config/ @admin-team\n\n# 团队管理\n# 创建团队\ncurl -X POST \\\n  https://api.github.com/orgs/ORG/teams \\\n  -H \"Authorization: token $GITHUB_TOKEN\" \\\n  -d '{\n    \"name\": \"frontend-team\",\n    \"description\": \"Frontend development team\",\n    \"privacy\": \"closed\",\n    \"permission\": \"push\"\n  }'\n\n# 添加团队成员\ncurl -X PUT \\\n  https://api.github.com/orgs/ORG/teams/TEAM/memberships/USERNAME \\\n  -H \"Authorization: token $GITHUB_TOKEN\" \\\n  -d '{\"role\": \"member\"}'\n\n# 设置仓库权限\ncurl -X PUT \\\n  https://api.github.com/orgs/ORG/teams/TEAM/repos/ORG/REPO \\\n  -H \"Authorization: token $GITHUB_TOKEN\" \\\n  -d '{\"permission\": \"push\"}'\n\n# 权限审计脚本\n#!/bin/bash\n# audit-permissions.sh\n\nORG=\"your-org\"\nTOKEN=\"$GITHUB_TOKEN\"\n\necho \"📊 GitHub权限审计报告\"\necho \"组织: $ORG\"\necho \"时间: $(date)\"\necho \"==========================\"\n\n# 获取所有仓库\nrepos=$(curl -s -H \"Authorization: token $TOKEN\" \\\n  \"https://api.github.com/orgs/$ORG/repos?per_page=100\" | \\\n  jq -r '.[].name')\n\nfor repo in $repos; do\n    echo \"\\n📁 仓库: $repo\"\n    \n    # 获取协作者\n    collaborators=$(curl -s -H \"Authorization: token $TOKEN\" \\\n      \"https://api.github.com/repos/$ORG/$repo/collaborators\" | \\\n      jq -r '.[] | \"\\(.login) (\\(.permissions.admin // false | if . then \"admin\" else if .permissions.push then \"write\" else \"read\" end end))\"')\n    \n    echo \"👥 协作者:\"\n    echo \"$collaborators\"\n    \n    # 检查分支保护\n    protection=$(curl -s -H \"Authorization: token $TOKEN\" \\\n      \"https://api.github.com/repos/$ORG/$repo/branches/main/protection\" 2>/dev/null)\n    \n    if [ \"$protection\" != \"null\" ]; then\n        echo \"🛡️  主分支已保护\"\n    else\n        echo \"⚠️  主分支未保护\"\n    fi\ndone"
  },
  "accessTokenManagement": {
    "title": "访问令牌管理",
    "language": "bash",
    "code": "# Personal Access Token (PAT) 最佳实践\n\n# 1. 最小权限原则\n# 只授予必要的权限范围\n# 常用权限范围:\n# - repo: 完整仓库访问\n# - public_repo: 公共仓库访问\n# - read:org: 读取组织信息\n# - workflow: GitHub Actions访问\n\n# 2. 令牌轮换\n# 定期更换访问令牌 (建议3-6个月)\n\n# 3. 环境隔离\n# 开发环境令牌\nGITHUB_TOKEN_DEV=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# 生产环境令牌\nGITHUB_TOKEN_PROD=ghp_yyyyyyyyyyyyyyyyyyyy\n\n# CI/CD环境令牌\nGITHUB_TOKEN_CI=ghp_zzzzzzzzzzzzzzzzzzzz\n\n# 4. 令牌存储\n# 使用密钥管理服务\n# AWS Secrets Manager\naws secretsmanager create-secret \\\n  --name \"github-token\" \\\n  --description \"GitHub Personal Access Token\" \\\n  --secret-string \"$GITHUB_TOKEN\"\n\n# Azure Key Vault\naz keyvault secret set \\\n  --vault-name \"MyKeyVault\" \\\n  --name \"github-token\" \\\n  --value \"$GITHUB_TOKEN\"\n\n# 5. 令牌监控\n# 监控令牌使用情况\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/user\n\n# 检查令牌权限\ncurl -H \"Authorization: token $GITHUB_TOKEN\" \\\n  https://api.github.com/user/repos\n\n# 6. 自动化令牌管理\n#!/bin/bash\n# token-rotation.sh\n\nOLD_TOKEN=\"$1\"\nNEW_TOKEN=\"$2\"\n\nif [ -z \"$OLD_TOKEN\" ] || [ -z \"$NEW_TOKEN\" ]; then\n    echo \"用法: $0 <old_token> <new_token>\"\n    exit 1\nfi\n\necho \"🔄 开始令牌轮换...\"\n\n# 测试新令牌\nif curl -s -H \"Authorization: token $NEW_TOKEN\" \\\n   https://api.github.com/user > /dev/null; then\n    echo \"✅ 新令牌验证成功\"\nelse\n    echo \"❌ 新令牌验证失败\"\n    exit 1\nfi\n\n# 更新环境变量\necho \"📝 请更新以下位置的令牌:\"\necho \"- CI/CD系统环境变量\"\necho \"- 密钥管理服务\"\necho \"- 本地开发环境\"\necho \"- 部署脚本\"\n\n# 验证旧令牌是否仍然有效\nif curl -s -H \"Authorization: token $OLD_TOKEN\" \\\n   https://api.github.com/user > /dev/null; then\n    echo \"⚠️  旧令牌仍然有效，请在GitHub设置中撤销\"\nelse\n    echo \"✅ 旧令牌已失效\"\nfi\n\n# GitHub App认证 (推荐用于组织)\n# 生成JWT令牌\ngenerate_jwt() {\n    local app_id=\"$1\"\n    local private_key_path=\"$2\"\n    \n    # JWT头部\n    header='{\"alg\":\"RS256\",\"typ\":\"JWT\"}'\n    \n    # JWT载荷\n    now=$(date +%s)\n    exp=$(($now + 600)) # 10分钟过期\n    payload='{\"iat\":'$now',\"exp\":'$exp',\"iss\":'$app_id'}'\n    \n    # 生成JWT\n    jwt=$(echo -n \"$header\" | base64 -w 0 | tr -d '=' | tr '/+' '_-')\n    jwt=\"$jwt.\"$(echo -n \"$payload\" | base64 -w 0 | tr -d '=' | tr '/+' '_-')\n    \n    signature=$(echo -n \"$jwt\" | openssl dgst -sha256 -sign \"$private_key_path\" | base64 -w 0 | tr -d '=' | tr '/+' '_-')\n    \n    echo \"$jwt.$signature\"\n}\n\n# 获取安装访问令牌\nget_installation_token() {\n    local jwt=\"$1\"\n    local installation_id=\"$2\"\n    \n    curl -X POST \\\n      -H \"Authorization: Bearer $jwt\" \\\n      -H \"Accept: application/vnd.github.v3+json\" \\\n      \"https://api.github.com/app/installations/$installation_id/access_tokens\" | \\\n      jq -r '.token'\n}"
  }
}