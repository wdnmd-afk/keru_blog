{
    "basicGenerics": {
        "title": "基础泛型",
        "language": "typescript",
        "code": "// 泛型函数\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\n// 使用泛型函数\nconst stringResult = identity<string>('hello')  // 类型: string\nconst numberResult = identity<number>(42)       // 类型: number\nconst boolResult = identity(true)              // 类型推断: boolean\n\n// 泛型箭头函数\nconst reverse = <T>(items: T[]): T[] => {\n  return items.reverse()\n}\n\n// 多个泛型参数\nfunction pair<T, U>(first: T, second: U): [T, U] {\n  return [first, second]\n}\n\nconst result = pair('hello', 42)  // 类型: [string, number]\n\n// 泛型数组\nfunction getFirstElement<T>(arr: T[]): T | undefined {\n  return arr[0]\n}\n\nconst numbers = [1, 2, 3]\nconst firstNumber = getFirstElement(numbers)  // 类型: number | undefined"
    },
    "genericInterfaces": {
        "title": "泛型接口",
        "language": "typescript",
        "code": "// 泛型接口\ninterface Container<T> {\n  value: T\n  getValue(): T\n  setValue(value: T): void\n}\n\n// 实现泛型接口\nclass Box<T> implements Container<T> {\n  constructor(public value: T) {}\n  \n  getValue(): T {\n    return this.value\n  }\n  \n  setValue(value: T): void {\n    this.value = value\n  }\n}\n\nconst stringBox = new Box<string>('hello')\nconst numberBox = new Box<number>(42)\n\n// 泛型接口作为函数类型\ninterface GenericFunction<T, U> {\n  (arg: T): U\n}\n\nconst toString: GenericFunction<number, string> = (num) => num.toString()\nconst toNumber: GenericFunction<string, number> = (str) => parseInt(str)\n\n// 索引签名泛型\ninterface Dictionary<T> {\n  [key: string]: T\n}\n\nconst stringDict: Dictionary<string> = {\n  name: 'John',\n  city: 'Beijing'\n}\n\nconst numberDict: Dictionary<number> = {\n  age: 25,\n  score: 95\n}"
    },
    "genericClasses": {
        "title": "泛型类",
        "language": "typescript",
        "code": "// 基础泛型类\nclass Stack<T> {\n  private items: T[] = []\n  \n  push(item: T): void {\n    this.items.push(item)\n  }\n  \n  pop(): T | undefined {\n    return this.items.pop()\n  }\n  \n  peek(): T | undefined {\n    return this.items[this.items.length - 1]\n  }\n  \n  isEmpty(): boolean {\n    return this.items.length === 0\n  }\n  \n  size(): number {\n    return this.items.length\n  }\n}\n\nconst numberStack = new Stack<number>()\nnumberStack.push(1)\nnumberStack.push(2)\nconsole.log(numberStack.pop())  // 2\n\nconst stringStack = new Stack<string>()\nstringStack.push('hello')\nstringStack.push('world')\n\n// 泛型类继承\nclass NamedStack<T> extends Stack<T> {\n  constructor(private name: string) {\n    super()\n  }\n  \n  getName(): string {\n    return this.name\n  }\n  \n  toString(): string {\n    return `${this.name}: [${this.size()} items]`\n  }\n}\n\nconst myStack = new NamedStack<number>('Numbers')\nmyStack.push(1)\nmyStack.push(2)\nconsole.log(myStack.toString())  // Numbers: [2 items]"
    },
    "genericConstraints": {
        "title": "泛型约束",
        "language": "typescript",
        "code": "// 基础约束\ninterface Lengthwise {\n  length: number\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length)  // 现在可以访问length属性\n  return arg\n}\n\nlogLength('hello')        // ✅ string有length属性\nlogLength([1, 2, 3])      // ✅ array有length属性\n// logLength(123)         // ❌ number没有length属性\n\n// 使用类型参数约束\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key]\n}\n\nconst person = { name: 'John', age: 30, city: 'Beijing' }\nconst name = getProperty(person, 'name')    // 类型: string\nconst age = getProperty(person, 'age')      // 类型: number\n// const invalid = getProperty(person, 'invalid')  // ❌ 编译错误\n\n// 条件约束\nfunction create<T extends object>(obj: T): T {\n  return { ...obj }\n}\n\nconst user = create({ name: 'John', age: 30 })  // ✅\n// const invalid = create('string')              // ❌ string不是object\n\n// 多重约束\ninterface Serializable {\n  serialize(): string\n}\n\ninterface Timestamped {\n  timestamp: Date\n}\n\nfunction processData<T extends Serializable & Timestamped>(data: T): string {\n  return `${data.timestamp.toISOString()}: ${data.serialize()}`\n}\n\nclass LogEntry implements Serializable, Timestamped {\n  constructor(\n    public message: string,\n    public timestamp: Date = new Date()\n  ) {}\n  \n  serialize(): string {\n    return this.message\n  }\n}\n\nconst entry = new LogEntry('Hello World')\nconsole.log(processData(entry))"
    },
    "conditionalTypes": {
        "title": "条件类型",
        "language": "typescript",
        "code": "// 基础条件类型\ntype IsString<T> = T extends string ? true : false\n\ntype Test1 = IsString<string>   // true\ntype Test2 = IsString<number>   // false\n\n// 实用条件类型\ntype NonNullable<T> = T extends null | undefined ? never : T\n\ntype Result1 = NonNullable<string | null>      // string\ntype Result2 = NonNullable<number | undefined> // number\n\n// 提取函数返回类型\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never\n\ntype Func1 = () => string\ntype Func2 = (x: number) => boolean\n\ntype Return1 = ReturnType<Func1>  // string\ntype Return2 = ReturnType<Func2>  // boolean\n\n// 提取数组元素类型\ntype ArrayElement<T> = T extends (infer U)[] ? U : never\n\ntype Element1 = ArrayElement<string[]>   // string\ntype Element2 = ArrayElement<number[]>   // number\n\n// 分布式条件类型\ntype ToArray<T> = T extends any ? T[] : never\n\ntype Arrays = ToArray<string | number>  // string[] | number[]\n\n// 复杂条件类型示例\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never\n}[keyof T]\n\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? never : K\n}[keyof T]\n\ninterface Example {\n  name: string\n  age: number\n  greet(): void\n  calculate(x: number): number\n}\n\ntype FuncProps = FunctionPropertyNames<Example>     // 'greet' | 'calculate'\ntype NonFuncProps = NonFunctionPropertyNames<Example> // 'name' | 'age'"
    },
    "mappedTypes": {
        "title": "映射类型",
        "language": "typescript",
        "code": "// 基础映射类型\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n\ninterface User {\n  id: number\n  name: string\n  email?: string\n}\n\ntype ReadonlyUser = Readonly<User>\ntype PartialUser = Partial<User>\ntype RequiredUser = Required<User>\n\n// 键名映射\ntype Getters<T> = {\n  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P]\n}\n\ntype UserGetters = Getters<User>\n// {\n//   getId: () => number\n//   getName: () => string\n//   getEmail: () => string | undefined\n// }\n\n// 条件映射\ntype NonFunctionProperties<T> = {\n  [K in keyof T]: T[K] extends Function ? never : T[K]\n}\n\ntype ApiResponse<T> = {\n  data: T\n  status: number\n  message: string\n}\n\n// 深度只读\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\n}\n\ninterface NestedObject {\n  user: {\n    profile: {\n      name: string\n      settings: {\n        theme: string\n      }\n    }\n  }\n}\n\ntype DeepReadonlyNested = DeepReadonly<NestedObject>\n// 所有嵌套属性都变为只读\n\n// 排除特定键\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\n\ntype UserWithoutEmail = Omit<User, 'email'>\n// { id: number; name: string }"
    },
    "utilityTypes": {
        "title": "实用工具类型",
        "language": "typescript",
        "code": "interface User {\n  id: number\n  name: string\n  email: string\n  age?: number\n  isActive: boolean\n}\n\n// Pick - 选择特定属性\ntype UserSummary = Pick<User, 'id' | 'name'>\n// { id: number; name: string }\n\n// Omit - 排除特定属性\ntype UserWithoutId = Omit<User, 'id'>\n// { name: string; email: string; age?: number; isActive: boolean }\n\n// Partial - 所有属性可选\ntype PartialUser = Partial<User>\n// { id?: number; name?: string; email?: string; age?: number; isActive?: boolean }\n\n// Required - 所有属性必需\ntype RequiredUser = Required<User>\n// { id: number; name: string; email: string; age: number; isActive: boolean }\n\n// Record - 创建对象类型\ntype UserRoles = 'admin' | 'user' | 'guest'\ntype RolePermissions = Record<UserRoles, string[]>\n// {\n//   admin: string[]\n//   user: string[]\n//   guest: string[]\n// }\n\nconst permissions: RolePermissions = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n}\n\n// Exclude - 从联合类型中排除\ntype AllColors = 'red' | 'green' | 'blue' | 'yellow'\ntype PrimaryColors = Exclude<AllColors, 'yellow'>  // 'red' | 'green' | 'blue'\n\n// Extract - 从联合类型中提取\ntype WarmColors = Extract<AllColors, 'red' | 'yellow'>  // 'red' | 'yellow'\n\n// NonNullable - 排除null和undefined\ntype MaybeString = string | null | undefined\ntype DefiniteString = NonNullable<MaybeString>  // string\n\n// ReturnType - 获取函数返回类型\nfunction getUser(): User {\n  return { id: 1, name: 'John', email: 'john@example.com', isActive: true }\n}\n\ntype GetUserReturn = ReturnType<typeof getUser>  // User\n\n// Parameters - 获取函数参数类型\nfunction updateUser(id: number, updates: Partial<User>): User {\n  // 实现省略\n  return {} as User\n}\n\ntype UpdateUserParams = Parameters<typeof updateUser>  // [number, Partial<User>]\n\n// ConstructorParameters - 获取构造函数参数类型\nclass UserService {\n  constructor(private apiUrl: string, private timeout: number) {}\n}\n\ntype UserServiceParams = ConstructorParameters<typeof UserService>  // [string, number]"
    },
    "advancedPatterns": {
        "title": "高级模式",
        "language": "typescript",
        "code": "// 递归类型\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json }\n\n// 模板字面量类型\ntype EventName<T extends string> = `on${Capitalize<T>}`\ntype ClickEvent = EventName<'click'>  // 'onClick'\ntype HoverEvent = EventName<'hover'>  // 'onHover'\n\n// 字符串操作类型\ntype UppercaseKeys<T> = {\n  [K in keyof T as Uppercase<string & K>]: T[K]\n}\n\ninterface Config {\n  apiUrl: string\n  timeout: number\n}\n\ntype UpperConfig = UppercaseKeys<Config>\n// { APIURL: string; TIMEOUT: number }\n\n// 函数重载泛型\nfunction createElement<T extends keyof HTMLElementTagNameMap>(\n  tag: T\n): HTMLElementTagNameMap[T]\nfunction createElement<T extends React.ComponentType<any>>(\n  component: T\n): React.ReactElement<React.ComponentProps<T>>\nfunction createElement(tagOrComponent: any): any {\n  // 实现省略\n}\n\nconst div = createElement('div')        // HTMLDivElement\nconst span = createElement('span')      // HTMLSpanElement\n\n// 品牌类型（Branded Types）\ntype UserId = number & { __brand: 'UserId' }\ntype ProductId = number & { __brand: 'ProductId' }\n\nfunction createUserId(id: number): UserId {\n  return id as UserId\n}\n\nfunction createProductId(id: number): ProductId {\n  return id as ProductId\n}\n\nfunction getUser(id: UserId): User {\n  // 实现省略\n  return {} as User\n}\n\nconst userId = createUserId(123)\nconst productId = createProductId(456)\n\ngetUser(userId)     // ✅ 正确\n// getUser(productId)  // ❌ 类型错误\n\n// 高阶类型\ntype AsyncReturnType<T extends (...args: any) => Promise<any>> = \n  T extends (...args: any) => Promise<infer R> ? R : never\n\nasync function fetchUser(): Promise<User> {\n  return {} as User\n}\n\ntype FetchedUser = AsyncReturnType<typeof fetchUser>  // User\n\n// 类型守卫工厂\nfunction isOfType<T>(obj: any, ...keys: (keyof T)[]): obj is T {\n  return keys.every(key => key in obj)\n}\n\ninterface Cat {\n  meow(): void\n  purr(): void\n}\n\ninterface Dog {\n  bark(): void\n  wag(): void\n}\n\nfunction handlePet(pet: Cat | Dog) {\n  if (isOfType<Cat>(pet, 'meow', 'purr')) {\n    pet.meow()  // TypeScript知道这是Cat\n  } else {\n    pet.bark()  // TypeScript知道这是Dog\n  }\n}"
    }
}
