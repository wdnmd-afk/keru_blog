{
    "basicDecorators": {
        "code": "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n\n// 或者使用命令行\ntsc --target ES5 --experimentalDecorators",
        "language": "json",
        "title": "启用装饰器"
    },
    "classDecorators": {
        "code": "// 简单的类装饰器\nfunction sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return \"Hello, \" + this.greeting;\n    }\n}\n\n// 带参数的类装饰器\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\n    return class extends constructor {\n        newProperty = \"new property\";\n        hello = \"override\";\n    }\n}\n\n@classDecorator\nclass Greeter2 {\n    property = \"property\";\n    hello: string;\n    constructor(m: string) {\n        this.hello = m;\n    }\n}",
        "language": "typescript",
        "title": "基本类装饰器"
    },
    "decoratorFactory": {
        "code": "// 装饰器工厂\nfunction Component(options: { selector: string; template: string }) {\n    return function <T extends { new(...args: any[]): {} }>(constructor: T) {\n        return class extends constructor {\n            selector = options.selector;\n            template = options.template;\n        };\n    };\n}\n\n@Component({\n    selector: 'app-user',\n    template: '<div>User Component</div>'\n})\nclass UserComponent {\n    name: string = 'User';\n}\n\n// 日志装饰器\nfunction Logger(logString: string) {\n    return function(constructor: Function) {\n        console.log(logString);\n        console.log(constructor);\n    };\n}\n\n@Logger('LOGGING - USER')\nclass User {\n    name = 'Max';\n    \n    constructor() {\n        console.log('Creating user object...');\n    }\n}",
        "language": "typescript",
        "title": "装饰器工厂"
    },
    "practicalClassDecorators": {
        "code": "// 单例装饰器\nfunction Singleton<T extends { new(...args: any[]): {} }>(constructor: T) {\n    let instance: T;\n    return class {\n        constructor(...args: any[]) {\n            if (instance) {\n                return instance;\n            }\n            instance = new constructor(...args) as T;\n            return instance;\n        }\n    } as T;\n}\n\n@Singleton\nclass DatabaseConnection {\n    connect() {\n        console.log('Connecting to database...');\n    }\n}\n\n// 自动绑定装饰器\nfunction AutoBind(_: any, _2: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    const adjDescriptor: PropertyDescriptor = {\n        configurable: true,\n        get() {\n            const boundFn = originalMethod.bind(this);\n            return boundFn;\n        }\n    };\n    return adjDescriptor;\n}\n\nclass Printer {\n    message = 'This works!';\n\n    @AutoBind\n    showMessage() {\n        console.log(this.message);\n    }\n}",
        "language": "typescript",
        "title": "实用类装饰器示例"
    },
    "methodDecorators": {
        "code": "// 方法装饰器签名\nfunction methodDecorator(\n    target: any,\n    propertyName: string,\n    descriptor: PropertyDescriptor\n) {\n    // target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n    // propertyName: 成员的名字\n    // descriptor: 成员的属性描述符\n}\n\n// 日志方法装饰器\nfunction Log(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n        console.log(`Calling ${propertyName} with arguments:`, args);\n        const result = originalMethod.apply(this, args);\n        console.log(`${propertyName} returned:`, result);\n        return result;\n    };\n}\n\nclass Calculator {\n    @Log\n    add(a: number, b: number): number {\n        return a + b;\n    }\n    \n    @Log\n    multiply(a: number, b: number): number {\n        return a * b;\n    }\n}",
        "language": "typescript",
        "title": "方法装饰器基础"
    },
    "advancedMethodDecorators": {
        "code": "// 性能监控装饰器\nfunction Measure(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n        const start = performance.now();\n        const result = originalMethod.apply(this, args);\n        const end = performance.now();\n        console.log(`${propertyName} execution time: ${end - start}ms`);\n        return result;\n    };\n}\n\n// 缓存装饰器\nfunction Memoize(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    const cache = new Map();\n    \n    descriptor.value = function (...args: any[]) {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            console.log('Cache hit for', propertyName);\n            return cache.get(key);\n        }\n        \n        const result = originalMethod.apply(this, args);\n        cache.set(key, result);\n        return result;\n    };\n}\n\n// 重试装饰器\nfunction Retry(times: number = 3) {\n    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n        const originalMethod = descriptor.value;\n        \n        descriptor.value = async function (...args: any[]) {\n            for (let i = 0; i < times; i++) {\n                try {\n                    return await originalMethod.apply(this, args);\n                } catch (error) {\n                    if (i === times - 1) {\n                        throw error;\n                    }\n                    console.log(`Retry ${i + 1}/${times} for ${propertyName}`);\n                }\n            }\n        };\n    };\n}\n\nclass ApiService {\n    @Measure\n    @Memoize\n    fetchData(id: string) {\n        // 模拟API调用\n        return `Data for ${id}`;\n    }\n    \n    @Retry(3)\n    async uploadFile(file: File) {\n        // 模拟可能失败的上传操作\n        if (Math.random() < 0.7) {\n            throw new Error('Upload failed');\n        }\n        return 'Upload successful';\n    }\n}",
        "language": "typescript",
        "title": "高级方法装饰器"
    },
    "propertyDecorators": {
        "code": "// 属性装饰器签名\nfunction propertyDecorator(target: any, propertyName: string) {\n    // target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n    // propertyName: 成员的名字\n}\n\n// 格式化装饰器\nfunction Format(formatString: string) {\n    return function (target: any, propertyName: string) {\n        let value: string;\n        \n        const getter = function () {\n            return value;\n        };\n        \n        const setter = function (newVal: string) {\n            value = formatString.replace('%s', newVal);\n        };\n        \n        Object.defineProperty(target, propertyName, {\n            get: getter,\n            set: setter,\n            enumerable: true,\n            configurable: true\n        });\n    };\n}\n\n// 验证装饰器\nfunction MinLength(length: number) {\n    return function (target: any, propertyName: string) {\n        let value: string;\n        \n        const getter = function () {\n            return value;\n        };\n        \n        const setter = function (newVal: string) {\n            if (newVal.length < length) {\n                throw new Error(`${propertyName} must be at least ${length} characters long`);\n            }\n            value = newVal;\n        };\n        \n        Object.defineProperty(target, propertyName, {\n            get: getter,\n            set: setter,\n            enumerable: true,\n            configurable: true\n        });\n    };\n}\n\nclass User {\n    @Format('Hello, %s!')\n    greeting: string;\n    \n    @MinLength(3)\n    username: string;\n    \n    constructor(username: string) {\n        this.username = username;\n        this.greeting = username;\n    }\n}",
        "language": "typescript",
        "title": "属性装饰器"
    },
    "parameterDecorators": {
        "code": "// 参数装饰器签名\nfunction parameterDecorator(target: any, propertyName: string, parameterIndex: number) {\n    // target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n    // propertyName: 成员的名字\n    // parameterIndex: 参数在函数参数列表中的索引\n}\n\n// 必需参数装饰器\nconst requiredMetadataKey = Symbol('required');\n\nfunction Required(target: Object, propertyName: string | symbol, parameterIndex: number) {\n    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName) || [];\n    existingRequiredParameters.push(parameterIndex);\n    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyName);\n}\n\nfunction Validate(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    let method = descriptor.value;\n    descriptor.value = function () {\n        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n        if (requiredParameters) {\n            for (let parameterIndex of requiredParameters) {\n                if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n                    throw new Error('Missing required argument.');\n                }\n            }\n        }\n        return method.apply(this, arguments);\n    };\n}\n\nclass UserService {\n    @Validate\n    createUser(@Required name: string, @Required email: string, age?: number) {\n        return { name, email, age };\n    }\n}\n\n// 类型转换装饰器\nfunction ToNumber(target: any, propertyName: string, parameterIndex: number) {\n    const originalMethod = target[propertyName];\n    target[propertyName] = function (...args: any[]) {\n        args[parameterIndex] = Number(args[parameterIndex]);\n        return originalMethod.apply(this, args);\n    };\n}\n\nclass MathService {\n    add(@ToNumber a: any, @ToNumber b: any): number {\n        return a + b;\n    }\n}",
        "language": "typescript",
        "title": "参数装饰器"
    },
    "dependencyInjection": {
        "code": "// 简单的依赖注入容器\nclass Container {\n    private services = new Map();\n    \n    register<T>(token: string, factory: () => T): void {\n        this.services.set(token, factory);\n    }\n    \n    resolve<T>(token: string): T {\n        const factory = this.services.get(token);\n        if (!factory) {\n            throw new Error(`Service ${token} not found`);\n        }\n        return factory();\n    }\n}\n\nconst container = new Container();\n\n// 注入装饰器\nfunction Injectable(token: string) {\n    return function <T extends { new(...args: any[]): {} }>(constructor: T) {\n        container.register(token, () => new constructor());\n        return constructor;\n    };\n}\n\nfunction Inject(token: string) {\n    return function (target: any, propertyName: string, parameterIndex: number) {\n        // 存储注入信息的元数据\n        const existingTokens = Reflect.getMetadata('inject-tokens', target) || [];\n        existingTokens[parameterIndex] = token;\n        Reflect.defineMetadata('inject-tokens', existingTokens, target);\n    };\n}\n\n@Injectable('UserService')\nclass UserService {\n    getUsers() {\n        return ['Alice', 'Bob', 'Charlie'];\n    }\n}\n\n@Injectable('UserController')\nclass UserController {\n    constructor(@Inject('UserService') private userService: UserService) {}\n    \n    getAllUsers() {\n        return this.userService.getUsers();\n    }\n}",
        "language": "typescript",
        "title": "依赖注入系统"
    },
    "routingDecorators": {
        "code": "// 路由元数据\ninterface RouteMetadata {\n    path: string;\n    method: string;\n}\n\n// 路由装饰器\nfunction Controller(basePath: string) {\n    return function <T extends { new(...args: any[]): {} }>(constructor: T) {\n        Reflect.defineMetadata('basePath', basePath, constructor);\n        return constructor;\n    };\n}\n\nfunction Get(path: string) {\n    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n        Reflect.defineMetadata('route', { path, method: 'GET' }, target, propertyName);\n    };\n}\n\nfunction Post(path: string) {\n    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n        Reflect.defineMetadata('route', { path, method: 'POST' }, target, propertyName);\n    };\n}\n\n// 使用示例\n@Controller('/api/users')\nclass UsersController {\n    @Get('/')\n    getAllUsers() {\n        return { users: ['Alice', 'Bob'] };\n    }\n    \n    @Get('/:id')\n    getUserById() {\n        return { user: 'Alice' };\n    }\n    \n    @Post('/')\n    createUser() {\n        return { message: 'User created' };\n    }\n}\n\n// 路由注册器\nfunction registerRoutes(controller: any) {\n    const basePath = Reflect.getMetadata('basePath', controller.constructor);\n    const prototype = Object.getPrototypeOf(controller);\n    \n    Object.getOwnPropertyNames(prototype).forEach(methodName => {\n        const routeMetadata: RouteMetadata = Reflect.getMetadata('route', prototype, methodName);\n        if (routeMetadata) {\n            const fullPath = basePath + routeMetadata.path;\n            console.log(`Registering ${routeMetadata.method} ${fullPath}`);\n            // 这里可以注册到实际的路由器\n        }\n    });\n}",
        "language": "typescript",
        "title": "API路由装饰器"
    }
}
