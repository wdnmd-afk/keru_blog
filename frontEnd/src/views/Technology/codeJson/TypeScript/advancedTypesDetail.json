{
  "unionTypes": {
    "code": "// 联合类型基础\ntype StringOrNumber = string | number;\ntype Status = 'loading' | 'success' | 'error';\n\nfunction processValue(value: StringOrNumber) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value * 2;\n}\n\n// 字面量联合类型\ntype Theme = 'light' | 'dark' | 'auto';\ntype Size = 'small' | 'medium' | 'large';\n\ninterface ButtonProps {\n    theme: Theme;\n    size: Size;\n    disabled?: boolean;\n}\n\n// 联合类型的类型守卫\nfunction isString(value: StringOrNumber): value is string {\n    return typeof value === 'string';\n}\n\nfunction handleValue(value: StringOrNumber) {\n    if (isString(value)) {\n        // TypeScript知道这里value是string类型\n        console.log(value.length);\n    } else {\n        // TypeScript知道这里value是number类型\n        console.log(value.toFixed(2));\n    }\n}",
    "language": "typescript",
    "title": "联合类型基础"
  },
  "intersectionTypes": {
    "code": "// 交叉类型基础\ninterface User {\n    name: string;\n    age: number;\n}\n\ninterface Admin {\n    permissions: string[];\n    role: 'admin';\n}\n\n// 交叉类型组合\ntype AdminUser = User & Admin;\n\nconst adminUser: AdminUser = {\n    name: 'Alice',\n    age: 30,\n    permissions: ['read', 'write', 'delete'],\n    role: 'admin'\n};\n\n// 函数类型的交叉\ntype Logger = {\n    log: (message: string) => void;\n};\n\ntype Formatter = {\n    format: (data: any) => string;\n};\n\ntype LoggerWithFormatter = Logger & Formatter;\n\nconst logger: LoggerWithFormatter = {\n    log: (message: string) => console.log(message),\n    format: (data: any) => JSON.stringify(data)\n};\n\n// 混入模式\nfunction mixinTimestamp<T extends object>(obj: T): T & { timestamp: number } {\n    return {\n        ...obj,\n        timestamp: Date.now()\n    };\n}",
    "language": "typescript",
    "title": "交叉类型基础"
  },
  "conditionalTypes": {
    "code": "// 条件类型基础\ntype IsString<T> = T extends string ? true : false;\n\ntype Test1 = IsString<string>;  // true\ntype Test2 = IsString<number>;  // false\n\n// 实用的条件类型\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype NonNull<T> = T extends null ? never : T;\n\n// 提取函数返回类型\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction getString(): string {\n    return 'hello';\n}\n\ntype StringReturn = ReturnType<typeof getString>; // string\n\n// 提取数组元素类型\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringArray = string[];\ntype Element = ArrayElement<StringArray>; // string\n\n// 分布式条件类型\ntype ToArray<T> = T extends any ? T[] : never;\ntype StrArrOrNumArr = ToArray<string | number>; // string[] | number[]\n\n// 复杂条件类型示例\ntype FunctionPropertyNames<T> = {\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ntype NonFunctionPropertyNames<T> = {\n    [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];",
    "language": "typescript",
    "title": "条件类型"
  },
  "mappedTypes": {
    "code": "// 映射类型基础\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\ninterface User {\n    name: string;\n    age: number;\n    email?: string;\n}\n\ntype ReadonlyUser = Readonly<User>;\ntype PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\n\n// 键名映射\ntype Getters<T> = {\n    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// {\n//     getName: () => string;\n//     getAge: () => number;\n//     getEmail: () => string | undefined;\n// }\n\n// 条件映射\ntype PickByType<T, U> = {\n    [K in keyof T as T[K] extends U ? K : never]: T[K];\n};\n\ninterface Example {\n    name: string;\n    age: number;\n    isActive: boolean;\n    tags: string[];\n}\n\ntype StringProps = PickByType<Example, string>; // { name: string }\ntype NumberProps = PickByType<Example, number>; // { age: number }",
    "language": "typescript",
    "title": "映射类型"
  },
  "templateLiteralTypes": {
    "code": "// 模板字面量类型\ntype World = 'world';\ntype Greeting = `hello ${World}`; // 'hello world'\n\n// 动态属性名\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype ClickEvent = EventName<'click'>; // 'onClick'\ntype HoverEvent = EventName<'hover'>; // 'onHover'\n\n// CSS属性类型\ntype CSSProperty = 'margin' | 'padding' | 'border';\ntype CSSDirection = 'top' | 'right' | 'bottom' | 'left';\ntype CSSPropertyWithDirection = `${CSSProperty}-${CSSDirection}`;\n// 'margin-top' | 'margin-right' | ... | 'border-left'\n\n// API路径类型\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype ApiVersion = 'v1' | 'v2';\ntype Resource = 'users' | 'posts' | 'comments';\ntype ApiPath = `/api/${ApiVersion}/${Resource}`;\n\n// 实际应用示例\ninterface EventMap {\n    click: MouseEvent;\n    hover: MouseEvent;\n    focus: FocusEvent;\n}\n\ntype EventHandlers = {\n    [K in keyof EventMap as `on${Capitalize<string & K>}`]?: (event: EventMap[K]) => void;\n};\n\n// 结果类型：\n// {\n//     onClick?: (event: MouseEvent) => void;\n//     onHover?: (event: MouseEvent) => void;\n//     onFocus?: (event: FocusEvent) => void;\n// }\n\n// 字符串操作\ntype Uppercase<S extends string> = intrinsic;\ntype Lowercase<S extends string> = intrinsic;\ntype Capitalize<S extends string> = intrinsic;\ntype Uncapitalize<S extends string> = intrinsic;\n\ntype UppercaseGreeting = Uppercase<'hello world'>; // 'HELLO WORLD'\ntype LowercaseGreeting = Lowercase<'HELLO WORLD'>; // 'hello world'",
    "language": "typescript",
    "title": "模板字面量类型"
  },
  "utilityTypes": {
    "code": "// TypeScript内置工具类型\n\n// 1. Partial<T> - 将所有属性变为可选\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string; }\n\nfunction updateUser(user: User, updates: PartialUser): User {\n    return { ...user, ...updates };\n}\n\n// 2. Required<T> - 将所有属性变为必需\ninterface Config {\n    apiUrl?: string;\n    timeout?: number;\n    retries?: number;\n}\n\ntype RequiredConfig = Required<Config>;\n// { apiUrl: string; timeout: number; retries: number; }\n\n// 3. Pick<T, K> - 选择特定属性\ntype UserSummary = Pick<User, 'id' | 'name'>;\n// { id: number; name: string; }\n\n// 4. Omit<T, K> - 排除特定属性\ntype UserWithoutEmail = Omit<User, 'email'>;\n// { id: number; name: string; }\n\n// 5. Record<K, T> - 创建键值对类型\ntype UserRoles = Record<string, string[]>;\nconst roles: UserRoles = {\n    admin: ['read', 'write', 'delete'],\n    user: ['read'],\n    guest: []\n};\n\n// 6. Exclude<T, U> - 从联合类型中排除\ntype AllColors = 'red' | 'green' | 'blue' | 'yellow';\ntype PrimaryColors = Exclude<AllColors, 'yellow'>; // 'red' | 'green' | 'blue'\n\n// 7. Extract<T, U> - 从联合类型中提取\ntype WarmColors = Extract<AllColors, 'red' | 'yellow'>; // 'red' | 'yellow'\n\n// 8. NonNullable<T> - 排除null和undefined\ntype MaybeString = string | null | undefined;\ntype DefinitelyString = NonNullable<MaybeString>; // string",
    "language": "typescript",
    "title": "工具类型"
  },
  "advancedPatterns": {
    "code": "// 高级类型模式\n\n// 1. 递归类型\ntype DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedObject {\n    user: {\n        profile: {\n            name: string;\n            settings: {\n                theme: string;\n            };\n        };\n    };\n}\n\ntype ReadonlyNested = DeepReadonly<NestedObject>;\n\n// 2. 函数重载类型\ninterface Overloaded {\n    (x: string): string;\n    (x: number): number;\n    (x: boolean): boolean;\n}\n\nconst fn: Overloaded = (x: any) => x;\n\n// 3. 高阶类型\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nfunction Timestamped<TBase extends Constructor>(Base: TBase) {\n    return class extends Base {\n        timestamp = Date.now();\n    };\n}\n\nclass User {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\nconst TimestampedUser = Timestamped(User);\nconst user = new TimestampedUser('Alice');\n\n// 4. 品牌类型（Branded Types）\ntype Brand<T, B> = T & { __brand: B };\ntype UserId = Brand<number, 'UserId'>;\ntype ProductId = Brand<number, 'ProductId'>;\n\nfunction createUserId(id: number): UserId {\n    return id as UserId;\n}\n\nfunction getUserById(id: UserId) {\n    // 只接受UserId类型\n}\n\n// 5. 状态机类型\ntype State = 'idle' | 'loading' | 'success' | 'error';\ntype Event = 'FETCH' | 'SUCCESS' | 'ERROR' | 'RESET';\n\ntype StateMachine = {\n    idle: { FETCH: 'loading' };\n    loading: { SUCCESS: 'success'; ERROR: 'error' };\n    success: { RESET: 'idle'; FETCH: 'loading' };\n    error: { RESET: 'idle'; FETCH: 'loading' };\n};\n\ntype NextState<S extends State, E extends Event> = \n    S extends keyof StateMachine \n        ? E extends keyof StateMachine[S] \n            ? StateMachine[S][E] \n            : never \n        : never;",
    "language": "typescript",
    "title": "高级类型模式"
  }
}