{
  "partialRequired": {
    "title": "Partial & Required",
    "language": "typescript",
    "code": "// 基础接口\ninterface User {\n    id: number\n    name: string\n    email: string\n    age: number\n}\n\n// Partial<T> - 将所有属性变为可选\ntype PartialUser = Partial<User>\n// 等价于:\n// {\n//     id?: number\n//     name?: string\n//     email?: string\n//     age?: number\n// }\n\n// 使用场景：更新操作\nfunction updateUser(id: number, updates: Partial<User>) {\n    // 只需要传递需要更新的字段\n}\n\nupdateUser(1, { name: '新名字' }) // ✅ 有效\nupdateUser(1, { email: 'new@email.com', age: 25 }) // ✅ 有效\n\n// Required<T> - 将所有属性变为必需\ninterface OptionalConfig {\n    host?: string\n    port?: number\n    ssl?: boolean\n}\n\ntype RequiredConfig = Required<OptionalConfig>\n// 等价于:\n// {\n//     host: string\n//     port: number\n//     ssl: boolean\n// }\n\n// 自定义实现\ntype MyPartial<T> = {\n    [P in keyof T]?: T[P]\n}\n\ntype MyRequired<T> = {\n    [P in keyof T]-?: T[P]  // -? 移除可选修饰符\n}"
  },
  "pickOmit": {
    "title": "Pick & Omit",
    "language": "typescript",
    "code": "// Pick<T, K> - 选择指定属性\ntype UserBasicInfo = Pick<User, 'id' | 'name'>\n// 等价于:\n// {\n//     id: number\n//     name: string\n// }\n\n// 使用场景：API响应类型\ninterface UserResponse extends Pick<User, 'id' | 'name' | 'email'> {\n    createdAt: string\n    updatedAt: string\n}\n\n// Omit<T, K> - 排除指定属性\ntype UserWithoutId = Omit<User, 'id'>\n// 等价于:\n// {\n//     name: string\n//     email: string\n//     age: number\n// }\n\n// 使用场景：创建操作\nfunction createUser(userData: Omit<User, 'id'>): User {\n    return {\n        id: Math.random(),\n        ...userData\n    }\n}\n\n// 组合使用\ntype UserPublicInfo = Pick<User, 'name' | 'email'>\ntype UserPrivateInfo = Omit<User, keyof UserPublicInfo>\n\n// 自定义实现\ntype MyPick<T, K extends keyof T> = {\n    [P in K]: T[P]\n}\n\ntype MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>"
  },
  "readonly": {
    "title": "Readonly",
    "language": "typescript",
    "code": "// Readonly<T> - 将所有属性变为只读\ntype ReadonlyUser = Readonly<User>\n// 等价于:\n// {\n//     readonly id: number\n//     readonly name: string\n//     readonly email: string\n//     readonly age: number\n// }\n\n// 使用场景：不可变数据\nfunction processUser(user: Readonly<User>) {\n    // user.name = '新名字' // ❌ 错误：无法分配到只读属性\n    return { ...user, name: '新名字' } // ✅ 正确：创建新对象\n}\n\n// 深度只读\ntype DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\n}\n\ninterface NestedData {\n    user: User\n    settings: {\n        theme: string\n        notifications: boolean\n    }\n}\n\ntype DeepReadonlyData = DeepReadonly<NestedData>\n// 所有嵌套属性都变为只读\n\n// 条件只读\ntype ConditionalReadonly<T, K extends keyof T> = {\n    readonly [P in K]: T[P]\n} & {\n    [P in Exclude<keyof T, K>]: T[P]\n}\n\ntype UserWithReadonlyId = ConditionalReadonly<User, 'id'>\n// id是只读的，其他属性可修改"
  },
  "recordExtractExclude": {
    "title": "Record & Extract & Exclude",
    "language": "typescript",
    "code": "// Record<K, T> - 创建键值对类型\ntype UserRoles = 'admin' | 'user' | 'guest'\ntype RolePermissions = Record<UserRoles, string[]>\n// 等价于:\n// {\n//     admin: string[]\n//     user: string[]\n//     guest: string[]\n// }\n\nconst permissions: RolePermissions = {\n    admin: ['read', 'write', 'delete'],\n    user: ['read', 'write'],\n    guest: ['read']\n}\n\n// 动态键类型\ntype DynamicRecord<T extends string> = Record<T, any>\ntype ApiEndpoints = DynamicRecord<'users' | 'posts' | 'comments'>\n\n// Extract<T, U> - 提取可分配给U的类型\ntype StringOrNumber = string | number | boolean\ntype OnlyStringOrNumber = Extract<StringOrNumber, string | number>\n// 结果: string | number\n\n// 使用场景：过滤联合类型\ntype EventType = 'click' | 'scroll' | 'resize' | 'load'\ntype MouseEvents = Extract<EventType, 'click' | 'scroll'>\n// 结果: 'click' | 'scroll'\n\n// Exclude<T, U> - 排除可分配给U的类型\ntype WithoutBoolean = Exclude<StringOrNumber, boolean>\n// 结果: string | number\n\n// 使用场景：移除特定类型\ntype NonMouseEvents = Exclude<EventType, MouseEvents>\n// 结果: 'resize' | 'load'"
  },
  "nonNullableConditional": {
    "title": "NonNullable & 条件类型",
    "language": "typescript",
    "code": "// NonNullable<T> - 排除null和undefined\ntype MaybeString = string | null | undefined\ntype DefinitelyString = NonNullable<MaybeString>\n// 结果: string\n\n// 使用场景：过滤空值\nfunction processValue<T>(value: T): NonNullable<T> {\n    if (value == null) {\n        throw new Error('Value cannot be null or undefined')\n    }\n    return value\n}\n\n// 自定义NonNullable\ntype MyNonNullable<T> = T extends null | undefined ? never : T\n\n// 复杂条件类型示例\ntype IsArray<T> = T extends any[] ? true : false\ntype Test1 = IsArray<string[]> // true\ntype Test2 = IsArray<string>   // false\n\n// 递归条件类型\ntype Flatten<T> = T extends (infer U)[] ? Flatten<U> : T\ntype Test3 = Flatten<string[][]> // string\ntype Test4 = Flatten<number[][][]> // number\n\n// 分布式条件类型\ntype ToArray<T> = T extends any ? T[] : never\ntype Test5 = ToArray<string | number> // string[] | number[]"
  },
  "parametersReturnType": {
    "title": "Parameters & ReturnType",
    "language": "typescript",
    "code": "// 示例函数\nfunction createUser(name: string, age: number, email?: string): User {\n    return { id: 1, name, age, email: email || '' }\n}\n\n// Parameters<T> - 获取函数参数类型\ntype CreateUserParams = Parameters<typeof createUser>\n// 结果: [name: string, age: number, email?: string]\n\n// 使用场景：函数包装器\nfunction loggedCreateUser(...args: Parameters<typeof createUser>) {\n    console.log('Creating user with:', args)\n    return createUser(...args)\n}\n\n// ReturnType<T> - 获取函数返回类型\ntype CreateUserReturn = ReturnType<typeof createUser>\n// 结果: User\n\n// 使用场景：API响应类型\nasync function fetchUser(id: number): Promise<User> {\n    // 实现...\n    return {} as User\n}\n\ntype FetchUserResponse = ReturnType<typeof fetchUser>\n// 结果: Promise<User>\n\n// 获取Promise的解析类型\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T\ntype UserData = UnwrapPromise<FetchUserResponse>\n// 结果: User"
  },
  "constructorParameters": {
    "title": "ConstructorParameters & 高级函数类型",
    "language": "typescript",
    "code": "// 类构造函数\nclass DatabaseConnection {\n    constructor(\n        private host: string,\n        private port: number,\n        private options?: { ssl: boolean }\n    ) {}\n}\n\n// ConstructorParameters<T> - 获取构造函数参数类型\ntype DbConnectionParams = ConstructorParameters<typeof DatabaseConnection>\n// 结果: [host: string, port: number, options?: { ssl: boolean }]\n\n// 使用场景：工厂函数\nfunction createConnection(...args: ConstructorParameters<typeof DatabaseConnection>) {\n    return new DatabaseConnection(...args)\n}\n\n// InstanceType<T> - 获取构造函数的实例类型\ntype DbInstance = InstanceType<typeof DatabaseConnection>\n// 结果: DatabaseConnection\n\n// ThisParameterType<T> - 获取函数的this参数类型\nfunction greet(this: User, message: string) {\n    return `${this.name}: ${message}`\n}\n\ntype GreetThis = ThisParameterType<typeof greet>\n// 结果: User\n\n// OmitThisParameter<T> - 移除this参数\ntype GreetWithoutThis = OmitThisParameter<typeof greet>\n// 结果: (message: string) => string\n\n// 高级函数类型操作\ntype AsyncReturnType<T extends (...args: any) => Promise<any>> = \n    T extends (...args: any) => Promise<infer R> ? R : never\n\nasync function fetchData(): Promise<{ users: User[] }> {\n    return { users: [] }\n}\n\ntype FetchDataResult = AsyncReturnType<typeof fetchData>\n// 结果: { users: User[] }"
  },
  "customUtilityTypes": {
    "title": "实用自定义工具类型",
    "language": "typescript",
    "code": "// 1. 深度部分类型\ntype DeepPartial<T> = {\n    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\n// 2. 键值互换\ntype Reverse<T extends Record<string, string>> = {\n    [K in T[keyof T]]: {\n        [P in keyof T]: T[P] extends K ? P : never\n    }[keyof T]\n}\n\ntype Colors = { red: '#ff0000'; green: '#00ff00'; blue: '#0000ff' }\ntype ColorValues = Reverse<Colors>\n// 结果: { '#ff0000': 'red'; '#00ff00': 'green'; '#0000ff': 'blue' }\n\n// 3. 可空类型\ntype Nullable<T> = T | null\ntype Optional<T> = T | undefined\ntype Maybe<T> = T | null | undefined\n\n// 4. 数组元素类型\ntype ArrayElement<T> = T extends (infer U)[] ? U : never\ntype StringArrayElement = ArrayElement<string[]> // string\n\n// 5. 对象值类型\ntype ValueOf<T> = T[keyof T]\ntype UserValues = ValueOf<User> // string | number\n\n// 6. 函数重载类型\ntype Overload<T> = T extends {\n    (...args: infer A1): infer R1\n    (...args: infer A2): infer R2\n} ? ((...args: A1) => R1) | ((...args: A2) => R2) : never\n\n// 7. 条件属性类型\ntype ConditionalKeys<T, U> = {\n    [K in keyof T]: T[K] extends U ? K : never\n}[keyof T]\n\ntype StringKeys = ConditionalKeys<User, string>\n// 结果: 'name' | 'email'\n\n// 8. 品牌类型\ntype Brand<T, B> = T & { __brand: B }\ntype UserId = Brand<number, 'UserId'>\ntype ProductId = Brand<number, 'ProductId'>\n\nfunction getUser(id: UserId): User {\n    // 实现...\n    return {} as User\n}\n\n// getUser(123) // ❌ 错误\n// getUser(123 as UserId) // ✅ 正确"
  }
}