{
    "conditionalTypes": {
        "title": "条件类型",
        "language": "typescript",
        "code": "// 条件类型基础语法\ntype IsString<T> = T extends string ? true : false\n\ntype Test1 = IsString<string>  // true\ntype Test2 = IsString<number>  // false\n\n// 实用的条件类型\ntype NonNullable<T> = T extends null | undefined ? never : T\ntype NonNull = NonNullable<string | null>  // string\n\n// 分布式条件类型\ntype ToArray<T> = T extends any ? T[] : never\ntype StringOrNumberArray = ToArray<string | number>  // string[] | number[]\n\n// 条件类型中的类型推断\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any\ntype FuncReturn = ReturnType<() => string>  // string\n\n// 复杂的条件类型\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\n}"
    },
    "mappedTypes": {
        "title": "映射类型",
        "language": "typescript",
        "code": "// 基础映射类型\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n\n// 键名映射\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n}\n\ninterface Person {\n  name: string\n  age: number\n}\n\ntype PersonGetters = Getters<Person>\n// {\n//   getName: () => string\n//   getAge: () => number\n// }\n\n// 过滤属性\ntype PickByType<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\ntype StringProps = PickByType<Person, string>  // { name: string }"
    },
    "templateLiteralTypes": {
        "title": "模板字面量类型",
        "language": "typescript",
        "code": "// 基础模板字面量类型\ntype World = \"world\"\ntype Greeting = `hello ${World}`  // \"hello world\"\n\n// 联合类型的模板字面量\ntype EmailLocaleIDs = \"welcome_email\" | \"email_heading\"\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\"\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`\n// \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n\n// 事件名称生成\ntype ObjectWatchedEvents<T> = {\n  [K in keyof T as `${string & K}Changed`]: (newValue: T[K]) => void\n}\n\ninterface User {\n  name: string\n  age: number\n}\n\ntype UserEvents = ObjectWatchedEvents<User>\n// {\n//   nameChanged: (newValue: string) => void\n//   ageChanged: (newValue: number) => void\n// }\n\n// SQL查询构建器\ntype SQLOperation = \"SELECT\" | \"INSERT\" | \"UPDATE\" | \"DELETE\"\ntype SQLQuery<T extends SQLOperation, U extends string> = `${T} * FROM ${U}`\n\ntype UserQuery = SQLQuery<\"SELECT\", \"users\">  // \"SELECT * FROM users\""
    },
    "indexedAccessTypes": {
        "title": "索引访问类型",
        "language": "typescript",
        "code": "// 基础索引访问\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserName = User['name']  // string\ntype UserKeys = keyof User    // \"id\" | \"name\" | \"email\"\n\n// 多个属性访问\ntype UserInfo = User['name' | 'email']  // string\n\n// 数组元素类型\ntype StringArray = string[]\ntype ArrayElement = StringArray[number]  // string\n\n// 嵌套访问\ninterface UserProfile {\n  user: User\n  settings: {\n    theme: 'light' | 'dark'\n    notifications: boolean\n  }\n}\n\ntype Theme = UserProfile['settings']['theme']  // 'light' | 'dark'\n\n// 动态属性访问\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key]\n}\n\nconst user: User = { id: 1, name: 'Alice', email: 'alice@example.com' }\nconst userName = getProperty(user, 'name')  // string类型"
    },
    "typeGuards": {
        "title": "类型守卫",
        "language": "typescript",
        "code": "// 用户定义的类型守卫\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // 这里 value 被推断为 string\n    console.log(value.toUpperCase())\n  }\n}\n\n// 对象类型守卫\ninterface User {\n  id: number\n  name: string\n}\n\ninterface Admin {\n  id: number\n  name: string\n  permissions: string[]\n}\n\nfunction isAdmin(user: User | Admin): user is Admin {\n  return 'permissions' in user\n}\n\nfunction handleUser(user: User | Admin) {\n  if (isAdmin(user)) {\n    // 这里 user 被推断为 Admin\n    console.log(user.permissions)\n  } else {\n    // 这里 user 被推断为 User\n    console.log(user.name)\n  }\n}\n\n// 断言函数\nfunction assertIsNumber(value: unknown): asserts value is number {\n  if (typeof value !== 'number') {\n    throw new Error('Expected number')\n  }\n}\n\nfunction processNumber(value: unknown) {\n  assertIsNumber(value)\n  // 这里 value 被推断为 number\n  console.log(value.toFixed(2))\n}"
    },
    "discriminatedUnions": {
        "title": "可辨识联合",
        "language": "typescript",
        "code": "// 基础可辨识联合\ninterface Circle {\n  kind: 'circle'\n  radius: number\n}\n\ninterface Rectangle {\n  kind: 'rectangle'\n  width: number\n  height: number\n}\n\ninterface Triangle {\n  kind: 'triangle'\n  base: number\n  height: number\n}\n\ntype Shape = Circle | Rectangle | Triangle\n\nfunction getArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2\n    case 'rectangle':\n      return shape.width * shape.height\n    case 'triangle':\n      return (shape.base * shape.height) / 2\n    default:\n      // 确保所有情况都被处理\n      const _exhaustiveCheck: never = shape\n      return _exhaustiveCheck\n  }\n}\n\n// API响应类型\ninterface LoadingState {\n  status: 'loading'\n}\n\ninterface SuccessState {\n  status: 'success'\n  data: any\n}\n\ninterface ErrorState {\n  status: 'error'\n  error: string\n}\n\ntype ApiState = LoadingState | SuccessState | ErrorState\n\nfunction handleApiState(state: ApiState) {\n  switch (state.status) {\n    case 'loading':\n      console.log('Loading...')\n      break\n    case 'success':\n      console.log('Data:', state.data)\n      break\n    case 'error':\n      console.log('Error:', state.error)\n      break\n  }\n}"
    },
    "recursiveTypes": {
        "title": "递归类型",
        "language": "typescript",
        "code": "// JSON类型定义\ntype JSONValue = \n  | string\n  | number\n  | boolean\n  | null\n  | JSONObject\n  | JSONArray\n\ninterface JSONObject {\n  [key: string]: JSONValue\n}\n\ninterface JSONArray extends Array<JSONValue> {}\n\n// 树形结构\ninterface TreeNode<T> {\n  value: T\n  children?: TreeNode<T>[]\n}\n\nconst tree: TreeNode<string> = {\n  value: 'root',\n  children: [\n    {\n      value: 'child1',\n      children: [\n        { value: 'grandchild1' },\n        { value: 'grandchild2' }\n      ]\n    },\n    { value: 'child2' }\n  ]\n}\n\n// 深度只读类型\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]\n}\n\n// 路径类型\ntype Path<T> = T extends object ? {\n  [K in keyof T]: K extends string\n    ? T[K] extends object\n      ? K | `${K}.${Path<T[K]>}`\n      : K\n    : never\n}[keyof T] : never\n\ninterface User {\n  profile: {\n    name: string\n    address: {\n      street: string\n      city: string\n    }\n  }\n  settings: {\n    theme: string\n  }\n}\n\ntype UserPaths = Path<User>\n// \"profile\" | \"settings\" | \"profile.name\" | \"profile.address\" | \"profile.address.street\" | \"profile.address.city\" | \"settings.theme\""
    },
    "higherOrderTypes": {
        "title": "高阶类型",
        "language": "typescript",
        "code": "// 函数组合类型\ntype Compose<F, G> = F extends (arg: infer A) => infer B\n  ? G extends (arg: B) => infer C\n    ? (arg: A) => C\n    : never\n  : never\n\ntype AddOne = (x: number) => number\ntype ToString = (x: number) => string\ntype AddOneAndToString = Compose<AddOne, ToString>  // (x: number) => string\n\n// 柯里化类型\ntype Curry<T> = T extends (...args: infer Args) => infer Return\n  ? Args extends [infer First, ...infer Rest]\n    ? (arg: First) => Rest extends []\n      ? Return\n      : Curry<(...args: Rest) => Return>\n    : () => Return\n  : never\n\ntype Add = (a: number, b: number, c: number) => number\ntype CurriedAdd = Curry<Add>  // (arg: number) => (arg: number) => (arg: number) => number\n\n// 管道类型\ntype Pipe<T extends readonly unknown[], R = {}> = T extends readonly [\n  (...args: any[]) => infer U,\n  ...infer Rest\n]\n  ? Rest extends readonly []\n    ? (...args: any[]) => U\n    : Rest extends readonly [(...args: any[]) => any, ...any[]]\n    ? U extends Parameters<Rest[0]>[0]\n      ? Pipe<Rest, R>\n      : never\n    : never\n  : never\n\n// 类型级别的数学运算\ntype Length<T extends readonly unknown[]> = T['length']\ntype Head<T extends readonly unknown[]> = T extends readonly [infer H, ...unknown[]] ? H : never\ntype Tail<T extends readonly unknown[]> = T extends readonly [unknown, ...infer Rest] ? Rest : []\n\ntype Numbers = [1, 2, 3, 4, 5]\ntype FirstNumber = Head<Numbers>  // 1\ntype RestNumbers = Tail<Numbers>  // [2, 3, 4, 5]\ntype ArrayLength = Length<Numbers>  // 5"
    }
}
