{
  "networkModes": {
    "title": "Docker 网络模式",
    "language": "bash",
    "code": "# 查看所有网络模式\ndocker network ls\n\n# 1. Bridge 网络（默认）\n# 容器连接到虚拟网桥，可以相互通信\ndocker run -d --name web1 --network bridge nginx\ndocker run -d --name web2 --network bridge nginx\n\n# 2. Host 网络\n# 容器直接使用主机网络栈\ndocker run -d --name web-host --network host nginx\n\n# 3. None 网络\n# 容器没有网络接口\ndocker run -d --name isolated --network none alpine sleep 3600\n\n# 4. Container 网络\n# 与其他容器共享网络栈\ndocker run -d --name web1 nginx\ndocker run -d --name web2 --network container:web1 alpine\n\n# 5. 自定义网络\ndocker network create --driver bridge my-network\ndocker run -d --name app --network my-network nginx"
  },
  "customNetworks": {
    "title": "自定义网络创建与配置",
    "language": "bash",
    "code": "# 创建基础自定义网络\ndocker network create my-app-network\n\n# 创建带子网的自定义网络\ndocker network create \\\n  --driver bridge \\\n  --subnet=172.20.0.0/16 \\\n  --ip-range=172.20.240.0/20 \\\n  --gateway=172.20.0.1 \\\n  custom-network\n\n# 创建带DNS配置的网络\ndocker network create \\\n  --driver bridge \\\n  --subnet=192.168.100.0/24 \\\n  --gateway=192.168.100.1 \\\n  --dns=8.8.8.8 \\\n  --dns=8.8.4.4 \\\n  dns-network\n\n# 创建多子网网络\ndocker network create \\\n  --driver bridge \\\n  --subnet=172.28.0.0/16 \\\n  --subnet=172.29.0.0/16 \\\n  multi-subnet-network\n\n# 查看网络详细信息\ndocker network inspect custom-network\n\n# 连接容器到网络\ndocker run -d --name web --network custom-network nginx\ndocker network connect custom-network existing-container\n\n# 断开网络连接\ndocker network disconnect custom-network container-name\n\n# 删除网络\ndocker network rm custom-network"
  },
  "containerCommunication": {
    "title": "容器间通信",
    "language": "bash",
    "code": "# 1. 通过容器名称通信（推荐）\n# 创建自定义网络\ndocker network create app-network\n\n# 启动数据库容器\ndocker run -d \\\n  --name mysql-db \\\n  --network app-network \\\n  -e MYSQL_ROOT_PASSWORD=rootpass \\\n  -e MYSQL_DATABASE=myapp \\\n  mysql:8.0\n\n# 启动应用容器，通过容器名连接数据库\ndocker run -d \\\n  --name web-app \\\n  --network app-network \\\n  -e DB_HOST=mysql-db \\\n  -e DB_PORT=3306 \\\n  -e DB_NAME=myapp \\\n  -p 8080:8080 \\\n  myapp:latest\n\n# 2. 通过IP地址通信\n# 获取容器IP\ndocker inspect mysql-db | grep IPAddress\n\n# 3. 通过别名通信\ndocker run -d \\\n  --name redis-cache \\\n  --network app-network \\\n  --network-alias cache \\\n  redis:alpine\n\n# 应用可以通过 'cache' 访问Redis\ndocker run -d \\\n  --name worker \\\n  --network app-network \\\n  -e REDIS_HOST=cache \\\n  worker:latest\n\n# 4. 多网络连接\ndocker network create frontend-network\ndocker network create backend-network\n\n# 代理服务器连接前端网络\ndocker run -d \\\n  --name nginx-proxy \\\n  --network frontend-network \\\n  -p 80:80 \\\n  nginx\n\n# 应用服务器连接两个网络\ndocker run -d \\\n  --name app-server \\\n  --network backend-network \\\n  myapp:latest\n\ndocker network connect frontend-network app-server"
  },
  "portMapping": {
    "title": "端口映射与暴露",
    "language": "bash",
    "code": "# 基础端口映射\n# 映射单个端口\ndocker run -d -p 8080:80 nginx\n\n# 映射多个端口\ndocker run -d \\\n  -p 80:80 \\\n  -p 443:443 \\\n  -p 8080:8080 \\\n  nginx\n\n# 指定主机IP映射\ndocker run -d -p 127.0.0.1:8080:80 nginx\n\n# 映射到随机端口\ndocker run -d -P nginx\ndocker port container-name  # 查看端口映射\n\n# UDP端口映射\ndocker run -d -p 53:53/udp dns-server\n\n# 端口范围映射\ndocker run -d -p 8000-8010:8000-8010 multi-port-app\n\n# 暴露端口（不映射到主机）\ndocker run -d --expose 3000 myapp\n\n# 查看容器端口\ndocker port container-name\ndocker inspect container-name | grep PortBindings\n\n# 动态端口映射示例\n# 启动多个相同服务实例\nfor i in {1..3}; do\n  docker run -d \\\n    --name web-$i \\\n    -p 808$i:80 \\\n    nginx\ndone\n\n# 负载均衡配置\ndocker run -d \\\n  --name load-balancer \\\n  -p 80:80 \\\n  -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf \\\n  nginx"
  },
  "networkSecurity": {
    "title": "网络安全配置",
    "language": "bash",
    "code": "# 1. 网络隔离\n# 创建隔离的网络\ndocker network create --internal secure-network\n\n# 内部服务（无外网访问）\ndocker run -d \\\n  --name database \\\n  --network secure-network \\\n  postgres:13\n\n# 2. 防火墙规则\n# 限制容器间通信\ndocker network create \\\n  --driver bridge \\\n  --opt com.docker.network.bridge.enable_icc=false \\\n  isolated-network\n\n# 3. TLS/SSL配置\n# 使用TLS证书\ndocker run -d \\\n  --name secure-web \\\n  -p 443:443 \\\n  -v $(pwd)/ssl:/etc/ssl/certs \\\n  -e SSL_CERT=/etc/ssl/certs/cert.pem \\\n  -e SSL_KEY=/etc/ssl/certs/key.pem \\\n  nginx\n\n# 4. 网络策略\n# 创建受限网络\ndocker network create \\\n  --driver bridge \\\n  --opt com.docker.network.bridge.enable_ip_masquerade=false \\\n  restricted-network\n\n# 5. 容器安全选项\ndocker run -d \\\n  --name secure-app \\\n  --network secure-network \\\n  --security-opt no-new-privileges \\\n  --read-only \\\n  --tmpfs /tmp \\\n  myapp:latest\n\n# 6. 网络监控\n# 监控网络流量\ndocker run -d \\\n  --name network-monitor \\\n  --network host \\\n  --cap-add NET_ADMIN \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  monitoring-tool\n\n# 7. 访问控制\n# 使用用户定义的网络和标签\ndocker network create \\\n  --label environment=production \\\n  --label security=high \\\n  prod-network"
  },
  "troubleshooting": {
    "title": "网络故障排查",
    "language": "bash",
    "code": "# 1. 网络连通性测试\n# 测试容器间连通性\ndocker exec container1 ping container2\ndocker exec container1 telnet container2 80\n\n# 测试外网连通性\ndocker exec container1 ping 8.8.8.8\ndocker exec container1 nslookup google.com\n\n# 2. 网络信息查看\n# 查看容器网络配置\ndocker inspect container-name | grep -A 20 NetworkSettings\n\n# 查看网络详情\ndocker network inspect network-name\n\n# 查看容器进程网络\ndocker exec container-name netstat -tulpn\ndocker exec container-name ss -tulpn\n\n# 3. 端口检查\n# 检查端口占用\ndocker exec container-name lsof -i :80\nnetstat -tulpn | grep :8080\n\n# 检查防火墙\nsudo iptables -L\nsudo ufw status\n\n# 4. DNS解析测试\n# 测试DNS解析\ndocker exec container-name nslookup service-name\ndocker exec container-name dig service-name\n\n# 查看DNS配置\ndocker exec container-name cat /etc/resolv.conf\n\n# 5. 网络流量分析\n# 抓包分析\ndocker exec container-name tcpdump -i eth0\nsudo tcpdump -i docker0\n\n# 查看网络统计\ndocker exec container-name cat /proc/net/dev\ndocker stats container-name\n\n# 6. 常见问题解决\n# 重启Docker网络\nsudo systemctl restart docker\n\n# 清理无用网络\ndocker network prune\n\n# 重建默认网络\ndocker network rm bridge\nsudo systemctl restart docker\n\n# 检查Docker守护进程\nsudo journalctl -u docker.service\ndocker system info"
  },
  "performanceOptimization": {
    "title": "网络性能优化",
    "language": "bash",
    "code": "# 1. 网络驱动优化\n# 使用高性能网络驱动\ndocker network create \\\n  --driver bridge \\\n  --opt com.docker.network.driver.mtu=9000 \\\n  high-perf-network\n\n# 2. 容器网络配置优化\n# 调整网络缓冲区\ndocker run -d \\\n  --name optimized-app \\\n  --sysctl net.core.rmem_max=134217728 \\\n  --sysctl net.core.wmem_max=134217728 \\\n  --sysctl net.ipv4.tcp_rmem=\"4096 65536 134217728\" \\\n  --sysctl net.ipv4.tcp_wmem=\"4096 65536 134217728\" \\\n  myapp:latest\n\n# 3. 连接池配置\n# 数据库连接池优化\ndocker run -d \\\n  --name database \\\n  -e POSTGRES_MAX_CONNECTIONS=200 \\\n  -e POSTGRES_SHARED_BUFFERS=256MB \\\n  postgres:13\n\n# 应用连接池配置\ndocker run -d \\\n  --name app \\\n  -e DB_POOL_SIZE=20 \\\n  -e DB_POOL_TIMEOUT=30000 \\\n  myapp:latest\n\n# 4. 负载均衡\n# Nginx负载均衡\ndocker run -d \\\n  --name nginx-lb \\\n  -p 80:80 \\\n  -v $(pwd)/nginx-lb.conf:/etc/nginx/nginx.conf \\\n  nginx\n\n# HAProxy负载均衡\ndocker run -d \\\n  --name haproxy-lb \\\n  -p 80:80 \\\n  -v $(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg \\\n  haproxy\n\n# 5. 缓存策略\n# Redis缓存\ndocker run -d \\\n  --name redis-cache \\\n  --memory=1g \\\n  -p 6379:6379 \\\n  redis:alpine redis-server --maxmemory 1gb --maxmemory-policy allkeys-lru\n\n# CDN配置\ndocker run -d \\\n  --name cdn-cache \\\n  -p 8080:80 \\\n  -v $(pwd)/static:/usr/share/nginx/html \\\n  nginx\n\n# 6. 监控和指标\n# 网络性能监控\ndocker run -d \\\n  --name netdata \\\n  -p 19999:19999 \\\n  --cap-add SYS_PTRACE \\\n  -v /proc:/host/proc:ro \\\n  -v /sys:/host/sys:ro \\\n  netdata/netdata\n\n# Prometheus监控\ndocker run -d \\\n  --name prometheus \\\n  -p 9090:9090 \\\n  -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n  prom/prometheus"
  },
  "bestPracticeNetworkIsolation": {
    "title": "网络隔离设计示例",
    "language": "bash",
    "code": "# ✅ 好的设计 - 分层网络隔离\n# 前端网络\ndocker network create frontend-network\n\n# 后端网络\ndocker network create backend-network\n\n# 数据库网络（内部）\ndocker network create --internal database-network\n\n# 前端服务只连接前端网络\ndocker run -d --name nginx --network frontend-network nginx\n\n# 应用服务连接前端和后端网络\ndocker run -d --name app --network backend-network myapp\ndocker network connect frontend-network app\n\n# 数据库只连接内部网络\ndocker run -d --name db --network database-network postgres\ndocker network connect backend-network db\n\n# ❌ 不好的设计 - 所有服务在同一网络\ndocker run -d --name nginx nginx\ndocker run -d --name app myapp\ndocker run -d --name db postgres\n# 所有服务都在默认bridge网络，缺乏隔离"
  },
  "bestPracticeServiceNaming": {
    "title": "服务命名最佳实践",
    "language": "bash",
    "code": "# ✅ 推荐 - 清晰的命名和别名\ndocker run -d \\\n  --name user-service \\\n  --network app-network \\\n  --network-alias users \\\n  user-service:latest\n\n docker run -d \\\n  --name order-service \\\n  --network app-network \\\n  --network-alias orders \\\n  -e USER_SERVICE_URL=http://users:3000 \\\n  order-service:latest\n\n# ❌ 不推荐 - 模糊的命名\ndocker run -d --name app1 service:latest\ndocker run -d --name app2 service:latest\n# 难以识别服务功能和依赖关系"
  },
  "bestPracticePortManagement": {
    "title": "端口管理策略",
    "language": "bash",
    "code": "# ✅ 好的端口管理\n# 使用标准端口映射\ndocker run -d -p 80:80 --name web nginx\ndocker run -d -p 443:443 --name web-ssl nginx\n\n# 为不同环境使用不同端口段\n# 开发环境: 8000-8099\ndocker run -d -p 8080:80 --name dev-web nginx\n\n# 测试环境: 8100-8199\ndocker run -d -p 8180:80 --name test-web nginx\n\n# 生产环境: 80, 443\ndocker run -d -p 80:80 -p 443:443 --name prod-web nginx\n\n# 内部服务不暴露端口\ndocker run -d --name internal-service \\\n  --network backend-network \\\n  internal-service:latest\n\n# ❌ 避免的做法\n# 随意的端口映射\ndocker run -d -p 12345:80 nginx\ndocker run -d -p 54321:3000 myapp"
  }
}