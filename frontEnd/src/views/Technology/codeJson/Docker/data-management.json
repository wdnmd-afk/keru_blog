{
  "volumeBasics": {
    "title": "Docker 卷基础概念",
    "language": "bash",
    "code": "# 1. 创建和管理 Docker 卷\n# 创建命名卷\ndocker volume create my-volume\ndocker volume create --driver local my-local-volume\n\n# 查看卷列表\ndocker volume ls\n\n# 查看卷详细信息\ndocker volume inspect my-volume\n\n# 删除卷\ndocker volume rm my-volume\n\n# 删除所有未使用的卷\ndocker volume prune\n\n# 2. 使用卷挂载容器\n# 挂载命名卷\ndocker run -d \\\n  --name web-server \\\n  -v my-volume:/var/www/html \\\n  nginx:latest\n\n# 挂载多个卷\ndocker run -d \\\n  --name database \\\n  -v db-data:/var/lib/mysql \\\n  -v db-config:/etc/mysql/conf.d \\\n  -v db-logs:/var/log/mysql \\\n  mysql:8.0\n\n# 3. 绑定挂载（Bind Mounts）\n# 挂载主机目录到容器\ndocker run -d \\\n  --name dev-server \\\n  -v /host/path:/container/path \\\n  -v $(pwd):/app \\\n  node:18-alpine\n\n# 只读挂载\ndocker run -d \\\n  --name readonly-app \\\n  -v /host/config:/app/config:ro \\\n  myapp:latest\n\n# 4. tmpfs 挂载（临时文件系统）\n# 挂载内存文件系统\ndocker run -d \\\n  --name temp-storage \\\n  --tmpfs /tmp:rw,noexec,nosuid,size=100m \\\n  ubuntu:latest\n\n# 5. 卷的备份和恢复\n# 备份卷数据\ndocker run --rm \\\n  -v my-volume:/data \\\n  -v $(pwd):/backup \\\n  ubuntu tar czf /backup/backup.tar.gz -C /data .\n\n# 恢复卷数据\ndocker run --rm \\\n  -v my-volume:/data \\\n  -v $(pwd):/backup \\\n  ubuntu tar xzf /backup/backup.tar.gz -C /data\n\n# 6. 卷驱动程序\n# 使用不同的卷驱动\ndocker volume create \\\n  --driver local \\\n  --opt type=nfs \\\n  --opt o=addr=192.168.1.100,rw \\\n  --opt device=:/path/to/dir \\\n  nfs-volume\n\n# 7. 卷标签和元数据\n# 创建带标签的卷\ndocker volume create \\\n  --label environment=production \\\n  --label application=web \\\n  prod-web-volume\n\n# 根据标签过滤卷\ndocker volume ls --filter label=environment=production"
  },
  "dataContainers": {
    "title": "数据容器模式",
    "language": "bash",
    "code": "# 1. 创建数据容器\n# 创建专用数据容器\ndocker create \\\n  --name data-container \\\n  -v /data \\\n  -v /logs \\\n  -v /config \\\n  busybox\n\n# 2. 使用数据容器\n# 应用容器使用数据容器的卷\ndocker run -d \\\n  --name app1 \\\n  --volumes-from data-container \\\n  myapp:latest\n\ndocker run -d \\\n  --name app2 \\\n  --volumes-from data-container \\\n  myapp:latest\n\n# 3. 数据容器的备份\n# 备份数据容器\ndocker run --rm \\\n  --volumes-from data-container \\\n  -v $(pwd):/backup \\\n  ubuntu tar czf /backup/data-backup.tar.gz /data /logs /config\n\n# 4. 数据容器的迁移\n# 导出数据容器\ndocker export data-container > data-container.tar\n\n# 在新主机上导入\ndocker import data-container.tar data-container:latest\n\n# 5. 共享数据容器\n# 多个应用共享同一数据容器\ndocker run -d \\\n  --name web-app \\\n  --volumes-from data-container \\\n  nginx:latest\n\ndocker run -d \\\n  --name api-app \\\n  --volumes-from data-container \\\n  node:18-alpine\n\n# 6. 数据容器的生命周期管理\n# 创建持久化数据容器\ndocker run -d \\\n  --name persistent-data \\\n  --restart=unless-stopped \\\n  -v persistent-volume:/data \\\n  busybox tail -f /dev/null\n\n# 7. 数据容器的权限管理\n# 设置数据容器权限\ndocker run -d \\\n  --name secure-data \\\n  --user 1000:1000 \\\n  -v secure-volume:/data:Z \\\n  busybox\n\n# 8. 数据容器监控\n# 监控数据容器状态\ndocker stats data-container\ndocker logs data-container"
  },
  "persistentStorage": {
    "title": "持久化存储策略",
    "language": "dockerfile",
    "code": "# 1. Dockerfile 中的卷定义\nFROM ubuntu:20.04\n\n# 创建应用目录\nWORKDIR /app\n\n# 安装应用依赖\nRUN apt-get update && \\\n    apt-get install -y python3 python3-pip && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 复制应用代码\nCOPY . .\n\n# 安装 Python 依赖\nRUN pip3 install -r requirements.txt\n\n# 定义数据卷\nVOLUME [\"/app/data\", \"/app/logs\", \"/app/uploads\"]\n\n# 设置环境变量\nENV DATA_DIR=/app/data \\\n    LOG_DIR=/app/logs \\\n    UPLOAD_DIR=/app/uploads\n\n# 创建非 root 用户\nRUN useradd -m -u 1000 appuser && \\\n    chown -R appuser:appuser /app\n\nUSER appuser\n\n# 暴露端口\nEXPOSE 8080\n\n# 启动应用\nCMD [\"python3\", \"app.py\"]\n\n# 2. 多阶段构建中的数据管理\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\n\n# 生产阶段\nFROM nginx:alpine AS production\n\n# 复制构建产物\nCOPY --from=builder /app/dist /usr/share/nginx/html\n\n# 创建数据目录\nRUN mkdir -p /var/log/nginx/app && \\\n    mkdir -p /etc/nginx/ssl && \\\n    mkdir -p /var/cache/nginx/app\n\n# 定义卷\nVOLUME [\"/var/log/nginx/app\", \"/etc/nginx/ssl\", \"/var/cache/nginx/app\"]\n\n# 复制 Nginx 配置\nCOPY nginx.conf /etc/nginx/nginx.conf\n\n# 3. 数据库容器的持久化\nFROM postgres:13\n\n# 设置环境变量\nENV POSTGRES_DB=myapp \\\n    POSTGRES_USER=appuser \\\n    POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password\n\n# 创建数据目录\nRUN mkdir -p /var/lib/postgresql/backup && \\\n    mkdir -p /var/lib/postgresql/archive && \\\n    chown -R postgres:postgres /var/lib/postgresql\n\n# 定义数据卷\nVOLUME [\"/var/lib/postgresql/data\", \"/var/lib/postgresql/backup\", \"/var/lib/postgresql/archive\"]\n\n# 复制初始化脚本\nCOPY init-scripts/ /docker-entrypoint-initdb.d/\n\n# 复制备份脚本\nCOPY backup-script.sh /usr/local/bin/\nRUN chmod +x /usr/local/bin/backup-script.sh\n\n# 4. 应用配置的持久化\nFROM openjdk:11-jre-slim\n\n# 创建应用用户\nRUN useradd -m -u 1000 appuser\n\n# 创建应用目录\nWORKDIR /app\n\n# 创建配置和数据目录\nRUN mkdir -p /app/config && \\\n    mkdir -p /app/data && \\\n    mkdir -p /app/logs && \\\n    mkdir -p /app/temp && \\\n    chown -R appuser:appuser /app\n\n# 定义卷\nVOLUME [\"/app/config\", \"/app/data\", \"/app/logs\"]\n\n# 复制应用 JAR\nCOPY target/myapp.jar /app/\n\n# 切换到应用用户\nUSER appuser\n\n# 设置 JVM 参数\nENV JAVA_OPTS=\"-Xmx512m -Xms256m -Djava.io.tmpdir=/app/temp\"\n\n# 启动应用\nCMD java $JAVA_OPTS -jar myapp.jar"
  },
  "dockerCompose": {
    "title": "Docker Compose 数据管理",
    "language": "yaml",
    "code": "# docker-compose.yml - 完整的数据管理示例\nversion: '3.8'\n\nservices:\n  # Web 应用服务\n  web:\n    build: .\n    ports:\n      - \"8080:8080\"\n    volumes:\n      # 应用数据卷\n      - app-data:/app/data\n      - app-logs:/app/logs\n      # 配置文件绑定挂载\n      - ./config:/app/config:ro\n      # 上传文件卷\n      - uploads:/app/uploads\n    environment:\n      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - db\n      - redis\n    networks:\n      - app-network\n\n  # 数据库服务\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n    volumes:\n      # 数据库数据持久化\n      - postgres-data:/var/lib/postgresql/data\n      # 数据库备份\n      - postgres-backup:/backup\n      # 初始化脚本\n      - ./init-db:/docker-entrypoint-initdb.d:ro\n    ports:\n      - \"5432:5432\"\n    networks:\n      - app-network\n\n  # Redis 缓存服务\n  redis:\n    image: redis:alpine\n    volumes:\n      # Redis 数据持久化\n      - redis-data:/data\n      # Redis 配置\n      - ./redis.conf:/usr/local/etc/redis/redis.conf:ro\n    command: redis-server /usr/local/etc/redis/redis.conf\n    ports:\n      - \"6379:6379\"\n    networks:\n      - app-network\n\n  # Nginx 反向代理\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      # Nginx 配置\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      # SSL 证书\n      - ssl-certs:/etc/nginx/ssl\n      # 静态文件\n      - static-files:/var/www/html\n      # 日志\n      - nginx-logs:/var/log/nginx\n    depends_on:\n      - web\n    networks:\n      - app-network\n\n  # 文件备份服务\n  backup:\n    image: alpine:latest\n    volumes:\n      # 挂载所有需要备份的卷\n      - app-data:/backup/app-data:ro\n      - postgres-data:/backup/postgres-data:ro\n      - uploads:/backup/uploads:ro\n      # 备份存储\n      - backup-storage:/backups\n      # 备份脚本\n      - ./backup-scripts:/scripts:ro\n    command: \"sh /scripts/backup.sh\"\n    networks:\n      - app-network\n\n  # 监控服务\n  monitoring:\n    image: prom/prometheus\n    ports:\n      - \"9090:9090\"\n    volumes:\n      # Prometheus 配置\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro\n      # Prometheus 数据\n      - prometheus-data:/prometheus\n    networks:\n      - app-network\n\n# 定义卷\nvolumes:\n  # 应用数据卷\n  app-data:\n    driver: local\n    driver_opts:\n      type: none\n      o: bind\n      device: /opt/app-data\n\n  # 应用日志卷\n  app-logs:\n    driver: local\n\n  # 用户上传文件卷\n  uploads:\n    driver: local\n    driver_opts:\n      type: none\n      o: bind\n      device: /opt/uploads\n\n  # PostgreSQL 数据卷\n  postgres-data:\n    driver: local\n    driver_opts:\n      type: none\n      o: bind\n      device: /opt/postgres-data\n\n  # PostgreSQL 备份卷\n  postgres-backup:\n    driver: local\n\n  # Redis 数据卷\n  redis-data:\n    driver: local\n\n  # SSL 证书卷\n  ssl-certs:\n    driver: local\n\n  # 静态文件卷\n  static-files:\n    driver: local\n\n  # Nginx 日志卷\n  nginx-logs:\n    driver: local\n\n  # 备份存储卷\n  backup-storage:\n    driver: local\n    driver_opts:\n      type: none\n      o: bind\n      device: /opt/backups\n\n  # Prometheus 数据卷\n  prometheus-data:\n    driver: local\n\n# 定义网络\nnetworks:\n  app-network:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16"
  },
  "backupRestore": {
    "title": "数据备份和恢复",
    "language": "bash",
    "code": "# 1. 卷数据备份脚本\n#!/bin/bash\n# backup-volumes.sh\n\nset -e\n\n# 配置变量\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\nVOLUMES=(\"app-data\" \"postgres-data\" \"uploads\")\n\n# 创建备份目录\nmkdir -p $BACKUP_DIR\n\n# 备份每个卷\nfor volume in \"${VOLUMES[@]}\"; do\n    echo \"Backing up volume: $volume\"\n    \n    # 创建备份\n    docker run --rm \\\n        -v ${volume}:/data:ro \\\n        -v ${BACKUP_DIR}:/backup \\\n        alpine:latest \\\n        tar czf /backup/${volume}_${DATE}.tar.gz -C /data .\n    \n    echo \"Backup completed: ${volume}_${DATE}.tar.gz\"\ndone\n\n# 清理旧备份（保留最近7天）\nfind $BACKUP_DIR -name \"*.tar.gz\" -mtime +7 -delete\n\necho \"All backups completed successfully\"\n\n# 2. 数据库备份脚本\n#!/bin/bash\n# backup-database.sh\n\nset -e\n\n# 数据库配置\nDB_CONTAINER=\"myapp_db_1\"\nDB_NAME=\"myapp\"\nDB_USER=\"postgres\"\nBACKUP_DIR=\"/backups/database\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\n# 创建备份目录\nmkdir -p $BACKUP_DIR\n\n# SQL 转储备份\necho \"Creating SQL dump backup...\"\ndocker exec $DB_CONTAINER pg_dump -U $DB_USER $DB_NAME > \"$BACKUP_DIR/dump_${DATE}.sql\"\n\n# 压缩备份\ngzip \"$BACKUP_DIR/dump_${DATE}.sql\"\n\n# 二进制备份（更快）\necho \"Creating binary backup...\"\ndocker exec $DB_CONTAINER pg_dump -U $DB_USER -Fc $DB_NAME > \"$BACKUP_DIR/backup_${DATE}.dump\"\n\n# 3. 应用数据恢复脚本\n#!/bin/bash\n# restore-volumes.sh\n\nset -e\n\nif [ $# -ne 2 ]; then\n    echo \"Usage: $0 <volume_name> <backup_file>\"\n    exit 1\nfi\n\nVOLUME_NAME=$1\nBACKUP_FILE=$2\n\nif [ ! -f \"$BACKUP_FILE\" ]; then\n    echo \"Backup file not found: $BACKUP_FILE\"\n    exit 1\nfi\n\necho \"Restoring volume $VOLUME_NAME from $BACKUP_FILE...\"\n\n# 停止使用该卷的容器\necho \"Stopping containers using volume $VOLUME_NAME...\"\ndocker ps --filter volume=$VOLUME_NAME --format \"{{.Names}}\" | xargs -r docker stop\n\n# 恢复数据\ndocker run --rm \\\n    -v ${VOLUME_NAME}:/data \\\n    -v $(dirname $BACKUP_FILE):/backup \\\n    alpine:latest \\\n    sh -c \"rm -rf /data/* && tar xzf /backup/$(basename $BACKUP_FILE) -C /data\"\n\necho \"Volume $VOLUME_NAME restored successfully\"\n\n# 4. 数据库恢复脚本\n#!/bin/bash\n# restore-database.sh\n\nset -e\n\nif [ $# -ne 2 ]; then\n    echo \"Usage: $0 <backup_type> <backup_file>\"\n    echo \"backup_type: sql or dump\"\n    exit 1\nfi\n\nBACKUP_TYPE=$1\nBACKUP_FILE=$2\nDB_CONTAINER=\"myapp_db_1\"\nDB_NAME=\"myapp\"\nDB_USER=\"postgres\"\n\nif [ ! -f \"$BACKUP_FILE\" ]; then\n    echo \"Backup file not found: $BACKUP_FILE\"\n    exit 1\nfi\n\necho \"Restoring database from $BACKUP_FILE...\"\n\n# 停止应用容器\necho \"Stopping application containers...\"\ndocker-compose stop web\n\nif [ \"$BACKUP_TYPE\" = \"sql\" ]; then\n    # 恢复 SQL 转储\n    if [[ $BACKUP_FILE == *.gz ]]; then\n        gunzip -c \"$BACKUP_FILE\" | docker exec -i $DB_CONTAINER psql -U $DB_USER -d $DB_NAME\n    else\n        docker exec -i $DB_CONTAINER psql -U $DB_USER -d $DB_NAME < \"$BACKUP_FILE\"\n    fi\nelif [ \"$BACKUP_TYPE\" = \"dump\" ]; then\n    # 恢复二进制转储\n    docker exec -i $DB_CONTAINER pg_restore -U $DB_USER -d $DB_NAME --clean < \"$BACKUP_FILE\"\nelse\n    echo \"Invalid backup type: $BACKUP_TYPE\"\n    exit 1\nfi\n\n# 重启应用容器\necho \"Starting application containers...\"\ndocker-compose start web\n\necho \"Database restored successfully\"\n\n# 5. 自动化备份 Cron 任务\n# 添加到 crontab\n# 0 2 * * * /path/to/backup-volumes.sh >> /var/log/backup.log 2>&1\n# 0 3 * * * /path/to/backup-database.sh >> /var/log/backup.log 2>&1\n\n# 6. 远程备份同步\n#!/bin/bash\n# sync-backups.sh\n\nset -e\n\nLOCAL_BACKUP_DIR=\"/backups\"\nREMOTE_HOST=\"backup-server.example.com\"\nREMOTE_USER=\"backup\"\nREMOTE_DIR=\"/remote/backups\"\n\necho \"Syncing backups to remote server...\"\n\n# 使用 rsync 同步备份\nrsync -avz --delete \\\n    --exclude='*.tmp' \\\n    $LOCAL_BACKUP_DIR/ \\\n    $REMOTE_USER@$REMOTE_HOST:$REMOTE_DIR/\n\necho \"Backup sync completed\"\n\n# 7. 备份验证脚本\n#!/bin/bash\n# verify-backup.sh\n\nset -e\n\nBACKUP_FILE=$1\n\nif [ ! -f \"$BACKUP_FILE\" ]; then\n    echo \"Backup file not found: $BACKUP_FILE\"\n    exit 1\nfi\n\necho \"Verifying backup: $BACKUP_FILE\"\n\n# 检查压缩文件完整性\nif [[ $BACKUP_FILE == *.tar.gz ]]; then\n    tar -tzf \"$BACKUP_FILE\" > /dev/null\n    echo \"Backup archive is valid\"\nelif [[ $BACKUP_FILE == *.sql.gz ]]; then\n    gunzip -t \"$BACKUP_FILE\"\n    echo \"SQL backup is valid\"\nelse\n    echo \"Unknown backup format\"\n    exit 1\nfi\n\necho \"Backup verification completed\""
  },
  "performanceOptimization": {
    "title": "存储性能优化",
    "language": "bash",
    "code": "# 1. 卷性能监控\n# 监控卷使用情况\ndocker system df -v\n\n# 查看卷详细信息\ndocker volume inspect my-volume\n\n# 监控容器存储性能\ndocker stats --format \"table {{.Container}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.BlockIO}}\"\n\n# 2. 存储驱动优化\n# 查看当前存储驱动\ndocker info | grep \"Storage Driver\"\n\n# 配置存储驱动（daemon.json）\n# {\n#   \"storage-driver\": \"overlay2\",\n#   \"storage-opts\": [\n#     \"overlay2.override_kernel_check=true\"\n#   ]\n# }\n\n# 3. 卷类型选择优化\n# 本地卷（最快）\ndocker volume create --driver local fast-volume\n\n# NFS 卷（网络共享）\ndocker volume create \\\n  --driver local \\\n  --opt type=nfs \\\n  --opt o=addr=192.168.1.100,rw \\\n  --opt device=:/shared/data \\\n  nfs-volume\n\n# 4. 缓存策略优化\n# 使用 tmpfs 提高临时文件性能\ndocker run -d \\\n  --name cache-app \\\n  --tmpfs /tmp:rw,noexec,nosuid,size=1g \\\n  --tmpfs /var/cache:rw,size=512m \\\n  myapp:latest\n\n# 5. 数据库存储优化\n# PostgreSQL 性能优化\ndocker run -d \\\n  --name postgres-optimized \\\n  -e POSTGRES_DB=myapp \\\n  -e POSTGRES_USER=postgres \\\n  -e POSTGRES_PASSWORD=password \\\n  -v postgres-data:/var/lib/postgresql/data \\\n  -v postgres-logs:/var/log/postgresql \\\n  --shm-size=256m \\\n  postgres:13 \\\n  -c shared_buffers=256MB \\\n  -c effective_cache_size=1GB \\\n  -c maintenance_work_mem=64MB \\\n  -c checkpoint_completion_target=0.9 \\\n  -c wal_buffers=16MB\n\n# 6. 文件系统优化\n# 使用 bind mount 优化\ndocker run -d \\\n  --name optimized-app \\\n  -v /opt/app-data:/app/data:rw,Z \\\n  -v /opt/app-logs:/app/logs:rw,Z \\\n  --mount type=bind,source=/opt/config,target=/app/config,readonly \\\n  myapp:latest\n\n# 7. 容器层优化\n# 减少层数的 Dockerfile\nFROM alpine:latest\nRUN apk add --no-cache \\\n    python3 \\\n    python3-dev \\\n    py3-pip \\\n    && pip3 install --no-cache-dir flask \\\n    && rm -rf /var/cache/apk/*\n\n# 8. 清理和维护\n# 清理未使用的卷\ndocker volume prune -f\n\n# 清理未使用的镜像\ndocker image prune -a -f\n\n# 清理构建缓存\ndocker builder prune -a -f\n\n# 9. 性能测试脚本\n#!/bin/bash\n# storage-benchmark.sh\n\nset -e\n\nVOLUME_NAME=\"test-volume\"\nTEST_SIZE=\"1G\"\n\necho \"Creating test volume...\"\ndocker volume create $VOLUME_NAME\n\necho \"Running write performance test...\"\ntime docker run --rm \\\n  -v $VOLUME_NAME:/test \\\n  alpine:latest \\\n  dd if=/dev/zero of=/test/testfile bs=1M count=1024\n\necho \"Running read performance test...\"\ntime docker run --rm \\\n  -v $VOLUME_NAME:/test \\\n  alpine:latest \\\n  dd if=/test/testfile of=/dev/null bs=1M\n\necho \"Cleaning up...\"\ndocker volume rm $VOLUME_NAME\n\necho \"Performance test completed\""
  }
}