{
    "containerSecurity": {
        "title": "容器安全基础",
        "language": "bash",
        "code": "# 1. 使用非 root 用户运行容器\ndocker run -d --user 1000:1000 nginx\n\n# 2. 只读文件系统\ndocker run -d --read-only --tmpfs /tmp nginx\n\n# 3. 禁用新权限\ndocker run -d --security-opt no-new-privileges nginx\n\n# 4. 删除不必要的能力\ndocker run -d --cap-drop ALL --cap-add NET_BIND_SERVICE nginx\n\n# 5. 限制资源使用\ndocker run -d \\\n  --memory=512m \\\n  --cpus=\"1.0\" \\\n  --pids-limit=100 \\\n  nginx\n\n# 6. 使用安全的网络模式\ndocker run -d --network none myapp\ndocker run -d --network custom-network myapp\n\n# 7. 挂载只读卷\ndocker run -d -v /host/config:/app/config:ro nginx"
    },
    "imageSecurity": {
        "title": "镜像安全扫描",
        "language": "bash",
        "code": "# 1. 使用 Docker Scout 扫描镜像\ndocker scout cves nginx:latest\ndocker scout recommendations nginx:latest\n\n# 2. 使用 Trivy 扫描镜像\n# 安装 Trivy\ncurl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin\n\n# 扫描镜像漏洞\ntrivy image nginx:latest\ntrivy image --severity HIGH,CRITICAL nginx:latest\n\n# 3. 使用 Clair 扫描\ndocker run -d --name clair-db postgres:latest\ndocker run -d --name clair --link clair-db:postgres quay.io/coreos/clair:latest\n\n# 4. 使用 Anchore Engine\ndocker run -d --name anchore-engine anchore/anchore-engine:latest\nanchore-cli image add nginx:latest\nanchore-cli image vuln nginx:latest all\n\n# 5. 镜像签名验证\n# 启用 Docker Content Trust\nexport DOCKER_CONTENT_TRUST=1\ndocker pull nginx:latest\n\n# 6. 基础镜像选择\n# 使用官方镜像\ndocker pull nginx:alpine\ndocker pull node:18-alpine\n\n# 使用 distroless 镜像\ndocker pull gcr.io/distroless/java:11"
    },
    "secretsManagement": {
        "title": "密钥和敏感信息管理",
        "language": "bash",
        "code": "# 1. 使用 Docker Secrets (Swarm 模式)\n# 创建密钥\necho \"mypassword\" | docker secret create db_password -\n\n# 在服务中使用密钥\ndocker service create \\\n  --name webapp \\\n  --secret db_password \\\n  --env DB_PASSWORD_FILE=/run/secrets/db_password \\\n  myapp:latest\n\n# 2. 使用外部密钥管理系统\n# HashiCorp Vault\nvault kv put secret/myapp/db password=\"secretpassword\"\n\n# 在容器中获取密钥\ndocker run -d \\\n  --name myapp \\\n  -e VAULT_ADDR=https://vault.example.com \\\n  -e VAULT_TOKEN=\"s.xyz123\" \\\n  myapp:latest\n\n# 3. 使用 init 容器获取密钥\n# docker-compose.yml 示例\n# version: '3.8'\n# services:\n#   init-secrets:\n#     image: vault:latest\n#     command: sh -c \"vault kv get -field=password secret/db > /shared/db_password\"\n#     volumes:\n#       - shared-data:/shared\n#   \n#   app:\n#     image: myapp:latest\n#     depends_on:\n#       - init-secrets\n#     volumes:\n#       - shared-data:/secrets\n\n# 4. 环境变量最佳实践\n# ❌ 避免在 Dockerfile 中硬编码密钥\n# ENV DB_PASSWORD=secretpassword\n\n# ✅ 运行时传入环境变量\ndocker run -d --env-file .env myapp:latest\n\n# 5. 文件权限管理\ndocker run -d \\\n  -v /host/secrets:/app/secrets:ro \\\n  --user 1000:1000 \\\n  myapp:latest"
    },
    "networkSecurity": {
        "title": "网络安全配置",
        "language": "bash",
        "code": "# 1. 创建隔离网络\ndocker network create --driver bridge \\\n  --opt com.docker.network.bridge.enable_icc=false \\\n  isolated-network\n\n# 2. 内部网络（无外网访问）\ndocker network create --internal secure-internal\n\n# 3. 自定义网络与防火墙规则\ndocker network create \\\n  --driver bridge \\\n  --subnet=172.20.0.0/16 \\\n  --ip-range=172.20.240.0/20 \\\n  custom-network\n\n# 4. 容器间通信控制\n# 禁用容器间通信\ndocker network create \\\n  --opt com.docker.network.bridge.enable_icc=false \\\n  no-inter-container\n\n# 5. TLS/SSL 配置\n# 生成自签名证书\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt\n\n# 在容器中使用 TLS\ndocker run -d \\\n  --name secure-web \\\n  -p 443:443 \\\n  -v $(pwd)/server.crt:/etc/ssl/certs/server.crt:ro \\\n  -v $(pwd)/server.key:/etc/ssl/private/server.key:ro \\\n  nginx\n\n# 6. 网络策略示例\n# 只允许特定端口\ndocker run -d \\\n  --name restricted-app \\\n  --publish 127.0.0.1:8080:8080 \\\n  myapp:latest\n\n# 7. 使用代理和负载均衡\ndocker run -d \\\n  --name nginx-proxy \\\n  -p 80:80 -p 443:443 \\\n  -v /var/run/docker.sock:/tmp/docker.sock:ro \\\n  nginxproxy/nginx-proxy"
    },
    "runtimeSecurity": {
        "title": "运行时安全监控",
        "language": "bash",
        "code": "# 1. 容器运行时监控\n# 使用 Falco 进行运行时安全监控\ndocker run -d \\\n  --name falco \\\n  --privileged \\\n  -v /var/run/docker.sock:/host/var/run/docker.sock \\\n  -v /dev:/host/dev \\\n  -v /proc:/host/proc:ro \\\n  -v /boot:/host/boot:ro \\\n  -v /lib/modules:/host/lib/modules:ro \\\n  -v /usr:/host/usr:ro \\\n  falcosecurity/falco:latest\n\n# 2. 容器行为监控\n# 监控文件系统变化\ndocker run -d \\\n  --name file-monitor \\\n  -v /var/lib/docker:/var/lib/docker:ro \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  monitoring-tool\n\n# 3. 日志安全分析\n# 集中化日志收集\ndocker run -d \\\n  --name log-collector \\\n  --log-driver=fluentd \\\n  --log-opt fluentd-address=localhost:24224 \\\n  --log-opt tag=\"docker.{{.Name}}\" \\\n  myapp:latest\n\n# 4. 资源使用监控\n# 监控容器资源使用\ndocker stats --format \"table {{.Container}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.NetIO}}\\t{{.BlockIO}}\"\n\n# 5. 安全事件告警\n# 使用 Prometheus + Grafana 监控\ndocker run -d \\\n  --name prometheus \\\n  -p 9090:9090 \\\n  -v prometheus.yml:/etc/prometheus/prometheus.yml \\\n  prom/prometheus\n\n# 6. 容器逃逸检测\n# 检测特权容器\ndocker ps --filter \"label=security.privileged=true\"\n\n# 7. 合规性检查\n# 使用 Docker Bench Security\ndocker run -it --net host --pid host --userns host --cap-add audit_control \\\n  -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \\\n  -v /var/lib:/var/lib:ro \\\n  -v /var/run/docker.sock:/var/run/docker.sock:ro \\\n  -v /usr/lib/systemd:/usr/lib/systemd:ro \\\n  -v /etc:/etc:ro --label docker_bench_security \\\n  docker/docker-bench-security"
    },
    "securityBestPractices": {
        "title": "安全最佳实践",
        "language": "dockerfile",
        "code": "# 安全的 Dockerfile 示例\nFROM node:18-alpine AS builder\n\n# 创建非 root 用户\nRUN addgroup -g 1001 -S nodejs && \\\n    adduser -S nextjs -u 1001\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制依赖文件\nCOPY package*.json ./\n\n# 安装依赖（仅生产依赖）\nRUN npm ci --only=production && npm cache clean --force\n\n# 复制应用代码\nCOPY --chown=nextjs:nodejs . .\n\n# 构建应用\nRUN npm run build\n\n# 生产阶段\nFROM node:18-alpine AS production\n\n# 安装 dumb-init 用于信号处理\nRUN apk add --no-cache dumb-init\n\n# 创建用户\nRUN addgroup -g 1001 -S nodejs && \\\n    adduser -S nextjs -u 1001\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制构建产物\nCOPY --from=builder --chown=nextjs:nodejs /app/dist ./dist\nCOPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules\nCOPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json\n\n# 切换到非 root 用户\nUSER nextjs\n\n# 暴露端口\nEXPOSE 3000\n\n# 健康检查\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1\n\n# 使用 dumb-init 启动应用\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"node\", \"dist/index.js\"]"
    },
    "complianceAndAuditing": {
        "title": "合规性和审计",
        "language": "bash",
        "code": "# 1. CIS Docker Benchmark 检查\n# 下载并运行 CIS 基准测试\nwget https://github.com/docker/docker-bench-security/archive/master.zip\nunzip master.zip\ncd docker-bench-security-master\nsudo sh docker-bench-security.sh\n\n# 2. 容器镜像合规性检查\n# 使用 Open Policy Agent (OPA) 进行策略检查\ndocker run -d --name opa \\\n  -p 8181:8181 \\\n  openpolicyagent/opa:latest \\\n  run --server --log-level debug\n\n# 3. 审计日志配置\n# 启用 Docker 守护进程审计\nsudo mkdir -p /etc/docker\necho '{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  },\n  \"audit-logs\": true\n}' | sudo tee /etc/docker/daemon.json\n\n# 4. 容器签名验证\n# 启用内容信任\nexport DOCKER_CONTENT_TRUST=1\nexport DOCKER_CONTENT_TRUST_SERVER=https://notary.example.com\n\n# 签名镜像\ndocker trust sign myregistry.com/myimage:latest\n\n# 5. RBAC 和访问控制\n# 创建 Docker 用户组\nsudo groupadd docker\nsudo usermod -aG docker $USER\n\n# 6. 安全扫描自动化\n# 在 CI/CD 中集成安全扫描\n# .gitlab-ci.yml 示例\n# security_scan:\n#   stage: security\n#   script:\n#     - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n#   only:\n#     - master\n\n# 7. 定期安全更新\n# 自动更新基础镜像\n#!/bin/bash\nfor image in $(docker images --format \"{{.Repository}}:{{.Tag}}\" | grep -v \"<none>\"); do\n  echo \"Updating $image\"\n  docker pull $image\ndone\n\n# 清理未使用的镜像\ndocker image prune -f"
    }
}
