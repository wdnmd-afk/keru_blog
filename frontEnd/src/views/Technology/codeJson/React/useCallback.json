{
    "basicUsage": {
        "title": "useCallback 基本用法",
        "language": "javascript",
        "code": "import React, { useState, useCallback } from 'react';\n\nconst ParentComponent = () => {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  // 使用 useCallback 缓存函数\n  const handleIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // 空依赖数组，函数永远不会重新创建\n\n  // 依赖于 name 的回调函数\n  const handleNameChange = useCallback((newName) => {\n    setName(newName);\n    console.log('Name changed to:', newName);\n  }, [name]); // 当 name 改变时，函数会重新创建\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Name: {name}</p>\n      <ChildComponent \n        onIncrement={handleIncrement}\n        onNameChange={handleNameChange}\n      />\n    </div>\n  );\n};\n\nconst ChildComponent = React.memo(({ onIncrement, onNameChange }) => {\n  console.log('ChildComponent rendered');\n  \n  return (\n    <div>\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={() => onNameChange('New Name')}>Change Name</button>\n    </div>\n  );\n});"
    },
    "withoutCallback": {
        "title": "不使用 useCallback 的问题",
        "language": "javascript",
        "code": "import React, { useState } from 'react';\n\n// ❌ 问题示例：没有使用 useCallback\nconst BadParentComponent = () => {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  // 每次渲染都会创建新的函数\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const handleNameChange = (newName) => {\n    setName(newName);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Name: {name}</p>\n      {/* 每次父组件重新渲染，子组件也会重新渲染 */}\n      <ExpensiveChildComponent \n        onIncrement={handleIncrement}\n        onNameChange={handleNameChange}\n      />\n    </div>\n  );\n};\n\nconst ExpensiveChildComponent = React.memo(({ onIncrement, onNameChange }) => {\n  console.log('ExpensiveChildComponent rendered'); // 会频繁打印\n  \n  // 模拟昂贵的计算\n  const expensiveValue = React.useMemo(() => {\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += i;\n    }\n    return result;\n  }, []);\n\n  return (\n    <div>\n      <p>Expensive calculation result: {expensiveValue}</p>\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={() => onNameChange('New Name')}>Change Name</button>\n    </div>\n  );\n});"
    },
    "dependencyArray": {
        "title": "依赖数组的使用",
        "language": "javascript",
        "code": "import React, { useState, useCallback, useEffect } from 'react';\n\nconst SearchComponent = () => {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  // 依赖于 query 的搜索函数\n  const handleSearch = useCallback(async () => {\n    if (!query.trim()) {\n      setResults([]);\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);\n      const data = await response.json();\n      setResults(data.results || []);\n    } catch (error) {\n      console.error('Search failed:', error);\n      setResults([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [query]); // 依赖于 query，当 query 改变时函数会重新创建\n\n  // 防抖搜索\n  const debouncedSearch = useCallback(() => {\n    const timeoutId = setTimeout(() => {\n      handleSearch();\n    }, 300);\n    \n    return () => clearTimeout(timeoutId);\n  }, [handleSearch]); // 依赖于 handleSearch\n\n  useEffect(() => {\n    const cleanup = debouncedSearch();\n    return cleanup;\n  }, [debouncedSearch]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n      <button onClick={handleSearch} disabled={loading}>\n        {loading ? '搜索中...' : '搜索'}\n      </button>\n      <SearchResults results={results} onItemClick={handleItemClick} />\n    </div>\n  );\n\n  // 处理搜索结果点击\n  const handleItemClick = useCallback((item) => {\n    console.log('Clicked item:', item);\n    // 这里可以添加导航逻辑\n  }, []); // 不依赖任何值\n};\n\nconst SearchResults = React.memo(({ results, onItemClick }) => {\n  return (\n    <ul>\n      {results.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item)}>\n          {item.title}\n        </li>\n      ))}\n    </ul>\n  );\n});"
    },
    "commonMistakes": {
        "title": "常见错误和最佳实践",
        "language": "javascript",
        "code": "import React, { useState, useCallback, useMemo } from 'react';\n\n// ❌ 错误1：忘记添加依赖\nconst BadExample1 = () => {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  const calculateValue = useCallback(() => {\n    return count * multiplier; // 使用了 count 和 multiplier\n  }, []); // ❌ 依赖数组为空，但函数内部使用了外部变量\n\n  return <div>{calculateValue()}</div>;\n};\n\n// ✅ 正确1：添加所有依赖\nconst GoodExample1 = () => {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  const calculateValue = useCallback(() => {\n    return count * multiplier;\n  }, [count, multiplier]); // ✅ 包含所有依赖\n\n  return <div>{calculateValue()}</div>;\n};\n\n// ❌ 错误2：过度使用 useCallback\nconst BadExample2 = () => {\n  const [name, setName] = useState('');\n\n  // ❌ 不必要的 useCallback，这个函数不会传递给子组件\n  const handleInputChange = useCallback((e) => {\n    setName(e.target.value);\n  }, []);\n\n  return (\n    <input \n      value={name} \n      onChange={handleInputChange} // 直接在这里使用，不需要缓存\n    />\n  );\n};\n\n// ✅ 正确2：只在必要时使用 useCallback\nconst GoodExample2 = () => {\n  const [name, setName] = useState('');\n  const [items, setItems] = useState([]);\n\n  // ✅ 传递给子组件的函数才需要缓存\n  const handleAddItem = useCallback((newItem) => {\n    setItems(prev => [...prev, newItem]);\n  }, []);\n\n  return (\n    <div>\n      <input \n        value={name} \n        onChange={(e) => setName(e.target.value)} // 直接使用内联函数\n      />\n      <ItemList items={items} onAddItem={handleAddItem} />\n    </div>\n  );\n};\n\n// ❌ 错误3：在依赖数组中包含对象或数组\nconst BadExample3 = () => {\n  const [config, setConfig] = useState({ theme: 'light', lang: 'en' });\n\n  const handleAction = useCallback(() => {\n    console.log('Config:', config);\n  }, [config]); // ❌ config 是对象，每次都会重新创建\n\n  return <button onClick={handleAction}>Action</button>;\n};\n\n// ✅ 正确3：解构对象属性或使用 useMemo\nconst GoodExample3 = () => {\n  const [config, setConfig] = useState({ theme: 'light', lang: 'en' });\n\n  const handleAction = useCallback(() => {\n    console.log('Config:', config);\n  }, [config.theme, config.lang]); // ✅ 只依赖具体的属性\n\n  // 或者使用 useMemo 缓存配置对象\n  const memoizedConfig = useMemo(() => config, [config.theme, config.lang]);\n  \n  const handleActionAlt = useCallback(() => {\n    console.log('Config:', memoizedConfig);\n  }, [memoizedConfig]);\n\n  return <button onClick={handleAction}>Action</button>;\n};"
    },
    "performanceOptimization": {
        "title": "性能优化实战",
        "language": "javascript",
        "code": "import React, { useState, useCallback, useMemo, memo } from 'react';\n\n// 大型列表组件的性能优化\nconst TodoApp = () => {\n  const [todos, setTodos] = useState([]);\n  const [filter, setFilter] = useState('all'); // 'all', 'active', 'completed'\n  const [newTodo, setNewTodo] = useState('');\n\n  // 添加待办事项\n  const addTodo = useCallback(() => {\n    if (newTodo.trim()) {\n      const todo = {\n        id: Date.now(),\n        text: newTodo.trim(),\n        completed: false,\n        createdAt: new Date().toISOString()\n      };\n      setTodos(prev => [...prev, todo]);\n      setNewTodo('');\n    }\n  }, [newTodo]);\n\n  // 切换待办事项状态\n  const toggleTodo = useCallback((id) => {\n    setTodos(prev => prev.map(todo => \n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ));\n  }, []);\n\n  // 删除待办事项\n  const deleteTodo = useCallback((id) => {\n    setTodos(prev => prev.filter(todo => todo.id !== id));\n  }, []);\n\n  // 批量操作\n  const toggleAll = useCallback(() => {\n    const allCompleted = todos.every(todo => todo.completed);\n    setTodos(prev => prev.map(todo => ({ \n      ...todo, \n      completed: !allCompleted \n    })));\n  }, [todos]);\n\n  const clearCompleted = useCallback(() => {\n    setTodos(prev => prev.filter(todo => !todo.completed));\n  }, []);\n\n  // 过滤待办事项\n  const filteredTodos = useMemo(() => {\n    switch (filter) {\n      case 'active':\n        return todos.filter(todo => !todo.completed);\n      case 'completed':\n        return todos.filter(todo => todo.completed);\n      default:\n        return todos;\n    }\n  }, [todos, filter]);\n\n  // 统计信息\n  const stats = useMemo(() => {\n    const total = todos.length;\n    const completed = todos.filter(todo => todo.completed).length;\n    const active = total - completed;\n    return { total, completed, active };\n  }, [todos]);\n\n  return (\n    <div className=\"todo-app\">\n      <header>\n        <h1>Todo App</h1>\n        <TodoInput \n          value={newTodo}\n          onChange={setNewTodo}\n          onSubmit={addTodo}\n        />\n      </header>\n      \n      <main>\n        <TodoStats stats={stats} />\n        <TodoFilters \n          currentFilter={filter}\n          onFilterChange={setFilter}\n        />\n        <TodoList \n          todos={filteredTodos}\n          onToggle={toggleTodo}\n          onDelete={deleteTodo}\n        />\n      </main>\n      \n      <footer>\n        <TodoActions \n          onToggleAll={toggleAll}\n          onClearCompleted={clearCompleted}\n          hasCompleted={stats.completed > 0}\n        />\n      </footer>\n    </div>\n  );\n};\n\n// 优化的子组件\nconst TodoInput = memo(({ value, onChange, onSubmit }) => {\n  const handleKeyPress = useCallback((e) => {\n    if (e.key === 'Enter') {\n      onSubmit();\n    }\n  }, [onSubmit]);\n\n  return (\n    <input\n      type=\"text\"\n      value={value}\n      onChange={(e) => onChange(e.target.value)}\n      onKeyPress={handleKeyPress}\n      placeholder=\"添加新的待办事项...\"\n    />\n  );\n});\n\nconst TodoItem = memo(({ todo, onToggle, onDelete }) => {\n  const handleToggle = useCallback(() => {\n    onToggle(todo.id);\n  }, [todo.id, onToggle]);\n\n  const handleDelete = useCallback(() => {\n    onDelete(todo.id);\n  }, [todo.id, onDelete]);\n\n  return (\n    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={handleToggle}\n      />\n      <span className=\"todo-text\">{todo.text}</span>\n      <button onClick={handleDelete} className=\"delete-btn\">\n        删除\n      </button>\n    </li>\n  );\n});\n\nconst TodoList = memo(({ todos, onToggle, onDelete }) => {\n  return (\n    <ul className=\"todo-list\">\n      {todos.map(todo => (\n        <TodoItem\n          key={todo.id}\n          todo={todo}\n          onToggle={onToggle}\n          onDelete={onDelete}\n        />\n      ))}\n    </ul>\n  );\n});"
    },
    "customHookExample": {
        "title": "在自定义Hook中使用useCallback",
        "language": "javascript",
        "code": "import { useState, useCallback, useEffect, useRef } from 'react';\n\n// 自定义Hook：useDebounce\nconst useDebounce = (callback, delay, deps = []) => {\n  const timeoutRef = useRef(null);\n\n  const debouncedCallback = useCallback((...args) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  }, [callback, delay, ...deps]);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n};\n\n// 自定义Hook：useAsync\nconst useAsync = (asyncFunction, immediate = true) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(immediate);\n  const [error, setError] = useState(null);\n\n  const execute = useCallback(async (...args) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await asyncFunction(...args);\n      setData(result);\n      return result;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [asyncFunction]);\n\n  useEffect(() => {\n    if (immediate) {\n      execute();\n    }\n  }, [execute, immediate]);\n\n  return { data, loading, error, execute };\n};\n\n// 自定义Hook：useLocalStorage\nconst useLocalStorage = (key, initialValue) => {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = useCallback((value) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  const removeValue = useCallback(() => {\n    try {\n      window.localStorage.removeItem(key);\n      setStoredValue(initialValue);\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  return [storedValue, setValue, removeValue];\n};\n\n// 使用自定义Hook的组件示例\nconst SearchApp = () => {\n  const [query, setQuery] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  \n  // 使用 useLocalStorage 保存搜索历史\n  const [searchHistory, setSearchHistory] = useLocalStorage('searchHistory', []);\n\n  // 搜索API函数\n  const searchAPI = useCallback(async (searchQuery) => {\n    const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);\n    if (!response.ok) {\n      throw new Error('Search failed');\n    }\n    return response.json();\n  }, []);\n\n  // 使用 useAsync 处理搜索请求\n  const { data, loading, error, execute: performSearch } = useAsync(searchAPI, false);\n\n  // 使用 useDebounce 防抖搜索\n  const debouncedSearch = useDebounce((searchQuery) => {\n    if (searchQuery.trim()) {\n      performSearch(searchQuery);\n      // 添加到搜索历史\n      setSearchHistory(prev => {\n        const newHistory = [searchQuery, ...prev.filter(item => item !== searchQuery)];\n        return newHistory.slice(0, 10); // 只保留最近10次搜索\n      });\n    }\n  }, 500, [performSearch, setSearchHistory]);\n\n  // 处理搜索输入\n  const handleSearchChange = useCallback((e) => {\n    const value = e.target.value;\n    setQuery(value);\n    debouncedSearch(value);\n  }, [debouncedSearch]);\n\n  // 处理历史搜索点击\n  const handleHistoryClick = useCallback((historyQuery) => {\n    setQuery(historyQuery);\n    performSearch(historyQuery);\n  }, [performSearch]);\n\n  useEffect(() => {\n    if (data) {\n      setSearchResults(data.results || []);\n    }\n  }, [data]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={query}\n        onChange={handleSearchChange}\n        placeholder=\"搜索...\"\n      />\n      \n      {loading && <div>搜索中...</div>}\n      {error && <div>搜索失败: {error.message}</div>}\n      \n      <div>\n        <h3>搜索结果</h3>\n        <ul>\n          {searchResults.map(result => (\n            <li key={result.id}>{result.title}</li>\n          ))}\n        </ul>\n      </div>\n      \n      <div>\n        <h3>搜索历史</h3>\n        <ul>\n          {searchHistory.map((item, index) => (\n            <li key={index}>\n              <button onClick={() => handleHistoryClick(item)}>\n                {item}\n              </button>\n            </li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n};"
    },
    "withReactMemo": {
        "title": "配合React.memo使用",
        "language": "javascript",
        "code": "// 子组件使用React.memo优化\nconst ChildComponent = React.memo(({ onClick, data }) => {\n  console.log('ChildComponent 渲染');\n  return (\n    <div>\n      <p>{data}</p>\n      <button onClick={onClick}>点击</button>\n    </div>\n  );\n});\n\nconst ParentComponent = () => {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  // ✅ 使用useCallback缓存函数\n  const handleClick = useCallback(() => {\n    console.log('按钮被点击');\n  }, []); // 空依赖，函数永远不变\n\n  return (\n    <div>\n      <input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n      <ChildComponent onClick={handleClick} data=\"固定数据\" />\n      <button onClick={() => setCount(count + 1)}>\n        Count: {count}\n      </button>\n    </div>\n  );\n};"
    }
}
