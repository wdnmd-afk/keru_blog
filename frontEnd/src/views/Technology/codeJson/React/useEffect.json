{
    "basicUsage": {
        "title": "useEffect 基本用法",
        "language": "javascript",
        "code": "import React, { useState, useEffect } from 'react';\n\nconst BasicEffectExample = () => {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  // 1. 无依赖数组 - 每次渲染后都执行\n  useEffect(() => {\n    console.log('组件渲染了');\n  });\n\n  // 2. 空依赖数组 - 只在组件挂载时执行一次\n  useEffect(() => {\n    console.log('组件挂载了');\n    document.title = '我的应用';\n  }, []);\n\n  // 3. 有依赖数组 - 只在依赖项改变时执行\n  useEffect(() => {\n    console.log('count 改变了:', count);\n    document.title = `计数: ${count}`;\n  }, [count]);\n\n  // 4. 多个依赖项\n  useEffect(() => {\n    console.log('count 或 name 改变了');\n    localStorage.setItem('userState', JSON.stringify({ count, name }));\n  }, [count, name]);\n\n  return (\n    <div>\n      <h2>useEffect 基本用法</h2>\n      <p>计数: {count}</p>\n      <button onClick={() => setCount(count + 1)}>增加计数</button>\n      \n      <div>\n        <input\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n          placeholder=\"输入姓名\"\n        />\n        <p>姓名: {name}</p>\n      </div>\n      \n      <small>打开控制台查看 useEffect 的执行</small>\n    </div>\n  );\n};"
    },
    "cleanup": {
        "title": "清理函数",
        "language": "javascript",
        "code": "import React, { useState, useEffect } from 'react';\n\nconst Timer = () => {\n  const [seconds, setSeconds] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n\n  useEffect(() => {\n    let intervalId;\n\n    if (isRunning) {\n      // 设置定时器\n      intervalId = setInterval(() => {\n        setSeconds(prevSeconds => prevSeconds + 1);\n      }, 1000);\n    }\n\n    // 清理函数 - 在组件卸载或依赖项改变前执行\n    return () => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        console.log('定时器已清理');\n      }\n    };\n  }, [isRunning]);\n\n  return (\n    <div>\n      <h3>定时器: {seconds}秒</h3>\n      <button onClick={() => setIsRunning(!isRunning)}>\n        {isRunning ? '暂停' : '开始'}\n      </button>\n      <button onClick={() => setSeconds(0)}>重置</button>\n    </div>\n  );\n};\n\n// 事件监听器清理示例\nconst WindowSizeTracker = () => {\n  const [windowSize, setWindowSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n\n    // 添加事件监听器\n    window.addEventListener('resize', handleResize);\n\n    // 清理函数 - 移除事件监听器\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      console.log('resize 事件监听器已移除');\n    };\n  }, []); // 空依赖数组，只在挂载和卸载时执行\n\n  return (\n    <div>\n      <h3>窗口大小</h3>\n      <p>宽度: {windowSize.width}px</p>\n      <p>高度: {windowSize.height}px</p>\n      <small>调整窗口大小试试</small>\n    </div>\n  );\n};\n\n// WebSocket 连接清理示例\nconst ChatComponent = ({ userId }) => {\n  const [messages, setMessages] = useState([]);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n\n  useEffect(() => {\n    if (!userId) return;\n\n    setConnectionStatus('connecting');\n    \n    // 创建 WebSocket 连接\n    const ws = new WebSocket(`ws://localhost:8080/chat/${userId}`);\n\n    ws.onopen = () => {\n      setConnectionStatus('connected');\n      console.log('WebSocket 连接已建立');\n    };\n\n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      setMessages(prev => [...prev, message]);\n    };\n\n    ws.onclose = () => {\n      setConnectionStatus('disconnected');\n      console.log('WebSocket 连接已关闭');\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket 错误:', error);\n      setConnectionStatus('error');\n    };\n\n    // 清理函数 - 关闭 WebSocket 连接\n    return () => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    };\n  }, [userId]);\n\n  return (\n    <div>\n      <h3>聊天室</h3>\n      <p>连接状态: {connectionStatus}</p>\n      <div>\n        {messages.map((msg, index) => (\n          <div key={index}>{msg.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\n// 组合示例\nconst CleanupExample = () => {\n  const [showTimer, setShowTimer] = useState(false);\n  const [showSizeTracker, setShowSizeTracker] = useState(false);\n\n  return (\n    <div>\n      <h2>清理函数示例</h2>\n      \n      <div>\n        <button onClick={() => setShowTimer(!showTimer)}>\n          {showTimer ? '隐藏' : '显示'}定时器\n        </button>\n        {showTimer && <Timer />}\n      </div>\n      \n      <div>\n        <button onClick={() => setShowSizeTracker(!showSizeTracker)}>\n          {showSizeTracker ? '隐藏' : '显示'}窗口大小追踪器\n        </button>\n        {showSizeTracker && <WindowSizeTracker />}\n      </div>\n    </div>\n  );\n};"
    },
    "dataFetching": {
        "title": "数据获取",
        "language": "javascript",
        "code": "import React, { useState, useEffect } from 'react';\n\n// 基本的数据获取\nconst UserProfile = ({ userId }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // 如果没有 userId，不执行请求\n    if (!userId) {\n      setUser(null);\n      setLoading(false);\n      return;\n    }\n\n    const fetchUser = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(`/api/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const userData = await response.json();\n        setUser(userData);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n  }, [userId]); // 当 userId 改变时重新获取数据\n\n  if (loading) return <div>加载中...</div>;\n  if (error) return <div>错误: {error}</div>;\n  if (!user) return <div>请选择用户</div>;\n\n  return (\n    <div>\n      <h3>{user.name}</h3>\n      <p>邮箱: {user.email}</p>\n      <p>电话: {user.phone}</p>\n    </div>\n  );\n};\n\n// 带取消功能的数据获取\nconst SearchResults = ({ query }) => {\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!query.trim()) {\n      setResults([]);\n      return;\n    }\n\n    const abortController = new AbortController();\n    \n    const searchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(\n          `/api/search?q=${encodeURIComponent(query)}`,\n          { signal: abortController.signal }\n        );\n        \n        if (!response.ok) {\n          throw new Error('搜索失败');\n        }\n        \n        const data = await response.json();\n        setResults(data.results || []);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // 防抖：延迟执行搜索\n    const timeoutId = setTimeout(() => {\n      searchData();\n    }, 300);\n\n    // 清理函数：取消请求和清除定时器\n    return () => {\n      clearTimeout(timeoutId);\n      abortController.abort();\n    };\n  }, [query]);\n\n  return (\n    <div>\n      {loading && <div>搜索中...</div>}\n      {error && <div>错误: {error}</div>}\n      <ul>\n        {results.map(result => (\n          <li key={result.id}>{result.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n// 自定义Hook：useFetch\nconst useFetch = (url, options = {}) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!url) return;\n\n    const abortController = new AbortController();\n    \n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(url, {\n          ...options,\n          signal: abortController.signal\n        });\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      abortController.abort();\n    };\n  }, [url, JSON.stringify(options)]);\n\n  return { data, loading, error };\n};\n\n// 使用自定义Hook\nconst PostList = () => {\n  const { data: posts, loading, error } = useFetch('/api/posts');\n\n  if (loading) return <div>加载文章中...</div>;\n  if (error) return <div>加载失败: {error}</div>;\n\n  return (\n    <div>\n      <h3>文章列表</h3>\n      {posts?.map(post => (\n        <div key={post.id}>\n          <h4>{post.title}</h4>\n          <p>{post.excerpt}</p>\n        </div>\n      ))}\n    </div>\n  );\n};\n\n// 组合示例\nconst DataFetchingExample = () => {\n  const [selectedUserId, setSelectedUserId] = useState('');\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div>\n      <h2>数据获取示例</h2>\n      \n      <div>\n        <h3>用户资料</h3>\n        <select \n          value={selectedUserId} \n          onChange={(e) => setSelectedUserId(e.target.value)}\n        >\n          <option value=\"\">选择用户</option>\n          <option value=\"1\">用户 1</option>\n          <option value=\"2\">用户 2</option>\n          <option value=\"3\">用户 3</option>\n        </select>\n        <UserProfile userId={selectedUserId} />\n      </div>\n      \n      <div>\n        <h3>搜索</h3>\n        <input\n          type=\"text\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n          placeholder=\"输入搜索关键词\"\n        />\n        <SearchResults query={searchQuery} />\n      </div>\n      \n      <div>\n        <PostList />\n      </div>\n    </div>\n  );\n};"
    },
    "commonMistakes": {
        "title": "常见错误和最佳实践",
        "language": "javascript",
        "code": "import React, { useState, useEffect, useCallback } from 'react';\n\n// ❌ 错误1: 忘记依赖数组\nconst BadExample1 = () => {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  useEffect(() => {\n    const result = count * multiplier;\n    console.log('Result:', result);\n    // ❌ 缺少依赖数组，每次渲染都会执行\n  });\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\n// ✅ 正确1: 添加正确的依赖数组\nconst GoodExample1 = () => {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  useEffect(() => {\n    const result = count * multiplier;\n    console.log('Result:', result);\n  }, [count, multiplier]); // ✅ 包含所有依赖\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\n// ❌ 错误2: 在 useEffect 中直接调用 setState\nconst BadExample2 = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // ❌ 这会导致无限循环\n    setCount(count + 1);\n  }, [count]);\n\n  return <div>Count: {count}</div>;\n};\n\n// ✅ 正确2: 使用条件或移除依赖\nconst GoodExample2 = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // ✅ 添加条件避免无限循环\n    if (count < 10) {\n      const timer = setTimeout(() => {\n        setCount(count + 1);\n      }, 1000);\n      return () => clearTimeout(timer);\n    }\n  }, [count]);\n\n  return <div>Count: {count}</div>;\n};\n\n// ❌ 错误3: 忘记清理副作用\nconst BadExample3 = () => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      fetch('/api/data')\n        .then(res => res.json())\n        .then(setData);\n    }, 1000);\n    \n    // ❌ 忘记清理定时器\n  }, []);\n\n  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;\n};\n\n// ✅ 正确3: 添加清理函数\nconst GoodExample3 = () => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      fetch('/api/data')\n        .then(res => res.json())\n        .then(setData);\n    }, 1000);\n    \n    // ✅ 清理定时器\n    return () => clearInterval(interval);\n  }, []);\n\n  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;\n};\n\n// ❌ 错误4: 在依赖数组中使用对象或数组\nconst BadExample4 = () => {\n  const [user, setUser] = useState({ id: 1, name: 'John' });\n  const [posts, setPosts] = useState([]);\n\n  useEffect(() => {\n    fetchUserPosts(user).then(setPosts);\n  }, [user]); // ❌ user 是对象，每次都会重新创建\n\n  return <div>Posts: {posts.length}</div>;\n};\n\n// ✅ 正确4: 只依赖对象的特定属性\nconst GoodExample4 = () => {\n  const [user, setUser] = useState({ id: 1, name: 'John' });\n  const [posts, setPosts] = useState([]);\n\n  useEffect(() => {\n    fetchUserPosts(user).then(setPosts);\n  }, [user.id]); // ✅ 只依赖 user.id\n\n  return <div>Posts: {posts.length}</div>;\n};\n\n// ❌ 错误5: 异步函数作为 useEffect 的回调\nconst BadExample5 = () => {\n  const [data, setData] = useState(null);\n\n  // ❌ useEffect 的回调不能是 async 函数\n  useEffect(async () => {\n    const response = await fetch('/api/data');\n    const result = await response.json();\n    setData(result);\n  }, []);\n\n  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;\n};\n\n// ✅ 正确5: 在 useEffect 内部定义异步函数\nconst GoodExample5 = () => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // ✅ 在内部定义异步函数\n    const fetchData = async () => {\n      try {\n        const response = await fetch('/api/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Fetch error:', error);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;\n};\n\n// ❌ 错误6: 过度使用 useEffect\nconst BadExample6 = () => {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [fullName, setFullName] = useState('');\n\n  // ❌ 不必要的 useEffect\n  useEffect(() => {\n    setFullName(`${firstName} ${lastName}`);\n  }, [firstName, lastName]);\n\n  return (\n    <div>\n      <input value={firstName} onChange={(e) => setFirstName(e.target.value)} />\n      <input value={lastName} onChange={(e) => setLastName(e.target.value)} />\n      <p>Full Name: {fullName}</p>\n    </div>\n  );\n};\n\n// ✅ 正确6: 使用计算值\nconst GoodExample6 = () => {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n\n  // ✅ 直接计算，不需要额外的状态和 useEffect\n  const fullName = `${firstName} ${lastName}`.trim();\n\n  return (\n    <div>\n      <input value={firstName} onChange={(e) => setFirstName(e.target.value)} />\n      <input value={lastName} onChange={(e) => setLastName(e.target.value)} />\n      <p>Full Name: {fullName}</p>\n    </div>\n  );\n};\n\n// 最佳实践：自定义Hook封装复杂逻辑\nconst useAsyncData = (url) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!url) return;\n\n    const abortController = new AbortController();\n    \n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        const response = await fetch(url, {\n          signal: abortController.signal\n        });\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      abortController.abort();\n    };\n  }, [url]);\n\n  return { data, loading, error };\n};\n\n// 模拟 API 函数\nconst fetchUserPosts = async (user) => {\n  const response = await fetch(`/api/users/${user.id}/posts`);\n  return response.json();\n};"
    }
}
