{
    "basicUsage": {
        "title": "useState 基本用法",
        "language": "javascript",
        "code": "import React, { useState } from 'react';\n\nconst Counter = () => {\n  // 声明一个状态变量 count，初始值为 0\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>当前计数: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        增加\n      </button>\n      <button onClick={() => setCount(count - 1)}>\n        减少\n      </button>\n      <button onClick={() => setCount(0)}>\n        重置\n      </button>\n    </div>\n  );\n};\n\n// 多个状态变量\nconst UserForm = () => {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [age, setAge] = useState(0);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log({ name, email, age });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"姓名\"\n      />\n      <input\n        type=\"email\"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        placeholder=\"邮箱\"\n      />\n      <input\n        type=\"number\"\n        value={age}\n        onChange={(e) => setAge(parseInt(e.target.value))}\n        placeholder=\"年龄\"\n      />\n      <button type=\"submit\">提交</button>\n    </form>\n  );\n};"
    },
    "functionalUpdates": {
        "title": "函数式更新",
        "language": "javascript",
        "code": "import React, { useState } from 'react';\n\nconst FunctionalUpdateExample = () => {\n  const [count, setCount] = useState(0);\n\n  // ❌ 可能出现问题的写法\n  const handleBadIncrement = () => {\n    setCount(count + 1);\n    setCount(count + 1); // 这里 count 还是旧值，所以只会增加 1\n  };\n\n  // ✅ 正确的函数式更新写法\n  const handleGoodIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1); // 这里会正确增加 2\n  };\n\n  // 复杂的状态更新\n  const [todos, setTodos] = useState([]);\n\n  const addTodo = (text) => {\n    setTodos(prevTodos => [\n      ...prevTodos,\n      {\n        id: Date.now(),\n        text,\n        completed: false\n      }\n    ]);\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id\n          ? { ...todo, completed: !todo.completed }\n          : todo\n      )\n    );\n  };\n\n  const deleteTodo = (id) => {\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div>\n      <div>\n        <p>计数: {count}</p>\n        <button onClick={handleBadIncrement}>错误的增加2</button>\n        <button onClick={handleGoodIncrement}>正确的增加2</button>\n        <button onClick={() => setCount(0)}>重置</button>\n      </div>\n\n      <div>\n        <h3>待办事项</h3>\n        <button onClick={() => addTodo(`任务 ${todos.length + 1}`)}>\n          添加任务\n        </button>\n        <ul>\n          {todos.map(todo => (\n            <li key={todo.id}>\n              <span\n                style={{\n                  textDecoration: todo.completed ? 'line-through' : 'none'\n                }}\n                onClick={() => toggleTodo(todo.id)}\n              >\n                {todo.text}\n              </span>\n              <button onClick={() => deleteTodo(todo.id)}>删除</button>\n            </li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n};"
    },
    "objectState": {
        "title": "对象状态管理",
        "language": "javascript",
        "code": "import React, { useState } from 'react';\n\nconst UserProfile = () => {\n  // 使用对象作为状态\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    age: 0,\n    preferences: {\n      theme: 'light',\n      language: 'zh-CN',\n      notifications: true\n    }\n  });\n\n  // ❌ 错误的更新方式 - 会覆盖整个对象\n  const handleBadUpdate = (field, value) => {\n    setUser({ [field]: value }); // 这会丢失其他字段\n  };\n\n  // ✅ 正确的更新方式 - 使用展开运算符\n  const handleUpdate = (field, value) => {\n    setUser(prevUser => ({\n      ...prevUser,\n      [field]: value\n    }));\n  };\n\n  // 更新嵌套对象\n  const handlePreferenceUpdate = (preference, value) => {\n    setUser(prevUser => ({\n      ...prevUser,\n      preferences: {\n        ...prevUser.preferences,\n        [preference]: value\n      }\n    }));\n  };\n\n  // 使用 useReducer 的替代方案（对于复杂状态）\n  const handleComplexUpdate = (updates) => {\n    setUser(prevUser => {\n      const newUser = { ...prevUser };\n      \n      Object.keys(updates).forEach(key => {\n        if (typeof updates[key] === 'object' && updates[key] !== null) {\n          newUser[key] = { ...newUser[key], ...updates[key] };\n        } else {\n          newUser[key] = updates[key];\n        }\n      });\n      \n      return newUser;\n    });\n  };\n\n  return (\n    <div>\n      <h2>用户资料</h2>\n      \n      <div>\n        <label>\n          姓名:\n          <input\n            type=\"text\"\n            value={user.name}\n            onChange={(e) => handleUpdate('name', e.target.value)}\n          />\n        </label>\n      </div>\n      \n      <div>\n        <label>\n          邮箱:\n          <input\n            type=\"email\"\n            value={user.email}\n            onChange={(e) => handleUpdate('email', e.target.value)}\n          />\n        </label>\n      </div>\n      \n      <div>\n        <label>\n          年龄:\n          <input\n            type=\"number\"\n            value={user.age}\n            onChange={(e) => handleUpdate('age', parseInt(e.target.value))}\n          />\n        </label>\n      </div>\n      \n      <h3>偏好设置</h3>\n      \n      <div>\n        <label>\n          主题:\n          <select\n            value={user.preferences.theme}\n            onChange={(e) => handlePreferenceUpdate('theme', e.target.value)}\n          >\n            <option value=\"light\">浅色</option>\n            <option value=\"dark\">深色</option>\n          </select>\n        </label>\n      </div>\n      \n      <div>\n        <label>\n          语言:\n          <select\n            value={user.preferences.language}\n            onChange={(e) => handlePreferenceUpdate('language', e.target.value)}\n          >\n            <option value=\"zh-CN\">中文</option>\n            <option value=\"en-US\">English</option>\n          </select>\n        </label>\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={user.preferences.notifications}\n            onChange={(e) => handlePreferenceUpdate('notifications', e.target.checked)}\n          />\n          接收通知\n        </label>\n      </div>\n      \n      <div>\n        <h3>当前状态:</h3>\n        <pre>{JSON.stringify(user, null, 2)}</pre>\n      </div>\n      \n      <button\n        onClick={() => handleComplexUpdate({\n          name: '张三',\n          email: 'zhangsan@example.com',\n          preferences: { theme: 'dark' }\n        })}\n      >\n        批量更新\n      </button>\n    </div>\n  );\n};"
    },
    "lazyInitialization": {
        "title": "惰性初始化",
        "language": "javascript",
        "code": "import React, { useState } from 'react';\n\n// 昂贵的计算函数\nconst expensiveCalculation = () => {\n  console.log('执行昂贵的计算...');\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += Math.random();\n  }\n  return result;\n};\n\n// 从 localStorage 读取数据\nconst getStoredValue = (key, defaultValue) => {\n  console.log('从 localStorage 读取数据...');\n  try {\n    const item = window.localStorage.getItem(key);\n    return item ? JSON.parse(item) : defaultValue;\n  } catch (error) {\n    console.error('读取 localStorage 失败:', error);\n    return defaultValue;\n  }\n};\n\nconst LazyInitializationExample = () => {\n  // ❌ 每次渲染都会执行昂贵的计算\n  const [badValue] = useState(expensiveCalculation());\n  \n  // ✅ 只在初始化时执行一次\n  const [goodValue] = useState(() => expensiveCalculation());\n  \n  // ✅ 惰性读取 localStorage\n  const [settings, setSettings] = useState(() => \n    getStoredValue('userSettings', {\n      theme: 'light',\n      language: 'zh-CN'\n    })\n  );\n  \n  // ✅ 复杂的初始状态计算\n  const [gameState, setGameState] = useState(() => {\n    console.log('初始化游戏状态...');\n    return {\n      level: 1,\n      score: 0,\n      lives: 3,\n      powerUps: [],\n      enemies: Array.from({ length: 5 }, (_, i) => ({\n        id: i,\n        x: Math.random() * 800,\n        y: Math.random() * 600,\n        health: 100\n      }))\n    };\n  });\n  \n  // 更新设置并保存到 localStorage\n  const updateSettings = (newSettings) => {\n    setSettings(prevSettings => {\n      const updated = { ...prevSettings, ...newSettings };\n      localStorage.setItem('userSettings', JSON.stringify(updated));\n      return updated;\n    });\n  };\n  \n  // 重置游戏状态\n  const resetGame = () => {\n    setGameState(() => ({\n      level: 1,\n      score: 0,\n      lives: 3,\n      powerUps: [],\n      enemies: Array.from({ length: 5 }, (_, i) => ({\n        id: i,\n        x: Math.random() * 800,\n        y: Math.random() * 600,\n        health: 100\n      }))\n    }));\n  };\n  \n  return (\n    <div>\n      <h2>惰性初始化示例</h2>\n      \n      <div>\n        <h3>计算结果</h3>\n        <p>错误方式的值: {badValue.toFixed(2)}</p>\n        <p>正确方式的值: {goodValue.toFixed(2)}</p>\n        <small>查看控制台，注意计算执行的次数</small>\n      </div>\n      \n      <div>\n        <h3>用户设置</h3>\n        <label>\n          主题:\n          <select\n            value={settings.theme}\n            onChange={(e) => updateSettings({ theme: e.target.value })}\n          >\n            <option value=\"light\">浅色</option>\n            <option value=\"dark\">深色</option>\n          </select>\n        </label>\n        \n        <label>\n          语言:\n          <select\n            value={settings.language}\n            onChange={(e) => updateSettings({ language: e.target.value })}\n          >\n            <option value=\"zh-CN\">中文</option>\n            <option value=\"en-US\">English</option>\n          </select>\n        </label>\n      </div>\n      \n      <div>\n        <h3>游戏状态</h3>\n        <p>等级: {gameState.level}</p>\n        <p>分数: {gameState.score}</p>\n        <p>生命: {gameState.lives}</p>\n        <p>敌人数量: {gameState.enemies.length}</p>\n        \n        <button onClick={resetGame}>重置游戏</button>\n        \n        <button\n          onClick={() => setGameState(prev => ({\n            ...prev,\n            score: prev.score + 100\n          }))}\n        >\n          增加分数\n        </button>\n      </div>\n    </div>\n  );\n};\n\n// 自定义Hook示例：惰性初始化的 localStorage Hook\nconst useLocalStorage = (key, initialValue) => {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n  \n  const setValue = (value) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  };\n  \n  return [storedValue, setValue];\n};\n\n// 使用自定义Hook\nconst LocalStorageExample = () => {\n  const [name, setName] = useLocalStorage('userName', '');\n  const [count, setCount] = useLocalStorage('userCount', 0);\n  \n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"输入姓名\"\n      />\n      <p>计数: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>增加</button>\n      <button onClick={() => setCount(0)}>重置</button>\n    </div>\n  );\n};"
    },
    "commonMistakes": {
        "title": "常见错误和最佳实践",
        "language": "javascript",
        "code": "import React, { useState, useEffect } from 'react';\n\n// ❌ 错误1: 直接修改状态\nconst BadExample1 = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n  \n  const addItem = () => {\n    items.push(4); // ❌ 直接修改数组\n    setItems(items); // React 不会重新渲染\n  };\n  \n  return (\n    <div>\n      {items.map(item => <div key={item}>{item}</div>)}\n      <button onClick={addItem}>添加项目</button>\n    </div>\n  );\n};\n\n// ✅ 正确1: 创建新的状态\nconst GoodExample1 = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n  \n  const addItem = () => {\n    setItems(prevItems => [...prevItems, prevItems.length + 1]);\n  };\n  \n  return (\n    <div>\n      {items.map(item => <div key={item}>{item}</div>)}\n      <button onClick={addItem}>添加项目</button>\n    </div>\n  );\n};\n\n// ❌ 错误2: 在渲染过程中调用 setState\nconst BadExample2 = () => {\n  const [count, setCount] = useState(0);\n  \n  // ❌ 这会导致无限循环\n  if (count < 10) {\n    setCount(count + 1);\n  }\n  \n  return <div>Count: {count}</div>;\n};\n\n// ✅ 正确2: 在 useEffect 中调用 setState\nconst GoodExample2 = () => {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    if (count < 10) {\n      const timer = setTimeout(() => {\n        setCount(count + 1);\n      }, 1000);\n      return () => clearTimeout(timer);\n    }\n  }, [count]);\n  \n  return <div>Count: {count}</div>;\n};\n\n// ❌ 错误3: 依赖旧的状态值\nconst BadExample3 = () => {\n  const [count, setCount] = useState(0);\n  \n  const handleMultipleUpdates = () => {\n    setCount(count + 1); // 基于当前的 count\n    setCount(count + 1); // 还是基于当前的 count，不是更新后的值\n    setCount(count + 1); // 同样基于当前的 count\n    // 结果只会增加 1，而不是 3\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleMultipleUpdates}>增加3</button>\n    </div>\n  );\n};\n\n// ✅ 正确3: 使用函数式更新\nconst GoodExample3 = () => {\n  const [count, setCount] = useState(0);\n  \n  const handleMultipleUpdates = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    // 正确增加 3\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleMultipleUpdates}>增加3</button>\n    </div>\n  );\n};\n\n// ❌ 错误4: 不必要的状态\nconst BadExample4 = () => {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [fullName, setFullName] = useState(''); // ❌ 不必要的状态\n  \n  const handleFirstNameChange = (e) => {\n    setFirstName(e.target.value);\n    setFullName(e.target.value + ' ' + lastName); // 手动同步\n  };\n  \n  const handleLastNameChange = (e) => {\n    setLastName(e.target.value);\n    setFullName(firstName + ' ' + e.target.value); // 手动同步\n  };\n  \n  return (\n    <div>\n      <input value={firstName} onChange={handleFirstNameChange} />\n      <input value={lastName} onChange={handleLastNameChange} />\n      <p>Full Name: {fullName}</p>\n    </div>\n  );\n};\n\n// ✅ 正确4: 计算派生状态\nconst GoodExample4 = () => {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  \n  // 派生状态，不需要额外的 useState\n  const fullName = `${firstName} ${lastName}`.trim();\n  \n  return (\n    <div>\n      <input \n        value={firstName} \n        onChange={(e) => setFirstName(e.target.value)} \n        placeholder=\"名\"\n      />\n      <input \n        value={lastName} \n        onChange={(e) => setLastName(e.target.value)} \n        placeholder=\"姓\"\n      />\n      <p>Full Name: {fullName}</p>\n    </div>\n  );\n};\n\n// ❌ 错误5: 复杂状态管理用 useState\nconst BadExample5 = () => {\n  const [user, setUser] = useState({ name: '', email: '' });\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(false);\n  \n  const handleSubmit = async () => {\n    setLoading(true);\n    setError(null);\n    setSuccess(false);\n    \n    try {\n      await submitUser(user);\n      setSuccess(true);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  // 多个相关状态难以管理\n};\n\n// ✅ 正确5: 复杂状态用 useReducer\nconst formReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, loading: true, error: null, success: false };\n    case 'SET_SUCCESS':\n      return { ...state, loading: false, success: true, error: null };\n    case 'SET_ERROR':\n      return { ...state, loading: false, error: action.payload, success: false };\n    case 'UPDATE_USER':\n      return { ...state, user: { ...state.user, ...action.payload } };\n    case 'RESET':\n      return { user: { name: '', email: '' }, loading: false, error: null, success: false };\n    default:\n      return state;\n  }\n};\n\nconst GoodExample5 = () => {\n  const [state, dispatch] = useReducer(formReducer, {\n    user: { name: '', email: '' },\n    loading: false,\n    error: null,\n    success: false\n  });\n  \n  const handleSubmit = async () => {\n    dispatch({ type: 'SET_LOADING' });\n    \n    try {\n      await submitUser(state.user);\n      dispatch({ type: 'SET_SUCCESS' });\n    } catch (err) {\n      dispatch({ type: 'SET_ERROR', payload: err.message });\n    }\n  };\n  \n  // 状态管理更清晰\n};\n\n// 模拟 API 调用\nconst submitUser = async (user) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (user.name && user.email) {\n        resolve({ success: true });\n      } else {\n        reject(new Error('姓名和邮箱都是必填的'));\n      }\n    }, 1000);\n  });\n};"
    }
}
