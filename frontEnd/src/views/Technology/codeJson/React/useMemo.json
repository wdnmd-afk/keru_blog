{
    "basicUsage": {
        "title": "useMemo 基本用法",
        "language": "javascript",
        "code": "import React, { useState, useMemo } from 'react';\n\nconst ExpensiveCalculationComponent = () => {\n  const [count, setCount] = useState(0);\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n\n  // 昂贵的计算函数\n  const expensiveCalculation = (num) => {\n    console.log('执行昂贵的计算...');\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += num * i;\n    }\n    return result;\n  };\n\n  // ❌ 没有使用 useMemo - 每次渲染都会重新计算\n  const expensiveValue1 = expensiveCalculation(count);\n\n  // ✅ 使用 useMemo - 只有当 count 改变时才重新计算\n  const expensiveValue2 = useMemo(() => {\n    return expensiveCalculation(count);\n  }, [count]);\n\n  // 计算数组的总和\n  const sum = useMemo(() => {\n    console.log('计算数组总和...');\n    return items.reduce((acc, item) => acc + item, 0);\n  }, [items]);\n\n  // 过滤偶数\n  const evenNumbers = useMemo(() => {\n    console.log('过滤偶数...');\n    return items.filter(item => item % 2 === 0);\n  }, [items]);\n\n  return (\n    <div>\n      <h3>useMemo 示例</h3>\n      \n      <div>\n        <p>计数: {count}</p>\n        <button onClick={() => setCount(count + 1)}>增加计数</button>\n        <button onClick={() => setCount(0)}>重置</button>\n      </div>\n      \n      <div>\n        <p>昂贵计算结果 (无缓存): {expensiveValue1}</p>\n        <p>昂贵计算结果 (有缓存): {expensiveValue2}</p>\n      </div>\n      \n      <div>\n        <p>数组: [{items.join(', ')}]</p>\n        <p>数组总和: {sum}</p>\n        <p>偶数: [{evenNumbers.join(', ')}]</p>\n        <button \n          onClick={() => setItems([...items, items.length + 1])}\n        >\n          添加项目\n        </button>\n      </div>\n      \n      <small>打开控制台查看计算执行情况</small>\n    </div>\n  );\n};"
    },
    "objectMemoization": {
        "title": "对象和数组的记忆化",
        "language": "javascript",
        "code": "import React, { useState, useMemo, useCallback } from 'react';\n\nconst UserList = ({ users, searchTerm, sortBy }) => {\n  // 过滤用户\n  const filteredUsers = useMemo(() => {\n    console.log('过滤用户...');\n    if (!searchTerm) return users;\n    \n    return users.filter(user => \n      user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      user.email.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [users, searchTerm]);\n\n  // 排序用户\n  const sortedUsers = useMemo(() => {\n    console.log('排序用户...');\n    const sorted = [...filteredUsers];\n    \n    return sorted.sort((a, b) => {\n      switch (sortBy) {\n        case 'name':\n          return a.name.localeCompare(b.name);\n        case 'email':\n          return a.email.localeCompare(b.email);\n        case 'age':\n          return a.age - b.age;\n        default:\n          return 0;\n      }\n    });\n  }, [filteredUsers, sortBy]);\n\n  // 用户统计信息\n  const userStats = useMemo(() => {\n    console.log('计算用户统计...');\n    return {\n      total: sortedUsers.length,\n      averageAge: sortedUsers.reduce((sum, user) => sum + user.age, 0) / sortedUsers.length || 0,\n      domains: [...new Set(sortedUsers.map(user => user.email.split('@')[1]))]\n    };\n  }, [sortedUsers]);\n\n  return (\n    <div>\n      <div>\n        <h4>用户统计</h4>\n        <p>总用户数: {userStats.total}</p>\n        <p>平均年龄: {userStats.averageAge.toFixed(1)}</p>\n        <p>邮箱域名: {userStats.domains.join(', ')}</p>\n      </div>\n      \n      <div>\n        <h4>用户列表</h4>\n        {sortedUsers.map(user => (\n          <div key={user.id} style={{ padding: '8px', border: '1px solid #ccc', margin: '4px' }}>\n            <strong>{user.name}</strong> ({user.age}岁)\n            <br />\n            <small>{user.email}</small>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nconst UserManagement = () => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [sortBy, setSortBy] = useState('name');\n  \n  // 模拟用户数据\n  const users = useMemo(() => [\n    { id: 1, name: '张三', age: 25, email: 'zhangsan@example.com' },\n    { id: 2, name: '李四', age: 30, email: 'lisi@gmail.com' },\n    { id: 3, name: '王五', age: 28, email: 'wangwu@example.com' },\n    { id: 4, name: '赵六', age: 35, email: 'zhaoliu@outlook.com' },\n    { id: 5, name: '钱七', age: 22, email: 'qianqi@example.com' }\n  ], []);\n\n  return (\n    <div>\n      <h3>用户管理系统</h3>\n      \n      <div style={{ marginBottom: '16px' }}>\n        <input\n          type=\"text\"\n          value={searchTerm}\n          onChange={(e) => setSearchTerm(e.target.value)}\n          placeholder=\"搜索用户...\"\n          style={{ marginRight: '8px', padding: '4px' }}\n        />\n        \n        <select \n          value={sortBy} \n          onChange={(e) => setSortBy(e.target.value)}\n          style={{ padding: '4px' }}\n        >\n          <option value=\"name\">按姓名排序</option>\n          <option value=\"age\">按年龄排序</option>\n          <option value=\"email\">按邮箱排序</option>\n        </select>\n      </div>\n      \n      <UserList \n        users={users}\n        searchTerm={searchTerm}\n        sortBy={sortBy}\n      />\n    </div>\n  );\n};"
    },
    "performanceOptimization": {
        "title": "性能优化实战",
        "language": "javascript",
        "code": "import React, { useState, useMemo, useCallback, memo } from 'react';\n\n// 昂贵的数据处理函数\nconst processLargeDataset = (data, filters) => {\n  console.log('处理大型数据集...');\n  \n  let result = data;\n  \n  // 应用过滤器\n  if (filters.category) {\n    result = result.filter(item => item.category === filters.category);\n  }\n  \n  if (filters.minPrice) {\n    result = result.filter(item => item.price >= filters.minPrice);\n  }\n  \n  if (filters.maxPrice) {\n    result = result.filter(item => item.price <= filters.maxPrice);\n  }\n  \n  if (filters.searchTerm) {\n    result = result.filter(item => \n      item.name.toLowerCase().includes(filters.searchTerm.toLowerCase())\n    );\n  }\n  \n  // 排序\n  result.sort((a, b) => {\n    switch (filters.sortBy) {\n      case 'price':\n        return filters.sortOrder === 'asc' ? a.price - b.price : b.price - a.price;\n      case 'name':\n        return filters.sortOrder === 'asc' \n          ? a.name.localeCompare(b.name)\n          : b.name.localeCompare(a.name);\n      default:\n        return 0;\n    }\n  });\n  \n  return result;\n};\n\n// 商品卡片组件\nconst ProductCard = memo(({ product, onAddToCart }) => {\n  console.log(`渲染商品卡片: ${product.name}`);\n  \n  return (\n    <div style={{ \n      border: '1px solid #ddd', \n      padding: '16px', \n      margin: '8px',\n      borderRadius: '8px'\n    }}>\n      <h4>{product.name}</h4>\n      <p>分类: {product.category}</p>\n      <p>价格: ¥{product.price}</p>\n      <p>库存: {product.stock}</p>\n      <button \n        onClick={() => onAddToCart(product)}\n        disabled={product.stock === 0}\n      >\n        {product.stock > 0 ? '加入购物车' : '缺货'}\n      </button>\n    </div>\n  );\n});\n\n// 主要的商品列表组件\nconst ProductList = () => {\n  const [filters, setFilters] = useState({\n    category: '',\n    minPrice: '',\n    maxPrice: '',\n    searchTerm: '',\n    sortBy: 'name',\n    sortOrder: 'asc'\n  });\n  \n  const [cart, setCart] = useState([]);\n  \n  // 模拟大型商品数据集\n  const products = useMemo(() => {\n    const categories = ['电子产品', '服装', '书籍', '家居', '运动'];\n    const productNames = [\n      'iPhone', 'MacBook', 'iPad', '耳机', '键盘',\n      'T恤', '牛仔裤', '运动鞋', '外套', '帽子',\n      'JavaScript指南', 'React教程', 'Node.js实战', 'CSS设计', 'HTML基础',\n      '沙发', '桌子', '椅子', '台灯', '书架',\n      '篮球', '足球', '跑鞋', '瑜伽垫', '哑铃'\n    ];\n    \n    return Array.from({ length: 1000 }, (_, index) => ({\n      id: index + 1,\n      name: `${productNames[index % productNames.length]} ${Math.floor(index / productNames.length) + 1}`,\n      category: categories[index % categories.length],\n      price: Math.floor(Math.random() * 1000) + 10,\n      stock: Math.floor(Math.random() * 100)\n    }));\n  }, []);\n  \n  // 使用 useMemo 缓存处理后的数据\n  const filteredProducts = useMemo(() => {\n    return processLargeDataset(products, filters);\n  }, [products, filters]);\n  \n  // 购物车统计\n  const cartStats = useMemo(() => {\n    const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);\n    const totalPrice = cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n    return { totalItems, totalPrice };\n  }, [cart]);\n  \n  // 添加到购物车的回调函数\n  const handleAddToCart = useCallback((product) => {\n    setCart(prevCart => {\n      const existingItem = prevCart.find(item => item.id === product.id);\n      if (existingItem) {\n        return prevCart.map(item => \n          item.id === product.id \n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      } else {\n        return [...prevCart, { ...product, quantity: 1 }];\n      }\n    });\n  }, []);\n  \n  // 更新过滤器\n  const updateFilter = useCallback((key, value) => {\n    setFilters(prev => ({ ...prev, [key]: value }));\n  }, []);\n  \n  return (\n    <div>\n      <h3>商品列表 ({filteredProducts.length} 件商品)</h3>\n      \n      {/* 购物车统计 */}\n      <div style={{ \n        background: '#f5f5f5', \n        padding: '16px', \n        marginBottom: '16px',\n        borderRadius: '8px'\n      }}>\n        <h4>购物车</h4>\n        <p>商品数量: {cartStats.totalItems}</p>\n        <p>总价: ¥{cartStats.totalPrice.toFixed(2)}</p>\n      </div>\n      \n      {/* 过滤器 */}\n      <div style={{ \n        display: 'grid', \n        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n        gap: '8px',\n        marginBottom: '16px',\n        padding: '16px',\n        background: '#f9f9f9',\n        borderRadius: '8px'\n      }}>\n        <select \n          value={filters.category} \n          onChange={(e) => updateFilter('category', e.target.value)}\n        >\n          <option value=\"\">所有分类</option>\n          <option value=\"电子产品\">电子产品</option>\n          <option value=\"服装\">服装</option>\n          <option value=\"书籍\">书籍</option>\n          <option value=\"家居\">家居</option>\n          <option value=\"运动\">运动</option>\n        </select>\n        \n        <input\n          type=\"number\"\n          placeholder=\"最低价格\"\n          value={filters.minPrice}\n          onChange={(e) => updateFilter('minPrice', Number(e.target.value))}\n        />\n        \n        <input\n          type=\"number\"\n          placeholder=\"最高价格\"\n          value={filters.maxPrice}\n          onChange={(e) => updateFilter('maxPrice', Number(e.target.value))}\n        />\n        \n        <input\n          type=\"text\"\n          placeholder=\"搜索商品...\"\n          value={filters.searchTerm}\n          onChange={(e) => updateFilter('searchTerm', e.target.value)}\n        />\n        \n        <select \n          value={filters.sortBy} \n          onChange={(e) => updateFilter('sortBy', e.target.value)}\n        >\n          <option value=\"name\">按名称排序</option>\n          <option value=\"price\">按价格排序</option>\n        </select>\n        \n        <select \n          value={filters.sortOrder} \n          onChange={(e) => updateFilter('sortOrder', e.target.value)}\n        >\n          <option value=\"asc\">升序</option>\n          <option value=\"desc\">降序</option>\n        </select>\n      </div>\n      \n      {/* 商品网格 */}\n      <div style={{ \n        display: 'grid', \n        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',\n        gap: '16px'\n      }}>\n        {filteredProducts.slice(0, 50).map(product => (\n          <ProductCard\n            key={product.id}\n            product={product}\n            onAddToCart={handleAddToCart}\n          />\n        ))}\n      </div>\n      \n      {filteredProducts.length > 50 && (\n        <p style={{ textAlign: 'center', marginTop: '16px' }}>\n          显示前50个结果，共{filteredProducts.length}个商品\n        </p>\n      )}\n    </div>\n  );\n};"
    },
    "commonMistakes": {
        "title": "常见错误和最佳实践",
        "language": "javascript",
        "code": "import React, { useState, useMemo, useEffect } from 'react';\n\n// ❌ 错误1: 过度使用 useMemo\nconst BadExample1 = () => {\n  const [name, setName] = useState('');\n  \n  // ❌ 对于简单计算使用 useMemo 是不必要的\n  const uppercaseName = useMemo(() => {\n    return name.toUpperCase();\n  }, [name]);\n  \n  // ❌ 对于基本的字符串拼接使用 useMemo\n  const greeting = useMemo(() => {\n    return `Hello, ${name}!`;\n  }, [name]);\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <p>{uppercaseName}</p>\n      <p>{greeting}</p>\n    </div>\n  );\n};\n\n// ✅ 正确1: 只对昂贵的计算使用 useMemo\nconst GoodExample1 = () => {\n  const [name, setName] = useState('');\n  \n  // ✅ 简单计算直接在渲染中进行\n  const uppercaseName = name.toUpperCase();\n  const greeting = `Hello, ${name}!`;\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <p>{uppercaseName}</p>\n      <p>{greeting}</p>\n    </div>\n  );\n};\n\n// ❌ 错误2: 依赖数组不正确\nconst BadExample2 = () => {\n  const [users, setUsers] = useState([]);\n  const [filter, setFilter] = useState({ status: 'active', role: 'user' });\n  \n  // ❌ 依赖对象，每次都会重新计算\n  const filteredUsers = useMemo(() => {\n    return users.filter(user => \n      user.status === filter.status && user.role === filter.role\n    );\n  }, [users, filter]); // filter 是对象，每次渲染都是新的引用\n  \n  return (\n    <div>\n      {filteredUsers.map(user => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n    </div>\n  );\n};\n\n// ✅ 正确2: 正确的依赖数组\nconst GoodExample2 = () => {\n  const [users, setUsers] = useState([]);\n  const [filter, setFilter] = useState({ status: 'active', role: 'user' });\n  \n  // ✅ 只依赖对象的具体属性\n  const filteredUsers = useMemo(() => {\n    return users.filter(user => \n      user.status === filter.status && user.role === filter.role\n    );\n  }, [users, filter.status, filter.role]);\n  \n  return (\n    <div>\n      {filteredUsers.map(user => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n    </div>\n  );\n};\n\n// ❌ 错误3: 在 useMemo 中执行副作用\nconst BadExample3 = () => {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  \n  // ❌ 在 useMemo 中执行副作用\n  const processedData = useMemo(() => {\n    setLoading(true); // 副作用！\n    \n    const result = data.map(item => ({\n      ...item,\n      processed: true\n    }));\n    \n    setLoading(false); // 副作用！\n    return result;\n  }, [data]);\n  \n  return (\n    <div>\n      {loading && <div>处理中...</div>}\n      {processedData.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n    </div>\n  );\n};\n\n// ✅ 正确3: 使用 useEffect 处理副作用\nconst GoodExample3 = () => {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  \n  // ✅ 纯计算，没有副作用\n  const processedData = useMemo(() => {\n    return data.map(item => ({\n      ...item,\n      processed: true\n    }));\n  }, [data]);\n  \n  // ✅ 使用 useEffect 处理副作用\n  useEffect(() => {\n    if (data.length > 0) {\n      setLoading(true);\n      // 模拟异步处理\n      const timer = setTimeout(() => {\n        setLoading(false);\n      }, 1000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, [data]);\n  \n  return (\n    <div>\n      {loading && <div>处理中...</div>}\n      {processedData.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n    </div>\n  );\n};\n\n// ❌ 错误4: 忘记依赖数组\nconst BadExample4 = () => {\n  const [items, setItems] = useState([]);\n  const [multiplier, setMultiplier] = useState(1);\n  \n  // ❌ 缺少依赖数组，每次渲染都会重新计算\n  const expensiveCalculation = useMemo(() => {\n    console.log('执行昂贵计算...');\n    return items.reduce((sum, item) => sum + item.value * multiplier, 0);\n  }); // 缺少依赖数组\n  \n  return (\n    <div>\n      <p>结果: {expensiveCalculation}</p>\n      <button onClick={() => setMultiplier(multiplier + 1)}>\n        增加倍数\n      </button>\n    </div>\n  );\n};\n\n// ✅ 正确4: 提供正确的依赖数组\nconst GoodExample4 = () => {\n  const [items, setItems] = useState([]);\n  const [multiplier, setMultiplier] = useState(1);\n  \n  // ✅ 包含所有依赖\n  const expensiveCalculation = useMemo(() => {\n    console.log('执行昂贵计算...');\n    return items.reduce((sum, item) => sum + item.value * multiplier, 0);\n  }, [items, multiplier]);\n  \n  return (\n    <div>\n      <p>结果: {expensiveCalculation}</p>\n      <button onClick={() => setMultiplier(multiplier + 1)}>\n        增加倍数\n      </button>\n    </div>\n  );\n};\n\n// 最佳实践示例\nconst BestPracticeExample = () => {\n  const [data, setData] = useState([]);\n  const [filters, setFilters] = useState({ category: '', minPrice: 0 });\n  \n  // ✅ 只对真正昂贵的计算使用 useMemo\n  const expensiveProcessedData = useMemo(() => {\n    console.log('执行昂贵的数据处理...');\n    \n    // 模拟复杂的数据处理\n    return data\n      .filter(item => {\n        if (filters.category && item.category !== filters.category) {\n          return false;\n        }\n        if (item.price < filters.minPrice) {\n          return false;\n        }\n        return true;\n      })\n      .map(item => ({\n        ...item,\n        // 复杂的计算\n        score: Math.sqrt(item.price * item.rating) + item.reviews * 0.1,\n        formattedPrice: new Intl.NumberFormat('zh-CN', {\n          style: 'currency',\n          currency: 'CNY'\n        }).format(item.price)\n      }))\n      .sort((a, b) => b.score - a.score);\n  }, [data, filters.category, filters.minPrice]); // 只依赖具体的属性\n  \n  // ✅ 简单的派生状态不需要 useMemo\n  const itemCount = expensiveProcessedData.length;\n  const hasItems = itemCount > 0;\n  \n  return (\n    <div>\n      <h3>最佳实践示例</h3>\n      <p>找到 {itemCount} 个项目</p>\n      {hasItems ? (\n        <ul>\n          {expensiveProcessedData.map(item => (\n            <li key={item.id}>\n              {item.name} - {item.formattedPrice} (评分: {item.score.toFixed(2)})\n            </li>\n          ))}\n        </ul>\n      ) : (\n        <p>没有找到匹配的项目</p>\n      )}\n    </div>\n  );\n};"
    },
    "vsUseCallback": {
        "title": "useMemo vs useCallback",
        "language": "javascript",
        "code": "// useMemo缓存计算结果\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n// useCallback缓存函数引用\nconst memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);\n\n// 等价写法\nconst memoizedCallback2 = useMemo(() => () => doSomething(a, b), [a, b]);"
    },
    "conditionalCaching": {
        "title": "条件性缓存",
        "language": "javascript",
        "code": "const Component = ({ data, shouldOptimize }) => {\n  const processedData = useMemo(() => {\n    if (!shouldOptimize) {\n      // 不需要优化时直接计算\n      return expensiveProcess(data);\n    }\n    // 需要优化时才缓存\n    return expensiveProcess(data);\n  }, shouldOptimize ? [data] : [data, Math.random()]);\n\n  return <div>{processedData}</div>;\n};"
    },
    "customHookUsage": {
        "title": "自定义Hook中的useMemo",
        "language": "javascript",
        "code": "const useFilteredData = (data, filters) => {\n  return useMemo(() => {\n    return data.filter(item => {\n      return Object.entries(filters).every(([key, value]) => {\n        if (!value) return true;\n        return item[key]?.toString().toLowerCase().includes(value.toLowerCase());\n      });\n    });\n  }, [data, filters]);\n};"
    }
}
