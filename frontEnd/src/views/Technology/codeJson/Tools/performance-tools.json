{
  "chromePerformance": {
    "title": "Chrome DevTools 性能分析",
    "language": "javascript",
    "code": "// 性能分析步骤\n// 1. 打开Chrome DevTools (F12)\n// 2. 切换到Performance面板\n// 3. 点击录制按钮开始分析\n// 4. 执行需要分析的操作\n// 5. 停止录制并分析结果\n\n// 性能报告解读\n// - FPS图表: 显示帧率变化\n// - CPU使用率: 显示CPU占用情况\n// - 网络活动: 显示网络请求时间线\n// - 主线程活动: 显示JavaScript执行详情\n\n// 关键性能指标\nconst performanceMetrics = {\n  FCP: 'First Contentful Paint', // 首次内容绘制\n  LCP: 'Largest Contentful Paint', // 最大内容绘制\n  FID: 'First Input Delay', // 首次输入延迟\n  CLS: 'Cumulative Layout Shift', // 累积布局偏移\n  TTFB: 'Time to First Byte' // 首字节时间\n}\n\n// 常见性能问题识别\n// - 长任务 (Long Tasks): 超过50ms的任务\n// - 强制同步布局 (Forced Reflow)\n// - 不必要的重绘 (Unnecessary Repaints)\n// - JavaScript执行时间过长"
  },
  "memoryAnalysis": {
    "title": "内存分析",
    "language": "javascript",
    "code": "// 内存分析类型\n// 1. Heap Snapshot (堆快照)\n//    - 查看内存使用情况\n//    - 识别内存泄漏\n//    - 分析对象引用关系\n\n// 2. Allocation Timeline (分配时间线)\n//    - 实时监控内存分配\n//    - 查看内存增长趋势\n\n// 3. Allocation Sampling (分配采样)\n//    - 轻量级内存分析\n//    - 适合长时间监控\n\n// 常见内存泄漏场景\n// 1. 全局变量未清理\nlet globalData = [] // 可能导致内存泄漏\n\n// 2. 事件监听器未移除\nfunction addListener() {\n  document.addEventListener('click', handleClick)\n  // 忘记移除监听器\n}\n\n// 3. 定时器未清理\nconst timer = setInterval(() => {\n  // 一些操作\n}, 1000)\n// 忘记 clearInterval(timer)\n\n// 4. 闭包引用\nfunction createHandler() {\n  const largeData = new Array(1000000).fill('data')\n  return function() {\n    // 闭包持有largeData引用\n    console.log('handler called')\n  }\n}\n\n// 内存优化建议\n// - 及时清理不需要的变量\n// - 移除事件监听器\n// - 清理定时器和动画\n// - 避免创建不必要的闭包\n\n// 内存泄漏检测\nfunction detectMemoryLeak() {\n  // 避免全局变量\n  // 坏的做法\n  window.globalData = []\n  \n  // 好的做法\n  const moduleData = []\n}"
  },
  "networkOptimization": {
    "title": "网络性能优化",
    "language": "html",
    "code": "<!-- 网络性能分析 -->\n<!-- 1. 资源加载瀑布图 -->\n<!--    - 查看资源加载顺序 -->\n<!--    - 识别阻塞资源 -->\n<!--    - 分析并行加载情况 -->\n\n<!-- 2. 资源优化策略 -->\n<!-- 预加载关键资源 -->\n<link rel=\"preload\" href=\"critical.css\" as=\"style\">\n<link rel=\"preload\" href=\"hero-image.jpg\" as=\"image\">\n<link rel=\"preload\" href=\"main.js\" as=\"script\">\n\n<!-- DNS预解析 -->\n<link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\">\n<link rel=\"dns-prefetch\" href=\"//api.example.com\">\n\n<!-- 预连接 -->\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n\n<!-- 资源压缩 -->\n<!-- 启用Gzip/Brotli压缩 -->\n<!-- 压缩图片 (WebP, AVIF) -->\n<!-- 压缩CSS/JS文件 -->\n\n<!-- 懒加载 -->\n<img src=\"placeholder.jpg\" data-src=\"actual-image.jpg\" loading=\"lazy\" alt=\"description\">\n\n<!-- 响应式图片 -->\n<picture>\n    <source srcset=\"image.webp\" type=\"image/webp\">\n    <source srcset=\"image.avif\" type=\"image/avif\">\n    <img src=\"image.jpg\" alt=\"description\" loading=\"lazy\">\n</picture>"
  },
  "lighthouseAudit": {
    "title": "Lighthouse 性能审计",
    "language": "bash",
    "code": "# Lighthouse安装和使用\n# 1. Chrome扩展使用\n# 在Chrome DevTools的Lighthouse面板中直接使用\n\n# 2. CLI工具安装\nnpm install -g lighthouse\n\n# 基本使用\nlighthouse https://example.com\n\n# 指定输出格式\nlighthouse https://example.com --output html --output-path ./report.html\nlighthouse https://example.com --output json --output-path ./report.json\n\n# 只运行性能审计\nlighthouse https://example.com --only-categories=performance\n\n# 模拟移动设备\nlighthouse https://example.com --emulated-form-factor=mobile\n\n# 自定义配置\nlighthouse https://example.com --config-path=./lighthouse-config.js\n\n# CI/CD集成\n# package.json\n{\n  \"scripts\": {\n    \"lighthouse\": \"lighthouse https://example.com --output html --output-path ./reports/lighthouse-report.html\",\n    \"lighthouse:ci\": \"lighthouse https://example.com --output json | node scripts/lighthouse-ci.js\"\n  }\n}\n\n# GitHub Actions集成\n# .github/workflows/lighthouse.yml\nname: Lighthouse CI\non: [push]\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Run Lighthouse CI\n        uses: treosh/lighthouse-ci-action@v7\n        with:\n          configPath: './lighthouserc.json'\n          uploadArtifacts: true\n          temporaryPublicStorage: true\n\n# lighthouserc.json配置\n{\n    \"ci\": {\n        \"collect\": {\n            \"url\": [\"http://localhost:3000\"],\n            \"numberOfRuns\": 3\n        },\n        \"assert\": {\n            \"assertions\": {\n                \"categories:performance\": [\"error\", {\"minScore\": 0.9}],\n                \"categories:accessibility\": [\"error\", {\"minScore\": 0.9}]\n            }\n        },\n        \"upload\": {\n            \"target\": \"temporary-public-storage\"\n        }\n    }\n}"
  },
  "coreWebVitals": {
    "title": "Core Web Vitals 优化",
    "language": "javascript",
    "code": "// Core Web Vitals优化\n// 1. LCP (Largest Contentful Paint) 优化\n// 目标: < 2.5秒\n\n// 优化策略:\n// - 优化服务器响应时间\n// - 移除阻塞渲染的资源\n// - 优化CSS\n// - 优化图片\n// - 预加载关键资源\n\n// 2. FID (First Input Delay) 优化\n// 目标: < 100毫秒\n\n// 优化策略:\n// - 减少JavaScript执行时间\n// - 代码分割\n// - 移除未使用的代码\n// - 使用Web Workers\n\n// 3. CLS (Cumulative Layout Shift) 优化\n// 目标: < 0.1\n\n// 优化策略:\n// - 为图片和视频设置尺寸属性\n// - 避免在现有内容上方插入内容\n// - 使用transform动画而非改变布局的属性\n\n// 性能监控代码\nfunction measureWebVitals() {\n  // 使用web-vitals库\n  import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n    getCLS(console.log)\n    getFID(console.log)\n    getFCP(console.log)\n    getLCP(console.log)\n    getTTFB(console.log)\n  })\n}\n\n// 性能API使用\nfunction measurePerformance() {\n  // 导航时间\n  const navigation = performance.getEntriesByType('navigation')[0]\n  console.log('页面加载时间:', navigation.loadEventEnd - navigation.fetchStart)\n  \n  // 资源时间\n  const resources = performance.getEntriesByType('resource')\n  resources.forEach(resource => {\n    console.log(`${resource.name}: ${resource.duration}ms`)\n  })\n  \n  // 自定义性能标记\n  performance.mark('custom-start')\n  // 执行一些操作\n  performance.mark('custom-end')\n  performance.measure('custom-operation', 'custom-start', 'custom-end')\n}\n\n// 服务端优化\nfunction serverOptimization(req, res) {\n  // 启用压缩\n  res.setHeader('Content-Encoding', 'gzip')\n  \n  // 设置缓存头\n  res.setHeader('Cache-Control', 'public, max-age=31536000')\n  \n  // 启用HTTP/2服务器推送\n  res.push('/critical.css')\n  res.push('/hero-image.jpg')\n  \n  const data = fetchDataFromDatabase()\n  cache.put(key, data, 300000) // 缓存5分钟\n  res.json(data)\n}"
  },
  "bundleAnalysis": {
    "title": "Bundle 分析工具",
    "language": "javascript",
    "code": "// Webpack Bundle Analyzer\n// 安装Bundle Analyzer\n// npm install --save-dev webpack-bundle-analyzer\n\n// webpack.config.js配置\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static', // 生成静态HTML文件\n      openAnalyzer: false,\n      reportFilename: 'bundle-report.html'\n    })\n  ]\n}\n\n// package.json脚本\n{\n  \"scripts\": {\n    \"analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\",\n    \"build:analyze\": \"npm run build -- --analyze\"\n  }\n}\n\n// Vite Bundle Analyzer\n// npm install --save-dev rollup-plugin-visualizer\n\n// vite.config.js\nimport { visualizer } from 'rollup-plugin-visualizer'\n\nexport default {\n  plugins: [\n    visualizer({\n      filename: 'dist/stats.html',\n      open: true,\n      gzipSize: true,\n      brotliSize: true\n    })\n  ]\n}\n\n// Next.js Bundle Analyzer\n// npm install --save-dev @next/bundle-analyzer\n\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true'\n})\n\nmodule.exports = withBundleAnalyzer({\n  // Next.js配置\n})\n\n// 使用: ANALYZE=true npm run build\n\n// Parcel Bundle Analyzer\n// npm install --save-dev parcel-bundle-analyzer\n\n// package.json\n{\n  \"scripts\": {\n    \"build:analyze\": \"parcel build src/index.html --reporter @parcel/reporter-bundle-analyzer\"\n  }\n}\n\n// 自定义Bundle分析\nconst fs = require('fs')\nconst path = require('path')\n\nfunction analyzeBundle(buildDir) {\n  const files = fs.readdirSync(buildDir)\n  let totalSize = 0\n  \n  files.forEach(file => {\n    if (file.endsWith('.js') || file.endsWith('.css')) {\n      const filePath = path.join(buildDir, file)\n      const stats = fs.statSync(filePath)\n      const sizeKB = Math.round(stats.size / 1024)\n      \n      console.log(`${file}: ${sizeKB}KB`)\n      totalSize += stats.size\n    }\n  })\n  \n  console.log(`Total: ${Math.round(totalSize / 1024)}KB`)\n}\n\n// 使用\n// analyzeBundle('./build/static/js')"
  }
}
