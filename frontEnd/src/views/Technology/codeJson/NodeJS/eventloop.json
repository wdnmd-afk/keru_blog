{
  "basicConcept": {
    "title": "事件循环基本概念",
    "language": "javascript",
    "code": "// Node.js 事件循环示例\nconsole.log('开始')\n\n// 同步代码\nconsole.log('同步代码 1')\n\n// 异步代码 - setTimeout\nsetTimeout(() => {\n  console.log('setTimeout 回调')\n}, 0)\n\n// 异步代码 - setImmediate\nsetImmediate(() => {\n  console.log('setImmediate 回调')\n})\n\n// 异步代码 - process.nextTick\nprocess.nextTick(() => {\n  console.log('process.nextTick 回调')\n})\n\n// 同步代码\nconsole.log('同步代码 2')\n\nconsole.log('结束')\n\n// 输出顺序:\n// 开始\n// 同步代码 1\n// 同步代码 2\n// 结束\n// process.nextTick 回调\n// setTimeout 回调\n// setImmediate 回调"
  },
  "eventLoopPhases": {
    "title": "事件循环阶段",
    "language": "javascript",
    "code": "// 事件循环的六个阶段示例\nconst fs = require('fs')\n\nconsole.log('=== 事件循环阶段演示 ===')\n\n// 1. Timer 阶段 - setTimeout, setInterval\nsetTimeout(() => console.log('Timer: setTimeout'), 0)\nsetInterval(() => {\n  console.log('Timer: setInterval')\n  process.exit(0) // 避免无限循环\n}, 100)\n\n// 2. Pending callbacks 阶段 - I/O 回调\nfs.readFile(__filename, () => {\n  console.log('I/O: fs.readFile 回调')\n})\n\n// 3. Idle, prepare 阶段 - 内部使用\n\n// 4. Poll 阶段 - 获取新的 I/O 事件\n\n// 5. Check 阶段 - setImmediate\nsetImmediate(() => console.log('Check: setImmediate'))\n\n// 6. Close callbacks 阶段\nconst server = require('http').createServer()\nserver.on('close', () => console.log('Close: server close'))\nserver.close()\n\n// 微任务队列\nprocess.nextTick(() => console.log('Microtask: process.nextTick'))\nPromise.resolve().then(() => console.log('Microtask: Promise.then'))"
  },
  "microtaskQueue": {
    "title": "微任务队列",
    "language": "javascript",
    "code": "// 微任务 vs 宏任务\nconsole.log('=== 微任务队列演示 ===')\n\n// 宏任务\nsetTimeout(() => console.log('宏任务: setTimeout 1'), 0)\nsetTimeout(() => console.log('宏任务: setTimeout 2'), 0)\n\n// 微任务\nprocess.nextTick(() => {\n  console.log('微任务: process.nextTick 1')\n  // 在微任务中添加新的微任务\n  process.nextTick(() => console.log('微任务: process.nextTick 嵌套'))\n})\n\nPromise.resolve().then(() => {\n  console.log('微任务: Promise.then 1')\n  return Promise.resolve()\n}).then(() => {\n  console.log('微任务: Promise.then 2')\n})\n\nprocess.nextTick(() => console.log('微任务: process.nextTick 2'))\n\nsetImmediate(() => console.log('宏任务: setImmediate'))\n\nconsole.log('同步代码')\n\n// 输出顺序:\n// 同步代码\n// 微任务: process.nextTick 1\n// 微任务: process.nextTick 2\n// 微任务: process.nextTick 嵌套\n// 微任务: Promise.then 1\n// 微任务: Promise.then 2\n// 宏任务: setTimeout 1\n// 宏任务: setTimeout 2\n// 宏任务: setImmediate"
  },
  "asyncAwait": {
    "title": "async/await 与事件循环",
    "language": "javascript",
    "code": "// async/await 在事件循环中的行为\nasync function asyncDemo() {\n  console.log('async 函数开始')\n  \n  // await 会暂停函数执行，将后续代码放入微任务队列\n  await Promise.resolve()\n  console.log('await 后的代码')\n  \n  await new Promise(resolve => {\n    setTimeout(() => {\n      console.log('Promise 中的 setTimeout')\n      resolve()\n    }, 0)\n  })\n  \n  console.log('第二个 await 后的代码')\n}\n\nconsole.log('开始')\n\nasyncDemo()\n\nsetTimeout(() => console.log('外部 setTimeout'), 0)\nprocess.nextTick(() => console.log('外部 nextTick'))\n\nconsole.log('结束')\n\n// 复杂的 async/await 示例\nasync function complexAsync() {\n  console.log('complexAsync 开始')\n  \n  const result1 = await fetch('https://api.example.com/data1')\n  console.log('第一个请求完成')\n  \n  const result2 = await fetch('https://api.example.com/data2')\n  console.log('第二个请求完成')\n  \n  // 并行执行\n  const [data1, data2] = await Promise.all([\n    fetch('https://api.example.com/parallel1'),\n    fetch('https://api.example.com/parallel2')\n  ])\n  \n  console.log('并行请求完成')\n  return { data1, data2 }\n}"
  },
  "performanceOptimization": {
    "title": "性能优化技巧",
    "language": "javascript",
    "code": "// 避免阻塞事件循环\nconst crypto = require('crypto')\nconst { Worker, isMainThread, parentPort } = require('worker_threads')\n\n// ❌ 错误：阻塞事件循环\nfunction blockingOperation() {\n  const start = Date.now()\n  // 同步的CPU密集型操作\n  crypto.pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512')\n  console.log(`阻塞操作耗时: ${Date.now() - start}ms`)\n}\n\n// ✅ 正确：使用异步操作\nfunction nonBlockingOperation() {\n  const start = Date.now()\n  crypto.pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, key) => {\n    if (err) throw err\n    console.log(`非阻塞操作耗时: ${Date.now() - start}ms`)\n  })\n}\n\n// ✅ 使用 Worker Threads 处理CPU密集型任务\nif (isMainThread) {\n  // 主线程\n  const worker = new Worker(__filename)\n  worker.postMessage({ task: 'heavy-computation', data: [1, 2, 3, 4, 5] })\n  \n  worker.on('message', (result) => {\n    console.log('Worker 结果:', result)\n  })\n  \n  // 主线程可以继续处理其他任务\n  setInterval(() => {\n    console.log('主线程仍在运行')\n  }, 1000)\n} else {\n  // Worker 线程\n  parentPort.on('message', ({ task, data }) => {\n    if (task === 'heavy-computation') {\n      // 执行CPU密集型计算\n      const result = data.reduce((sum, num) => {\n        // 模拟复杂计算\n        for (let i = 0; i < 1000000; i++) {\n          sum += num * Math.random()\n        }\n        return sum\n      }, 0)\n      \n      parentPort.postMessage(result)\n    }\n  })\n}\n\n// 使用 setImmediate 分割长任务\nfunction processLargeArray(array, callback) {\n  if (array.length === 0) {\n    return callback()\n  }\n  \n  // 处理一小部分数据\n  const batch = array.splice(0, 100)\n  batch.forEach(item => {\n    // 处理单个项目\n    console.log(`处理项目: ${item}`)\n  })\n  \n  // 使用 setImmediate 让出控制权\n  setImmediate(() => processLargeArray(array, callback))\n}"
  },
  "timerComparison": {
    "title": "定时器对比",
    "language": "javascript",
    "code": "// setTimeout vs setImmediate vs process.nextTick\nconsole.log('=== 定时器执行顺序对比 ===')\n\n// 立即执行\nconsole.log('1. 同步代码')\n\n// 微任务队列 - 最高优先级\nprocess.nextTick(() => console.log('2. process.nextTick'))\nPromise.resolve().then(() => console.log('3. Promise.then'))\n\n// 宏任务队列\nsetTimeout(() => console.log('4. setTimeout 0'), 0)\nsetImmediate(() => console.log('5. setImmediate'))\n\n// I/O 操作\nconst fs = require('fs')\nfs.readFile(__filename, () => {\n  console.log('6. fs.readFile')\n  \n  // 在 I/O 回调中的执行顺序\n  setTimeout(() => console.log('7. setTimeout in I/O'), 0)\n  setImmediate(() => console.log('8. setImmediate in I/O'))\n  process.nextTick(() => console.log('9. nextTick in I/O'))\n})\n\nconsole.log('10. 同步代码结束')"
  },
  "eventLoopMonitoring": {
    "title": "事件循环监控",
    "language": "javascript",
    "code": "// 监控事件循环延迟\nconst { performance } = require('perf_hooks')\n\nclass EventLoopMonitor {\n  constructor() {\n    this.delays = []\n    this.isMonitoring = false\n  }\n  \n  start() {\n    if (this.isMonitoring) return\n    \n    this.isMonitoring = true\n    this.monitor()\n    console.log('🔍 开始监控事件循环延迟')\n  }\n  \n  stop() {\n    this.isMonitoring = false\n    console.log('⏹️  停止监控事件循环延迟')\n  }\n  \n  monitor() {\n    if (!this.isMonitoring) return\n    \n    const start = performance.now()\n    \n    setImmediate(() => {\n      const delay = performance.now() - start\n      this.delays.push(delay)\n      \n      // 保持最近100个样本\n      if (this.delays.length > 100) {\n        this.delays.shift()\n      }\n      \n      // 如果延迟过高，发出警告\n      if (delay > 10) {\n        console.warn(`⚠️  事件循环延迟过高: ${delay.toFixed(2)}ms`)\n      }\n      \n      // 继续监控\n      this.monitor()\n    })\n  }\n  \n  getStats() {\n    if (this.delays.length === 0) {\n      return { avg: 0, max: 0, min: 0 }\n    }\n    \n    const avg = this.delays.reduce((a, b) => a + b, 0) / this.delays.length\n    const max = Math.max(...this.delays)\n    const min = Math.min(...this.delays)\n    \n    return {\n      avg: avg.toFixed(2),\n      max: max.toFixed(2),\n      min: min.toFixed(2),\n      samples: this.delays.length\n    }\n  }\n}\n\n// 使用示例\nconst monitor = new EventLoopMonitor()\nmonitor.start()\n\n// 模拟一些工作负载\nsetInterval(() => {\n  const stats = monitor.getStats()\n  console.log('📊 事件循环统计:', stats)\n}, 5000)\n\n// 模拟阻塞操作\nsetTimeout(() => {\n  console.log('🔥 执行阻塞操作...')\n  const start = Date.now()\n  while (Date.now() - start < 100) {\n    // 阻塞100ms\n  }\n  console.log('✅ 阻塞操作完成')\n}, 10000)"
  }
}
