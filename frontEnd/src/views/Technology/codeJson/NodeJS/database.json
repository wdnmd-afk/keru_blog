{
  "mysqlNative": {
    "title": "MySQL原生驱动使用",
    "language": "javascript",
    "code": "// 安装MySQL驱动\n// npm install mysql2\n\n// 基本连接\nconst mysql = require('mysql2/promise')\n\n// 创建连接池\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'myapp',\n  waitForConnections: true,\n  connectionLimit: 10,\n  queueLimit: 0\n})\n\n// 执行查询\nasync function getUsers() {\n  try {\n    const [rows] = await pool.execute(\n      'SELECT id, name, email FROM users WHERE status = ?',\n      ['active']\n    )\n    return rows\n  } catch (error) {\n    console.error('数据库查询错误:', error)\n    throw error\n  }\n}\n\n// 事务处理\nasync function createUserWithProfile(userData, profileData) {\n  const connection = await pool.getConnection()\n  \n  try {\n    await connection.beginTransaction()\n    \n    // 创建用户\n    const [userResult] = await connection.execute(\n      'INSERT INTO users (name, email) VALUES (?, ?)',\n      [userData.name, userData.email]\n    )\n    \n    const userId = userResult.insertId\n    \n    // 创建用户资料\n    await connection.execute(\n      'INSERT INTO profiles (user_id, bio, avatar) VALUES (?, ?, ?)',\n      [userId, profileData.bio, profileData.avatar]\n    )\n    \n    await connection.commit()\n    return userId\n  } catch (error) {\n    await connection.rollback()\n    throw error\n  } finally {\n    connection.release()\n  }\n}"
  },
  "sequelizeORM": {
    "title": "Sequelize ORM",
    "language": "javascript",
    "code": "// 安装Sequelize\n// npm install sequelize mysql2\n\n// 配置连接\nconst { Sequelize, DataTypes } = require('sequelize')\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql',\n  pool: {\n    max: 5,\n    min: 0,\n    acquire: 30000,\n    idle: 10000\n  }\n})\n\n// 定义模型\nconst User = sequelize.define('User', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    validate: {\n      notEmpty: true,\n      len: [2, 50]\n    }\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true,\n    validate: {\n      isEmail: true\n    }\n  },\n  status: {\n    type: DataTypes.ENUM('active', 'inactive'),\n    defaultValue: 'active'\n  }\n}, {\n  tableName: 'users',\n  timestamps: true\n})\n\n// 关联关系\nconst Post = sequelize.define('Post', {\n  title: DataTypes.STRING,\n  content: DataTypes.TEXT\n})\n\nUser.hasMany(Post)\nPost.belongsTo(User)\n\n// 查询操作\nasync function findUsers() {\n  return await User.findAll({\n    where: {\n      status: 'active'\n    },\n    include: [{\n      model: Post,\n      attributes: ['title', 'createdAt']\n    }],\n    order: [['createdAt', 'DESC']],\n    limit: 10\n  })\n}"
  },
  "prismaORM": {
    "title": "Prisma ORM",
    "language": "javascript",
    "code": "// 安装Prisma\n// npm install prisma @prisma/client\n// npx prisma init\n\n// schema.prisma\n/*\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id       Int      @id @default(autoincrement())\n  name     String\n  email    String   @unique\n  posts    Post[]\n  profile  Profile?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@map(\"users\")\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?  @db.Text\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@map(\"posts\")\n}\n\nmodel Profile {\n  id     Int     @id @default(autoincrement())\n  bio    String?\n  avatar String?\n  user   User    @relation(fields: [userId], references: [id])\n  userId Int     @unique\n\n  @@map(\"profiles\")\n}\n*/\n\n// 生成客户端\n// npx prisma generate\n\n// 使用Prisma客户端\nconst { PrismaClient } = require('@prisma/client')\nconst prisma = new PrismaClient()\n\n// CRUD操作\nasync function createUser(data) {\n  return await prisma.user.create({\n    data: {\n      name: data.name,\n      email: data.email,\n      profile: {\n        create: {\n          bio: data.bio,\n          avatar: data.avatar\n        }\n      }\n    },\n    include: {\n      profile: true\n    }\n  })\n}\n\n// 复杂查询\nasync function getUsersWithPosts() {\n  return await prisma.user.findMany({\n    include: {\n      posts: {\n        where: {\n          published: true\n        },\n        orderBy: {\n          createdAt: 'desc'\n        }\n      },\n      profile: true\n    }\n  })\n}\n\n// 事务处理\nasync function transferPost(postId, newAuthorId) {\n  return await prisma.$transaction(async (prisma) => {\n    // 检查新作者是否存在\n    const newAuthor = await prisma.user.findUnique({\n      where: { id: newAuthorId }\n    })\n    \n    if (!newAuthor) {\n      throw new Error('新作者不存在')\n    }\n    \n    // 更新文章作者\n    const post = await prisma.post.update({\n      where: { id: postId },\n      data: { authorId: newAuthorId }\n    })\n    \n    return post\n  })\n}"
  },
  "mongodbNative": {
    "title": "MongoDB原生驱动",
    "language": "javascript",
    "code": "// 安装MongoDB驱动\n// npm install mongodb\n\n// 连接MongoDB\nconst { MongoClient } = require('mongodb')\n\nconst uri = 'mongodb://localhost:27017'\nconst client = new MongoClient(uri)\n\nasync function connectDB() {\n  try {\n    await client.connect()\n    console.log('MongoDB连接成功')\n    return client.db('myapp')\n  } catch (error) {\n    console.error('MongoDB连接失败:', error)\n    throw error\n  }\n}\n\n// CRUD操作\nasync function userOperations() {\n  const db = await connectDB()\n  const users = db.collection('users')\n  \n  // 创建用户\n  const newUser = await users.insertOne({\n    name: '张三',\n    email: 'zhang@example.com',\n    age: 25,\n    tags: ['developer', 'nodejs'],\n    createdAt: new Date()\n  })\n  \n  // 查询用户\n  const user = await users.findOne({ _id: newUser.insertId })\n  \n  // 更新用户\n  await users.updateOne(\n    { _id: newUser.insertId },\n    { \n      $set: { age: 26 },\n      $push: { tags: 'mongodb' }\n    }\n  )\n  \n  // 复杂查询\n  const activeUsers = await users.find({\n    age: { $gte: 18, $lte: 65 },\n    tags: { $in: ['developer'] },\n    'profile.status': 'active'\n  }).toArray()\n  \n  // 聚合查询\n  const pipeline = [\n    { $match: { age: { $gte: 18 } } },\n    { $group: {\n        _id: '$department',\n        count: { $sum: 1 },\n        avgAge: { $avg: '$age' }\n      }\n    },\n    { $sort: { count: -1 } }\n  ]\n  const aggregationResult = await users.aggregate(pipeline).toArray()\n  \n  return aggregationResult\n}"
  },
  "mongooseODM": {
    "title": "Mongoose ODM",
    "language": "javascript",
    "code": "// 安装Mongoose\n// npm install mongoose\n\n// 连接配置\nconst mongoose = require('mongoose')\n\nmongoose.connect('mongodb://localhost:27017/myapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n})\n\n// 定义Schema\nconst userSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: [true, '姓名是必填的'],\n    trim: true,\n    minlength: 2,\n    maxlength: 50\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true,\n    validate: {\n      validator: function(v) {\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v)\n      },\n      message: '请输入有效的邮箱地址'\n    }\n  },\n  age: {\n    type: Number,\n    min: [0, '年龄不能为负数'],\n    max: [120, '年龄不能超过120岁']\n  },\n  profile: {\n    bio: String,\n    avatar: String,\n    social: {\n      twitter: String,\n      github: String\n    }\n  },\n  tags: [String],\n  status: {\n    type: String,\n    enum: ['active', 'inactive', 'pending'],\n    default: 'pending'\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n})\n\n// 虚拟字段\nuserSchema.virtual('fullProfile').get(function() {\n  return `${this.name} (${this.email})`\n})\n\n// 中间件\nuserSchema.pre('save', function(next) {\n  if (this.isModified('email')) {\n    this.email = this.email.toLowerCase()\n  }\n  next()\n})\n\n// 静态方法\nuserSchema.statics.findByEmail = function(email) {\n  return this.findOne({ email: email.toLowerCase() })\n}\n\n// 实例方法\nuserSchema.methods.addTag = function(tag) {\n  if (!this.tags.includes(tag)) {\n    this.tags.push(tag)\n  }\n  return this.save()\n}\n\nconst User = mongoose.model('User', userSchema)\n\n// 使用示例\nasync function userOperations() {\n  try {\n    // 创建用户\n    const user = new User({\n      name: '李四',\n      email: 'LI@EXAMPLE.COM',\n      age: 28,\n      profile: {\n        bio: '全栈开发者',\n        social: {\n          github: 'lisi'\n        }\n      },\n      tags: ['javascript', 'nodejs']\n    })\n    \n    await user.save()\n    \n    // 查询操作\n    const users = await User.find({ status: 'active' })\n      .populate('posts')\n      .sort({ createdAt: -1 })\n      .limit(10)\n    \n    return users\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      const errors = Object.values(error.errors).map(err => err.message)\n      throw new Error(`验证失败: ${errors.join(', ')}`)\n    }\n    throw error\n  }\n}"
  },
  "redisBasic": {
    "title": "Redis基本使用",
    "language": "javascript",
    "code": "// 安装Redis客户端\n// npm install redis\n\n// 连接Redis\nconst redis = require('redis')\nconst client = redis.createClient({\n  host: 'localhost',\n  port: 6379,\n  password: 'your-password', // 如果有密码\n  db: 0\n})\n\nclient.on('connect', () => {\n  console.log('Redis连接成功')\n})\n\nclient.on('error', (err) => {\n  console.error('Redis连接错误:', err)\n})\n\n// 基本操作\nasync function redisOperations() {\n  // 字符串操作\n  await client.set('user:1:name', '张三')\n  const name = await client.get('user:1:name')\n  \n  // 设置过期时间\n  await client.setex('session:abc123', 3600, 'user-data')\n  \n  // 哈希操作\n  await client.hset('user:1', {\n    name: '张三',\n    email: 'zhang@example.com',\n    age: 25\n  })\n  const user = await client.hgetall('user:1')\n  \n  // 列表操作\n  await client.lpush('notifications', '新消息1', '新消息2')\n  const notifications = await client.lrange('notifications', 0, -1)\n  \n  // 集合操作\n  await client.sadd('tags', 'javascript', 'nodejs', 'redis')\n  const tags = await client.smembers('tags')\n  \n  // 有序集合操作\n  await client.zadd('leaderboard', 100, 'user:1', 200, 'user:2', 150, 'user:3')\n  const topUsers = await client.zrevrange('leaderboard', 0, 2, 'WITHSCORES')\n  \n  return { name, user, notifications, tags, topUsers }\n}"
  },
  "redisCaching": {
    "title": "Redis缓存策略",
    "language": "javascript",
    "code": "// 缓存装饰器\nfunction cache(ttl = 3600) {\n  return function(target, propertyName, descriptor) {\n    const originalMethod = descriptor.value\n    \n    descriptor.value = async function(...args) {\n      const cacheKey = `cache:${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`\n      \n      // 尝试从缓存获取\n      const cached = await client.get(cacheKey)\n      if (cached) {\n        return JSON.parse(cached)\n      }\n      \n      // 执行原方法\n      const result = await originalMethod.apply(this, args)\n      \n      // 存入缓存\n      await client.setex(cacheKey, ttl, JSON.stringify(result))\n      \n      return result\n    }\n    \n    return descriptor\n  }\n}\n\n// 缓存服务类\nclass CacheService {\n  constructor(redisClient) {\n    this.client = redisClient\n  }\n  \n  // 获取或设置缓存\n  async getOrSet(key, fetchFunction, ttl = 3600) {\n    const cached = await this.client.get(key)\n    if (cached) {\n      return JSON.parse(cached)\n    }\n    \n    const data = await fetchFunction()\n    await this.client.setex(key, ttl, JSON.stringify(data))\n    return data\n  }\n  \n  // 缓存失效\n  async invalidate(pattern) {\n    const keys = await this.client.keys(pattern)\n    if (keys.length > 0) {\n      await this.client.del(...keys)\n    }\n  }\n  \n  // 分布式锁\n  async acquireLock(lockKey, ttl = 10) {\n    const identifier = Math.random().toString(36)\n    const result = await this.client.set(lockKey, identifier, 'PX', ttl * 1000, 'NX')\n    return result === 'OK' ? identifier : null\n  }\n  \n  async releaseLock(lockKey, identifier) {\n    const script = `\n      if redis.call('get', KEYS[1]) == ARGV[1] then\n        return redis.call('del', KEYS[1])\n      else\n        return 0\n      end\n    `\n    return await this.client.eval(script, 1, lockKey, identifier)\n  }\n}\n\n// 使用示例\nconst cacheService = new CacheService(client)\n\n// 分布式锁使用\nasync function processOrder(orderId) {\n  const lockKey = `lock:order:${orderId}`\n  const lockId = await cacheService.acquireLock(lockKey, 30)\n  \n  if (lockId) {\n    try {\n      // 处理订单逻辑\n      console.log(`处理订单 ${orderId}`)\n      // ... 业务逻辑\n    } finally {\n      await cacheService.releaseLock(lockKey, lockId)\n    }\n  } else {\n    throw new Error('订单正在处理中，请稍后重试')\n  }\n}"
  }
}
