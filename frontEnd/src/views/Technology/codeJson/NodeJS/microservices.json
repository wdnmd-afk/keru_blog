{
  "basicArchitecture": {
    "title": "微服务基本架构",
    "language": "javascript",
    "code": "// 用户服务 (User Service)\nconst express = require('express')\nconst app = express()\n\napp.use(express.json())\n\n// 用户相关API\napp.get('/users/:id', async (req, res) => {\n  try {\n    const user = await getUserById(req.params.id)\n    res.json(user)\n  } catch (error) {\n    res.status(500).json({ error: error.message })\n  }\n})\n\napp.post('/users', async (req, res) => {\n  try {\n    const user = await createUser(req.body)\n    res.status(201).json(user)\n  } catch (error) {\n    res.status(400).json({ error: error.message })\n  }\n})\n\napp.listen(3001, () => {\n  console.log('用户服务运行在端口 3001')\n})\n\n// 订单服务 (Order Service)\nconst orderApp = express()\n\norderApp.use(express.json())\n\n// 订单相关API\norderApp.get('/orders/:id', async (req, res) => {\n  try {\n    const order = await getOrderById(req.params.id)\n    res.json(order)\n  } catch (error) {\n    res.status(500).json({ error: error.message })\n  }\n})\n\norderApp.post('/orders', async (req, res) => {\n  try {\n    // 调用用户服务验证用户\n    const userResponse = await fetch(`http://user-service:3001/users/${req.body.userId}`)\n    if (!userResponse.ok) {\n      return res.status(400).json({ error: '用户不存在' })\n    }\n    \n    const order = await createOrder(req.body)\n    res.status(201).json(order)\n  } catch (error) {\n    res.status(400).json({ error: error.message })\n  }\n})\n\norderApp.listen(3002, () => {\n  console.log('订单服务运行在端口 3002')\n})"
  },
  "serviceDiscovery": {
    "title": "服务发现",
    "language": "javascript",
    "code": "// 服务注册中心\nclass ServiceRegistry {\n  constructor() {\n    this.services = new Map()\n  }\n  \n  // 注册服务\n  register(serviceName, serviceInfo) {\n    if (!this.services.has(serviceName)) {\n      this.services.set(serviceName, [])\n    }\n    \n    this.services.get(serviceName).push({\n      ...serviceInfo,\n      registeredAt: new Date(),\n      lastHeartbeat: new Date()\n    })\n    \n    console.log(`服务注册: ${serviceName} - ${serviceInfo.host}:${serviceInfo.port}`)\n  }\n  \n  // 发现服务\n  discover(serviceName) {\n    const instances = this.services.get(serviceName) || []\n    // 过滤健康的服务实例\n    return instances.filter(instance => {\n      const timeSinceHeartbeat = Date.now() - instance.lastHeartbeat.getTime()\n      return timeSinceHeartbeat < 30000 // 30秒内有心跳\n    })\n  }\n  \n  // 心跳检测\n  heartbeat(serviceName, serviceId) {\n    const instances = this.services.get(serviceName) || []\n    const instance = instances.find(i => i.id === serviceId)\n    if (instance) {\n      instance.lastHeartbeat = new Date()\n    }\n  }\n  \n  // 注销服务\n  unregister(serviceName, serviceId) {\n    const instances = this.services.get(serviceName) || []\n    const index = instances.findIndex(i => i.id === serviceId)\n    if (index !== -1) {\n      instances.splice(index, 1)\n      console.log(`服务注销: ${serviceName} - ${serviceId}`)\n    }\n  }\n}\n\n// 服务实例\nclass ServiceInstance {\n  constructor(serviceName, host, port) {\n    this.serviceName = serviceName\n    this.host = host\n    this.port = port\n    this.id = `${serviceName}-${Date.now()}`\n    this.registry = new ServiceRegistry()\n  }\n  \n  // 启动服务\n  start() {\n    // 注册服务\n    this.registry.register(this.serviceName, {\n      id: this.id,\n      host: this.host,\n      port: this.port,\n      status: 'healthy'\n    })\n    \n    // 定期发送心跳\n    this.heartbeatInterval = setInterval(() => {\n      this.registry.heartbeat(this.serviceName, this.id)\n    }, 10000)\n    \n    console.log(`服务启动: ${this.serviceName} on ${this.host}:${this.port}`)\n  }\n  \n  // 停止服务\n  stop() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval)\n    }\n    this.registry.unregister(this.serviceName, this.id)\n    console.log(`服务停止: ${this.serviceName}`)\n  }\n}\n\n// 使用示例\nconst userService = new ServiceInstance('user-service', 'localhost', 3001)\nconst orderService = new ServiceInstance('order-service', 'localhost', 3002)\n\nuserService.start()\norderService.start()"
  },
  "apiGateway": {
    "title": "API网关",
    "language": "javascript",
    "code": "// API网关实现\nconst express = require('express')\nconst httpProxy = require('http-proxy-middleware')\nconst rateLimit = require('express-rate-limit')\nconst jwt = require('jsonwebtoken')\n\nconst app = express()\n\n// 服务配置\nconst services = {\n  'user-service': 'http://localhost:3001',\n  'order-service': 'http://localhost:3002',\n  'product-service': 'http://localhost:3003'\n}\n\n// 中间件\napp.use(express.json())\n\n// 速率限制\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15分钟\n  max: 100 // 限制每个IP 100个请求\n})\napp.use('/api/', limiter)\n\n// JWT认证中间件\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization']\n  const token = authHeader && authHeader.split(' ')[1]\n  \n  if (!token) {\n    return res.status(401).json({ error: '缺少访问令牌' })\n  }\n  \n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: '无效的访问令牌' })\n    }\n    req.user = user\n    next()\n  })\n}\n\n// 负载均衡器\nclass LoadBalancer {\n  constructor() {\n    this.currentIndex = 0\n  }\n  \n  // 轮询算法\n  roundRobin(instances) {\n    if (instances.length === 0) return null\n    \n    const instance = instances[this.currentIndex]\n    this.currentIndex = (this.currentIndex + 1) % instances.length\n    return instance\n  }\n  \n  // 随机算法\n  random(instances) {\n    if (instances.length === 0) return null\n    const index = Math.floor(Math.random() * instances.length)\n    return instances[index]\n  }\n}\n\nconst loadBalancer = new LoadBalancer()\n\n// 动态路由\napp.use('/api/:service/*', authenticateToken, (req, res, next) => {\n  const serviceName = req.params.service\n  const serviceUrl = services[serviceName]\n  \n  if (!serviceUrl) {\n    return res.status(404).json({ error: '服务未找到' })\n  }\n  \n  // 创建代理\n  const proxy = httpProxy.createProxyMiddleware({\n    target: serviceUrl,\n    changeOrigin: true,\n    pathRewrite: {\n      [`^/api/${serviceName}`]: ''\n    },\n    onError: (err, req, res) => {\n      console.error('代理错误:', err)\n      res.status(500).json({ error: '服务暂时不可用' })\n    },\n    onProxyReq: (proxyReq, req, res) => {\n      // 添加请求头\n      proxyReq.setHeader('X-User-ID', req.user.id)\n      proxyReq.setHeader('X-Request-ID', generateRequestId())\n    }\n  })\n  \n  proxy(req, res, next)\n})\n\n// 健康检查\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', timestamp: new Date().toISOString() })\n})\n\n// 生成请求ID\nfunction generateRequestId() {\n  return Math.random().toString(36).substring(2, 15)\n}\n\napp.listen(3000, () => {\n  console.log('API网关运行在端口 3000')\n})"
  },
  "messageQueue": {
    "title": "消息队列通信",
    "language": "javascript",
    "code": "// 使用Redis作为消息队列\nconst redis = require('redis')\nconst { EventEmitter } = require('events')\n\nclass MessageQueue extends EventEmitter {\n  constructor() {\n    super()\n    this.publisher = redis.createClient()\n    this.subscriber = redis.createClient()\n    this.setupSubscriber()\n  }\n  \n  // 发布消息\n  async publish(channel, message) {\n    const payload = {\n      id: this.generateId(),\n      timestamp: new Date().toISOString(),\n      data: message\n    }\n    \n    await this.publisher.publish(channel, JSON.stringify(payload))\n    console.log(`消息发布到 ${channel}:`, payload.id)\n  }\n  \n  // 订阅消息\n  async subscribe(channel, handler) {\n    await this.subscriber.subscribe(channel)\n    this.on(channel, handler)\n    console.log(`订阅频道: ${channel}`)\n  }\n  \n  // 设置订阅者\n  setupSubscriber() {\n    this.subscriber.on('message', (channel, message) => {\n      try {\n        const payload = JSON.parse(message)\n        this.emit(channel, payload)\n      } catch (error) {\n        console.error('消息解析错误:', error)\n      }\n    })\n  }\n  \n  generateId() {\n    return Math.random().toString(36).substring(2, 15)\n  }\n}\n\n// 用户服务 - 发布用户创建事件\nconst userServiceMQ = new MessageQueue()\n\nclass UserService {\n  async createUser(userData) {\n    try {\n      // 创建用户\n      const user = await this.saveUser(userData)\n      \n      // 发布用户创建事件\n      await userServiceMQ.publish('user.created', {\n        userId: user.id,\n        email: user.email,\n        name: user.name\n      })\n      \n      return user\n    } catch (error) {\n      console.error('用户创建失败:', error)\n      throw error\n    }\n  }\n  \n  async saveUser(userData) {\n    // 模拟保存用户到数据库\n    return {\n      id: Date.now(),\n      ...userData,\n      createdAt: new Date()\n    }\n  }\n}\n\n// 邮件服务 - 订阅用户创建事件\nconst emailServiceMQ = new MessageQueue()\n\nclass EmailService {\n  constructor() {\n    this.setupEventHandlers()\n  }\n  \n  async setupEventHandlers() {\n    // 订阅用户创建事件\n    await emailServiceMQ.subscribe('user.created', this.handleUserCreated.bind(this))\n  }\n  \n  async handleUserCreated(event) {\n    try {\n      console.log('处理用户创建事件:', event.id)\n      \n      // 发送欢迎邮件\n      await this.sendWelcomeEmail(event.data.email, event.data.name)\n      \n      console.log(`欢迎邮件已发送给: ${event.data.email}`)\n    } catch (error) {\n      console.error('邮件发送失败:', error)\n    }\n  }\n  \n  async sendWelcomeEmail(email, name) {\n    // 模拟发送邮件\n    return new Promise(resolve => {\n      setTimeout(() => {\n        console.log(`📧 发送欢迎邮件到 ${email}`)\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// 使用示例\nconst userService = new UserService()\nconst emailService = new EmailService()\n\n// 创建用户，自动触发邮件发送\nuserService.createUser({\n  name: '张三',\n  email: 'zhangsan@example.com'\n})"
  }
}
