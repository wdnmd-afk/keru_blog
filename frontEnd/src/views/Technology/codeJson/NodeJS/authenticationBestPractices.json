{
    "sessionAuth": {
        "title": "Express Session配置",
        "language": "javascript",
        "code": "// 安装依赖\nnpm install express-session connect-mongo\n\nconst session = require('express-session')\nconst MongoStore = require('connect-mongo')\n\n// Session配置\napp.use(session({\n    secret: process.env.SESSION_SECRET || 'your-secret-key',\n    resave: false,\n    saveUninitialized: false,\n    store: MongoStore.create({\n        mongoUrl: process.env.MONGODB_URI,\n        touchAfter: 24 * 3600 // 24小时内只更新一次\n    }),\n    cookie: {\n        secure: process.env.NODE_ENV === 'production', // HTTPS环境下设为true\n        httpOnly: true, // 防止XSS攻击\n        maxAge: 1000 * 60 * 60 * 24 * 7 // 7天过期\n    }\n}))\n\n// 登录路由\napp.post('/auth/login', async (req, res) => {\n    const { email, password } = req.body\n    \n    try {\n        // 验证用户凭据\n        const user = await User.findOne({ email })\n        if (!user || !await bcrypt.compare(password, user.password)) {\n            return res.status(401).json({ error: '邮箱或密码错误' })\n        }\n        \n        // 创建session\n        req.session.userId = user._id\n        req.session.email = user.email\n        \n        res.json({ \n            message: '登录成功',\n            user: {\n                id: user._id,\n                email: user.email,\n                name: user.name\n            }\n        })\n    } catch (error) {\n        res.status(500).json({ error: '服务器错误' })\n    }\n})\n\n// 登出路由\napp.post('/auth/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            return res.status(500).json({ error: '登出失败' })\n        }\n        res.clearCookie('connect.sid')\n        res.json({ message: '登出成功' })\n    })\n})\n\n// 认证中间件\nfunction requireAuth(req, res, next) {\n    if (!req.session.userId) {\n        return res.status(401).json({ error: '请先登录' })\n    }\n    next()\n}\n\n// 受保护的路由\napp.get('/api/profile', requireAuth, async (req, res) => {\n    try {\n        const user = await User.findById(req.session.userId)\n        res.json(user)\n    } catch (error) {\n        res.status(500).json({ error: '获取用户信息失败' })\n    }\n})"
    },
    "passwordSecurity": {
        "title": "密码安全处理",
        "language": "javascript",
        "code": "const bcrypt = require('bcryptjs')\nconst validator = require('validator')\n\n// 密码强度验证\nfunction validatePassword(password) {\n    const minLength = 8\n    const hasUpperCase = /[A-Z]/.test(password)\n    const hasLowerCase = /[a-z]/.test(password)\n    const hasNumbers = /\\d/.test(password)\n    const hasSpecialChar = /[!@#$%^&*(),.?\"{}|<>]/.test(password)\n    \n    if (password.length < minLength) {\n        return { valid: false, message: '密码长度至少8位' }\n    }\n    \n    if (!hasUpperCase || !hasLowerCase) {\n        return { valid: false, message: '密码必须包含大小写字母' }\n    }\n    \n    if (!hasNumbers) {\n        return { valid: false, message: '密码必须包含数字' }\n    }\n    \n    if (!hasSpecialChar) {\n        return { valid: false, message: '密码必须包含特殊字符' }\n    }\n    \n    return { valid: true, message: '密码强度符合要求' }\n}\n\n// 注册用户\napp.post('/auth/register', async (req, res) => {\n    const { email, password, name } = req.body\n    \n    try {\n        // 验证邮箱格式\n        if (!validator.isEmail(email)) {\n            return res.status(400).json({ error: '邮箱格式不正确' })\n        }\n        \n        // 验证密码强度\n        const passwordValidation = validatePassword(password)\n        if (!passwordValidation.valid) {\n            return res.status(400).json({ error: passwordValidation.message })\n        }\n        \n        // 检查邮箱是否已存在\n        const existingUser = await User.findOne({ email })\n        if (existingUser) {\n            return res.status(400).json({ error: '邮箱已被注册' })\n        }\n        \n        // 加密密码\n        const saltRounds = 12\n        const hashedPassword = await bcrypt.hash(password, saltRounds)\n        \n        // 创建用户\n        const user = new User({\n            email,\n            password: hashedPassword,\n            name,\n            createdAt: new Date()\n        })\n        \n        await user.save()\n        \n        res.status(201).json({ \n            message: '注册成功',\n            user: {\n                id: user._id,\n                email: user.email,\n                name: user.name\n            }\n        })\n    } catch (error) {\n        res.status(500).json({ error: '注册失败' })\n    }\n})\n\n// 密码重置\napp.post('/auth/reset-password', async (req, res) => {\n    const { email, newPassword, resetToken } = req.body\n    \n    try {\n        // 验证重置令牌\n        const user = await User.findOne({ \n            email,\n            resetToken,\n            resetTokenExpiry: { $gt: Date.now() }\n        })\n        \n        if (!user) {\n            return res.status(400).json({ error: '重置令牌无效或已过期' })\n        }\n        \n        // 验证新密码\n        const passwordValidation = validatePassword(newPassword)\n        if (!passwordValidation.valid) {\n            return res.status(400).json({ error: passwordValidation.message })\n        }\n        \n        // 更新密码\n        const hashedPassword = await bcrypt.hash(newPassword, 12)\n        user.password = hashedPassword\n        user.resetToken = undefined\n        user.resetTokenExpiry = undefined\n        \n        await user.save()\n        \n        res.json({ message: '密码重置成功' })\n    } catch (error) {\n        res.status(500).json({ error: '密码重置失败' })\n    }\n})"
    },
    "sessionManagement": {
        "title": "会话管理",
        "language": "javascript",
        "code": "// 会话安全配置\nconst sessionConfig = {\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    rolling: true, // 每次请求都重新设置过期时间\n    store: MongoStore.create({\n        mongoUrl: process.env.MONGODB_URI,\n        touchAfter: 24 * 3600,\n        crypto: {\n            secret: process.env.SESSION_ENCRYPT_SECRET\n        }\n    }),\n    cookie: {\n        secure: process.env.NODE_ENV === 'production',\n        httpOnly: true,\n        maxAge: 1000 * 60 * 30, // 30分钟\n        sameSite: 'strict' // CSRF保护\n    }\n}\n\napp.use(session(sessionConfig))\n\n// 会话活动检测中间件\nfunction sessionActivity(req, res, next) {\n    if (req.session.userId) {\n        const now = Date.now()\n        const lastActivity = req.session.lastActivity || now\n        const inactiveTime = now - lastActivity\n        \n        // 30分钟无活动则销毁会话\n        if (inactiveTime > 30 * 60 * 1000) {\n            req.session.destroy((err) => {\n                if (err) console.error('Session destroy error:', err)\n            })\n            return res.status(401).json({ error: '会话已过期，请重新登录' })\n        }\n        \n        // 更新最后活动时间\n        req.session.lastActivity = now\n    }\n    next()\n}\n\n// 并发会话控制\nconst activeSessions = new Map()\n\nfunction limitConcurrentSessions(req, res, next) {\n    if (req.session.userId) {\n        const userId = req.session.userId\n        const sessionId = req.sessionID\n        \n        // 检查是否有其他活跃会话\n        if (activeSessions.has(userId)) {\n            const existingSessionId = activeSessions.get(userId)\n            if (existingSessionId !== sessionId) {\n                // 可选：踢出之前的会话或拒绝新会话\n                activeSessions.set(userId, sessionId)\n                // 这里可以通知用户有新的登录\n            }\n        } else {\n            activeSessions.set(userId, sessionId)\n        }\n    }\n    next()\n}\n\n// 会话清理\nfunction cleanupSessions() {\n    // 定期清理过期的活跃会话记录\n    setInterval(() => {\n        // 这里可以实现更复杂的清理逻辑\n        console.log('Cleaning up expired sessions...')\n    }, 60 * 60 * 1000) // 每小时执行一次\n}\n\n// 安全登出\napp.post('/auth/logout', sessionActivity, (req, res) => {\n    const userId = req.session.userId\n    \n    req.session.destroy((err) => {\n        if (err) {\n            return res.status(500).json({ error: '登出失败' })\n        }\n        \n        // 清理活跃会话记录\n        if (userId) {\n            activeSessions.delete(userId)\n        }\n        \n        res.clearCookie('connect.sid')\n        res.json({ message: '登出成功' })\n    })\n})\n\n// 获取会话信息\napp.get('/auth/session', sessionActivity, (req, res) => {\n    if (!req.session.userId) {\n        return res.status(401).json({ error: '未登录' })\n    }\n    \n    res.json({\n        userId: req.session.userId,\n        email: req.session.email,\n        lastActivity: req.session.lastActivity,\n        expiresAt: req.session.cookie.expires\n    })\n})\n\n// 应用中间件\napp.use(sessionActivity)\napp.use(limitConcurrentSessions)\ncleanupSessions()"
    },
    "jwtBasic": {
        "title": "JWT基础实现",
        "language": "javascript",
        "code": "const jwt = require('jsonwebtoken')\nconst bcrypt = require('bcryptjs')\n\n// JWT配置\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key'\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h'\nconst REFRESH_TOKEN_EXPIRES_IN = '7d'\n\n// 生成令牌对\nfunction generateTokens(user) {\n    const payload = {\n        userId: user._id,\n        email: user.email,\n        name: user.name\n    }\n    \n    const accessToken = jwt.sign(payload, JWT_SECRET, {\n        expiresIn: JWT_EXPIRES_IN\n    })\n    \n    const refreshToken = jwt.sign(\n        { userId: user._id },\n        JWT_SECRET,\n        { expiresIn: REFRESH_TOKEN_EXPIRES_IN }\n    )\n    \n    return { accessToken, refreshToken }\n}\n\n// JWT登录\napp.post('/auth/login', async (req, res) => {\n    const { email, password } = req.body\n    \n    try {\n        // 验证用户\n        const user = await User.findOne({ email })\n        if (!user || !await bcrypt.compare(password, user.password)) {\n            return res.status(401).json({ error: '邮箱或密码错误' })\n        }\n        \n        // 生成令牌\n        const { accessToken, refreshToken } = generateTokens(user)\n        \n        // 保存refresh token到数据库\n        user.refreshToken = refreshToken\n        await user.save()\n        \n        // 设置httpOnly cookie存储refresh token\n        res.cookie('refreshToken', refreshToken, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV === 'production',\n            sameSite: 'strict',\n            maxAge: 7 * 24 * 60 * 60 * 1000 // 7天\n        })\n        \n        res.json({\n            message: '登录成功',\n            accessToken,\n            user: {\n                id: user._id,\n                email: user.email,\n                name: user.name\n            }\n        })\n    } catch (error) {\n        res.status(500).json({ error: '登录失败' })\n    }\n})\n\n// JWT验证中间件\nfunction authenticateToken(req, res, next) {\n    const authHeader = req.headers['authorization']\n    const token = authHeader && authHeader.split(' ')[1]\n    \n    if (!token) {\n        return res.status(401).json({ error: '访问令牌缺失' })\n    }\n    \n    jwt.verify(token, JWT_SECRET, (err, decoded) => {\n        if (err) {\n            if (err.name === 'TokenExpiredError') {\n                return res.status(401).json({ error: '令牌已过期' })\n            }\n            return res.status(403).json({ error: '令牌无效' })\n        }\n        \n        req.user = decoded\n        next()\n    })\n}\n\n// 刷新令牌\napp.post('/auth/refresh', async (req, res) => {\n    const refreshToken = req.cookies.refreshToken\n    \n    if (!refreshToken) {\n        return res.status(401).json({ error: 'Refresh token缺失' })\n    }\n    \n    try {\n        // 验证refresh token\n        const decoded = jwt.verify(refreshToken, JWT_SECRET)\n        \n        // 查找用户并验证refresh token\n        const user = await User.findById(decoded.userId)\n        if (!user || user.refreshToken !== refreshToken) {\n            return res.status(403).json({ error: 'Refresh token无效' })\n        }\n        \n        // 生成新的令牌对\n        const tokens = generateTokens(user)\n        \n        // 更新数据库中的refresh token\n        user.refreshToken = tokens.refreshToken\n        await user.save()\n        \n        // 更新cookie\n        res.cookie('refreshToken', tokens.refreshToken, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV === 'production',\n            sameSite: 'strict',\n            maxAge: 7 * 24 * 60 * 60 * 1000\n        })\n        \n        res.json({\n            accessToken: tokens.accessToken,\n            message: '令牌刷新成功'\n        })\n    } catch (error) {\n        res.status(403).json({ error: 'Refresh token无效' })\n    }\n})\n\n// 受保护的路由示例\napp.get('/api/profile', authenticateToken, async (req, res) => {\n    try {\n        const user = await User.findById(req.user.userId).select('-password -refreshToken')\n        res.json(user)\n    } catch (error) {\n        res.status(500).json({ error: '获取用户信息失败' })\n    }\n})"
    },
    "jwtSecurity": {
        "title": "JWT安全增强",
        "language": "javascript",
        "code": "// 令牌黑名单（Redis实现）\nconst blacklistedTokens = new Set()\n\n// 登出时将令牌加入黑名单\napp.post('/auth/logout', authenticateToken, async (req, res) => {\n    const token = req.headers['authorization'].split(' ')[1]\n    \n    try {\n        // 获取令牌过期时间\n        const decoded = jwt.decode(token)\n        const expiresAt = decoded.exp * 1000 // 转换为毫秒\n        const now = Date.now()\n        \n        if (expiresAt > now) {\n            // 将令牌加入黑名单，设置过期时间\n            const ttl = Math.floor((expiresAt - now) / 1000)\n            await redisClient.setex(`blacklist:${token}`, ttl, 'true')\n        }\n        \n        // 清除refresh token\n        const user = await User.findById(req.user.userId)\n        if (user) {\n            user.refreshToken = null\n            await user.save()\n        }\n        \n        res.clearCookie('refreshToken')\n        res.json({ message: '登出成功' })\n    } catch (error) {\n        res.status(500).json({ error: '登出失败' })\n    }\n})\n\n// 增强的JWT验证中间件\nfunction authenticateTokenWithBlacklist(req, res, next) {\n    const authHeader = req.headers['authorization']\n    const token = authHeader && authHeader.split(' ')[1]\n    \n    if (!token) {\n        return res.status(401).json({ error: '访问令牌缺失' })\n    }\n    \n    // 检查令牌是否在黑名单中\n    redisClient.get(`blacklist:${token}`, (err, result) => {\n        if (result) {\n            return res.status(401).json({ error: '令牌已失效' })\n        }\n        \n        jwt.verify(token, JWT_SECRET, (err, decoded) => {\n            if (err) {\n                if (err.name === 'TokenExpiredError') {\n                    return res.status(401).json({ error: '令牌已过期' })\n                }\n                return res.status(403).json({ error: '令牌无效' })\n            }\n            \n            req.user = decoded\n            next()\n        })\n    })\n}\n\n// 令牌轮换策略\nfunction rotateTokens(req, res, next) {\n    const authHeader = req.headers['authorization']\n    const token = authHeader && authHeader.split(' ')[1]\n    \n    if (token) {\n        const decoded = jwt.decode(token)\n        const now = Math.floor(Date.now() / 1000)\n        const timeUntilExpiry = decoded.exp - now\n        \n        // 如果令牌在5分钟内过期，自动刷新\n        if (timeUntilExpiry < 300) {\n            const newToken = jwt.sign(\n                { \n                    userId: decoded.userId,\n                    email: decoded.email,\n                    name: decoded.name\n                },\n                JWT_SECRET,\n                { expiresIn: JWT_EXPIRES_IN }\n            )\n            \n            res.setHeader('X-New-Token', newToken)\n        }\n    }\n    \n    next()\n}\n\n// 使用增强的中间件\napp.use('/api', authenticateTokenWithBlacklist, rotateTokens)"
    },
    "oauthIntegration": {
        "title": "OAuth第三方登录",
        "language": "javascript",
        "code": "// Google OAuth 2.0配置\nconst passport = require('passport')\nconst GoogleStrategy = require('passport-google-oauth20').Strategy\n\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    callbackURL: \"/auth/google/callback\"\n}, async (accessToken, refreshToken, profile, done) => {\n    try {\n        // 检查用户是否已存在\n        let user = await User.findOne({ googleId: profile.id })\n        \n        if (user) {\n            return done(null, user)\n        }\n        \n        // 创建新用户\n        user = new User({\n            googleId: profile.id,\n            name: profile.displayName,\n            email: profile.emails[0].value,\n            avatar: profile.photos[0].value,\n            provider: 'google'\n        })\n        \n        await user.save()\n        done(null, user)\n    } catch (error) {\n        done(error, null)\n    }\n}))\n\n// Google OAuth路由\napp.get('/auth/google',\n    passport.authenticate('google', { scope: ['profile', 'email'] })\n)\n\napp.get('/auth/google/callback',\n    passport.authenticate('google', { failureRedirect: '/login' }),\n    async (req, res) => {\n        // 生成JWT令牌\n        const token = jwt.sign(\n            { \n                userId: req.user._id,\n                email: req.user.email,\n                name: req.user.name\n            },\n            JWT_SECRET,\n            { expiresIn: JWT_EXPIRES_IN }\n        )\n        \n        // 重定向到前端并传递令牌\n        res.redirect(`${FRONTEND_URL}/auth/success?token=${token}`)\n    }\n)\n\n// GitHub OAuth配置\nconst GitHubStrategy = require('passport-github2').Strategy\n\npassport.use(new GitHubStrategy({\n    clientID: process.env.GITHUB_CLIENT_ID,\n    clientSecret: process.env.GITHUB_CLIENT_SECRET,\n    callbackURL: \"/auth/github/callback\"\n}, async (accessToken, refreshToken, profile, done) => {\n    try {\n        let user = await User.findOne({ githubId: profile.id })\n        \n        if (user) {\n            return done(null, user)\n        }\n        \n        user = new User({\n            githubId: profile.id,\n            name: profile.displayName || profile.username,\n            email: profile.emails?.[0]?.value,\n            avatar: profile.photos?.[0]?.value,\n            provider: 'github'\n        })\n        \n        await user.save()\n        done(null, user)\n    } catch (error) {\n        done(error, null)\n    }\n}))\n\n// GitHub OAuth路由\napp.get('/auth/github',\n    passport.authenticate('github', { scope: ['user:email'] })\n)\n\napp.get('/auth/github/callback',\n    passport.authenticate('github', { failureRedirect: '/login' }),\n    async (req, res) => {\n        const token = jwt.sign(\n            { \n                userId: req.user._id,\n                email: req.user.email,\n                name: req.user.name\n            },\n            JWT_SECRET,\n            { expiresIn: JWT_EXPIRES_IN }\n        )\n        \n        res.redirect(`${FRONTEND_URL}/auth/success?token=${token}`)\n    }\n)"
    }
}
